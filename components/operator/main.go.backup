package main

import (
	"context"
	"fmt"
	"log"
	"os"
	"strings"
	"time"

	batchv1 "k8s.io/api/batch/v1"
	corev1 "k8s.io/api/core/v1"
	rbacv1 "k8s.io/api/rbac/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/resource"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/watch"
	"k8s.io/client-go/dynamic"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
)

// ProjectSettings represents the project configuration for multi-tenancy
type ProjectSettings struct {
	Spec   ProjectSettingsSpec   `json:"spec"`
	Status ProjectSettingsStatus `json:"status"`
}

type ProjectSettingsSpec struct {
	DisplayName         string                 `json:"displayName"`
	Description         string                 `json:"description,omitempty"`
	Bots                []BotConfig            `json:"bots,omitempty"`
	GroupAccess         []GroupAccessConfig    `json:"groupAccess,omitempty"`
	AvailableResources  AvailableResources     `json:"availableResources"`
	Defaults            DefaultSettings        `json:"defaults"`
	Constraints         ProjectConstraints     `json:"constraints"`
}

type ProjectSettingsStatus struct {
	Phase   string `json:"phase"`
	Message string `json:"message,omitempty"`
}

type BotConfig struct {
	Name        string `json:"name"`
	Description string `json:"description,omitempty"`
}

type GroupAccessConfig struct {
	GroupName string `json:"groupName"`
	Role      string `json:"role"`
}

type AvailableResources struct {
	Models           []ModelConfig      `json:"models"`
	ResourceLimits   ResourceLimits     `json:"resourceLimits"`
	PriorityClasses  []string           `json:"priorityClasses"`
	Integrations     []IntegrationConfig `json:"integrations"`
}

type ModelConfig struct {
	Name         string  `json:"name"`
	DisplayName  string  `json:"displayName"`
	CostPerToken float64 `json:"costPerToken"`
	MaxTokens    int     `json:"maxTokens"`
	Default      bool    `json:"default,omitempty"`
}

type ResourceLimits struct {
	CPU                  string `json:"cpu"`
	Memory               string `json:"memory"`
	Storage              string `json:"storage"`
	MaxDurationMinutes   int    `json:"maxDurationMinutes"`
}

type IntegrationConfig struct {
	Type    string `json:"type"`
	Enabled bool   `json:"enabled"`
}

type DefaultSettings struct {
	Model         string  `json:"model"`
	Temperature   float64 `json:"temperature"`
	MaxTokens     int     `json:"maxTokens"`
	Timeout       int     `json:"timeout"`
	PriorityClass string  `json:"priorityClass"`
}

type ProjectConstraints struct {
	MaxConcurrentSessions  int     `json:"maxConcurrentSessions"`
	MaxSessionsPerUser     int     `json:"maxSessionsPerUser"`
	MaxCostPerSession      float64 `json:"maxCostPerSession"`
	MaxCostPerUserPerDay   float64 `json:"maxCostPerUserPerDay"`
	AllowSessionCloning    bool    `json:"allowSessionCloning"`
	AllowBotAccounts       bool    `json:"allowBotAccounts"`
}

// UserContext represents the user context for v1alpha1 sessions
type UserContext struct {
	UserID      string   `json:"userId"`
	DisplayName string   `json:"displayName"`
	Groups      []string `json:"groups"`
}

// BotAccount represents bot account configuration for v1alpha1 sessions
type BotAccount struct {
	ServiceAccountName string `json:"serviceAccountName"`
	Automated          bool   `json:"automated"`
}

// ResourceOverrides represents session-specific resource overrides for v1alpha1 sessions
type ResourceOverrides struct {
	MaxDurationMinutes int    `json:"maxDurationMinutes,omitempty"`
	PriorityClass      string `json:"priorityClass,omitempty"`
}

var (
	k8sClient              *kubernetes.Clientset
	dynamicClient          dynamic.Interface
	namespace              string
	ambientCodeRunnerImage string
	projectSettingsCache   map[string]*ProjectSettings
	cacheMutex             sync.RWMutex
)

func main() {
	// Initialize Kubernetes clients
	if err := initK8sClients(); err != nil {
		log.Fatalf("Failed to initialize Kubernetes clients: %v", err)
	}

	// Initialize project settings cache
	projectSettingsCache = make(map[string]*ProjectSettings)

	// Get namespace from environment or use default
	namespace = os.Getenv("NAMESPACE")
	if namespace == "" {
		namespace = "default"
	}

	// Get ambient-code runner image from environment or use default
	ambientCodeRunnerImage = os.Getenv("AMBIENT_CODE_RUNNER_IMAGE")
	if ambientCodeRunnerImage == "" {
		ambientCodeRunnerImage = "quay.io/ambient_code/vteam_claude_runner:latest"
	}

	log.Printf("Agentic Session Operator starting in namespace: %s", namespace)
	log.Printf("Using ambient-code runner image: %s", ambientCodeRunnerImage)

	// Start watching AgenticSession resources
	go watchAgenticSessions()

	// Start watching for managed namespaces
	go watchNamespaces()

	// Start watching ProjectSettings resources
	go watchProjectSettings()

	// Keep the operator running
	select {}
}

func initK8sClients() error {
	var config *rest.Config
	var err error

	// Try in-cluster config first
	if config, err = rest.InClusterConfig(); err != nil {
		// If in-cluster config fails, try kubeconfig
		kubeconfig := os.Getenv("KUBECONFIG")
		if kubeconfig == "" {
			kubeconfig = fmt.Sprintf("%s/.kube/config", os.Getenv("HOME"))
		}

		if config, err = clientcmd.BuildConfigFromFlags("", kubeconfig); err != nil {
			return fmt.Errorf("failed to create Kubernetes config: %v", err)
		}
	}

	// Create standard Kubernetes client
	k8sClient, err = kubernetes.NewForConfig(config)
	if err != nil {
		return fmt.Errorf("failed to create Kubernetes client: %v", err)
	}

	// Create dynamic client for custom resources
	dynamicClient, err = dynamic.NewForConfig(config)
	if err != nil {
		return fmt.Errorf("failed to create dynamic client: %v", err)
	}

	return nil
}

func getAgenticSessionResource() schema.GroupVersionResource {
	return schema.GroupVersionResource{
		Group:    "vteam.ambient-code",
		Version:  "v1alpha1",
		Resource: "agenticsessions",
	}
}

func getAgenticSessionV1Resource() schema.GroupVersionResource {
	return schema.GroupVersionResource{
		Group:    "vteam.ambient-code",
		Version:  "v1",
		Resource: "agenticsessions",
	}
}

func getProjectSettingsResource() schema.GroupVersionResource {
	return schema.GroupVersionResource{
		Group:    "vteam.ambient-code",
		Version:  "v1alpha1",
		Resource: "projectsettings",
	}
}

func watchAgenticSessions() {
	gvr := getAgenticSessionResource()

	for {
		watcher, err := dynamicClient.Resource(gvr).Namespace(namespace).Watch(context.TODO(), v1.ListOptions{})
		if err != nil {
			log.Printf("Failed to create watcher: %v", err)
			time.Sleep(5 * time.Second)
			continue
		}

		log.Println("Watching for AgenticSession events...")

		for event := range watcher.ResultChan() {
			switch event.Type {
			case watch.Added, watch.Modified:
				obj := event.Object.(*unstructured.Unstructured)

				// Add small delay to avoid race conditions with rapid create/delete cycles
				time.Sleep(100 * time.Millisecond)

				if err := handleAgenticSessionEvent(obj); err != nil {
					log.Printf("Error handling AgenticSession event: %v", err)
				}
			case watch.Deleted:
				obj := event.Object.(*unstructured.Unstructured)
				sessionName := obj.GetName()
				log.Printf("AgenticSession %s deleted", sessionName)

				// Cancel any ongoing job monitoring for this session
				// (We could implement this with a context cancellation if needed)
			case watch.Error:
				obj := event.Object.(*unstructured.Unstructured)
				log.Printf("Watch error for AgenticSession: %v", obj)
			}
		}

		log.Println("Watch channel closed, restarting...")
		watcher.Stop()
		time.Sleep(2 * time.Second)
	}
}

func handleAgenticSessionEvent(obj *unstructured.Unstructured) error {
	name := obj.GetName()
	sessionNamespace := obj.GetNamespace()

	// Detect API version to handle both v1 and v1alpha1
	apiVersion := obj.GetAPIVersion()
	isV1Alpha1 := strings.Contains(apiVersion, "v1alpha1")

	log.Printf("Processing AgenticSession %s (API version: %s) in namespace %s", name, apiVersion, sessionNamespace)

	// Verify the resource still exists before processing
	var gvr schema.GroupVersionResource
	if isV1Alpha1 {
		gvr = getAgenticSessionResource()
	} else {
		gvr = getAgenticSessionV1Resource()
	}

	currentObj, err := dynamicClient.Resource(gvr).Namespace(sessionNamespace).Get(context.TODO(), name, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			log.Printf("AgenticSession %s no longer exists, skipping processing", name)
			return nil
		}
		return fmt.Errorf("failed to verify AgenticSession %s exists: %v", name, err)
	}

	// Get the current status from the fresh object
	status, _, _ := unstructured.NestedMap(currentObj.Object, "status")
	phase, _, _ := unstructured.NestedString(status, "phase")

	log.Printf("Processing AgenticSession %s with phase %s", name, phase)

	// Only process if status is Pending
	if phase != "Pending" {
		return nil
	}

	// For v1alpha1 sessions, perform validation against project settings
	if isV1Alpha1 {
		if err := validateV1Alpha1Session(currentObj); err != nil {
			log.Printf("Validation failed for AgenticSession %s: %v", name, err)
			// Update status to Error
			updateAgenticSessionStatus(name, map[string]interface{}{
				"phase":   "Error",
				"message": fmt.Sprintf("Validation failed: %v", err),
			})
			return fmt.Errorf("validation failed: %v", err)
		}
		log.Printf("Validation passed for v1alpha1 AgenticSession %s", name)
	}

	// Create a Kubernetes Job for this AgenticSession
	jobName := fmt.Sprintf("%s-job", name)

	// Check if job already exists
	_, err = k8sClient.BatchV1().Jobs(sessionNamespace).Get(context.TODO(), jobName, v1.GetOptions{})
	if err == nil {
		log.Printf("Job %s already exists for AgenticSession %s", jobName, name)
		return nil
	}

	// Extract spec information from the fresh object
	spec, _, _ := unstructured.NestedMap(currentObj.Object, "spec")
	prompt, _, _ := unstructured.NestedString(spec, "prompt")
	websiteURL, _, _ := unstructured.NestedString(spec, "websiteURL")
	timeout, _, _ := unstructured.NestedInt64(spec, "timeout")

	llmSettings, _, _ := unstructured.NestedMap(spec, "llmSettings")
	model, _, _ := unstructured.NestedString(llmSettings, "model")
	temperature, _, _ := unstructured.NestedFloat64(llmSettings, "temperature")
	maxTokens, _, _ := unstructured.NestedInt64(llmSettings, "maxTokens")

	// Extract v1alpha1 features
	var userContext UserContext
	var botAccount *BotAccount
	var resourceOverrides *ResourceOverrides
	var serviceAccountName string = "default"

	if isV1Alpha1 {
		userContext = extractUserContextFromSession(currentObj)
		botAccount = extractBotAccountFromSession(currentObj)
		resourceOverrides = extractResourceOverridesFromSession(currentObj)

		// Use bot service account if specified
		if botAccount != nil {
			serviceAccountName = botAccount.ServiceAccountName
		}
	} else {
		// Default user context for v1 sessions
		userContext = extractUserContextFromSession(currentObj)
	}

	// Determine owner reference API version
	ownerAPIVersion := "vteam.ambient-code/v1"
	if isV1Alpha1 {
		ownerAPIVersion = "vteam.ambient-code/v1alpha1"
	}

	// Create the Job
	job := &batchv1.Job{
		ObjectMeta: v1.ObjectMeta{
			Name:      jobName,
			Namespace: sessionNamespace,
			Labels: map[string]string{
				"agentic-session": name,
				"app":             "ambient-code-runner",
				"api-version":     apiVersion,
				"user-id":         userContext.UserID,
			},
			OwnerReferences: []v1.OwnerReference{
				{
					APIVersion: ownerAPIVersion,
					Kind:       "AgenticSession",
					Name:       currentObj.GetName(),
					UID:        currentObj.GetUID(),
					Controller: boolPtr(true),
					// Remove BlockOwnerDeletion to avoid permission issues
					// BlockOwnerDeletion: boolPtr(true),
				},
			},
		},
		Spec: batchv1.JobSpec{
			BackoffLimit: int32Ptr(3),
			ActiveDeadlineSeconds: func() *int64 {
				// Use resource overrides if available, otherwise default
				if resourceOverrides != nil && resourceOverrides.MaxDurationMinutes > 0 {
					return int64Ptr(int64(resourceOverrides.MaxDurationMinutes * 60))
				}
				// Default 30 minute timeout for safety
				return int64Ptr(1800)
			}(),
			Template: corev1.PodTemplateSpec{
				ObjectMeta: v1.ObjectMeta{
					Labels: map[string]string{
						"agentic-session": name,
						"app":             "ambient-code-runner",
					},
					// If you run a service mesh that injects sidecars and causes egress issues for Jobs:
					// Annotations: map[string]string{"sidecar.istio.io/inject": "false"},
				},
				Spec: corev1.PodSpec{
					RestartPolicy:      corev1.RestartPolicyNever,
					ServiceAccountName: serviceAccountName,

					// âš ï¸ Let OpenShift SCC choose UID/GID dynamically (restricted-v2 compatible)
					// SecurityContext omitted to allow SCC assignment

					// ðŸ”§ Optional: Shared memory volume (may need to be removed if SCC restricts it)
					Volumes: []corev1.Volume{
						{
							Name: "dshm",
							VolumeSource: corev1.VolumeSource{
								EmptyDir: &corev1.EmptyDirVolumeSource{
									Medium:    corev1.StorageMediumMemory,
									SizeLimit: resource.NewQuantity(256*1024*1024, resource.BinarySI),
								},
							},
						},
					},

					Containers: []corev1.Container{
						{
							Name:  "ambient-code-runner",
							Image: ambientCodeRunnerImage,
							// ðŸ”’ Container-level security (SCC-compatible, no privileged capabilities)
							SecurityContext: &corev1.SecurityContext{
								AllowPrivilegeEscalation: boolPtr(false),
								ReadOnlyRootFilesystem:   boolPtr(false), // Playwright needs to write temp files
								Capabilities: &corev1.Capabilities{
									Drop: []corev1.Capability{"ALL"}, // Drop all capabilities for security
								},
							},

							// ðŸ“¦ Mount shared memory volume
							VolumeMounts: []corev1.VolumeMount{
								{Name: "dshm", MountPath: "/dev/shm"},
							},

							Env: []corev1.EnvVar{
								{Name: "AGENTIC_SESSION_NAME", Value: name},
								{Name: "AGENTIC_SESSION_NAMESPACE", Value: sessionNamespace},
								{Name: "PROMPT", Value: prompt},
								{Name: "WEBSITE_URL", Value: websiteURL},
								{Name: "LLM_MODEL", Value: model},
								{Name: "LLM_TEMPERATURE", Value: fmt.Sprintf("%.2f", temperature)},
								{Name: "LLM_MAX_TOKENS", Value: fmt.Sprintf("%d", maxTokens)},
								{Name: "TIMEOUT", Value: fmt.Sprintf("%d", timeout)},
								{Name: "BACKEND_API_URL", Value: os.Getenv("BACKEND_API_URL")},

								// v1alpha1 user context
								{Name: "USER_ID", Value: userContext.UserID},
								{Name: "USER_DISPLAY_NAME", Value: userContext.DisplayName},
								{Name: "USER_GROUPS", Value: strings.Join(userContext.Groups, ",")},
								{Name: "API_VERSION", Value: apiVersion},
								{Name: "IS_BOT_SESSION", Value: strconv.FormatBool(botAccount != nil)},

								// ðŸ”‘ Anthropic key from Secret
								{
									Name: "ANTHROPIC_API_KEY",
									ValueFrom: &corev1.EnvVarSource{
										SecretKeyRef: &corev1.SecretKeySelector{
											LocalObjectReference: corev1.LocalObjectReference{Name: "ambient-code-secrets"},
											Key:                  "anthropic-api-key",
										},
									},
								},

								// âœ… Use /tmp for SCC-assigned random UID (OpenShift compatible)
								{Name: "HOME", Value: "/tmp"},
								{Name: "XDG_CONFIG_HOME", Value: "/tmp/.config"},
								{Name: "XDG_CACHE_HOME", Value: "/tmp/.cache"},
								{Name: "XDG_DATA_HOME", Value: "/tmp/.local/share"},

								// ðŸ§Š Playwright/Chromium optimized for containers with shared memory
								{Name: "PW_CHROMIUM_ARGS", Value: "--no-sandbox --disable-gpu"},

								// ðŸ“ Playwright browser cache in writable location
								{Name: "PLAYWRIGHT_BROWSERS_PATH", Value: "/tmp/.cache/ms-playwright"},

								// (Optional) proxy envs if your cluster requires them:
								// { Name: "HTTPS_PROXY", Value: "http://proxy.corp:3128" },
								// { Name: "NO_PROXY",    Value: ".svc,.cluster.local,10.0.0.0/8" },
							},

							Resources: corev1.ResourceRequirements{
								Requests: corev1.ResourceList{
									corev1.ResourceCPU:    resource.MustParse("1000m"),
									corev1.ResourceMemory: resource.MustParse("2Gi"),
								},
								Limits: corev1.ResourceList{
									corev1.ResourceCPU:    resource.MustParse("2000m"),
									corev1.ResourceMemory: resource.MustParse("4Gi"),
								},
							},
						},
					},
				},
			},
		},
	}

	// Update status to Creating before attempting job creation
	if err := updateAgenticSessionStatus(name, map[string]interface{}{
		"phase":   "Creating",
		"message": "Creating Kubernetes job",
	}); err != nil {
		log.Printf("Failed to update AgenticSession status to Creating: %v", err)
		// Continue anyway - resource might have been deleted
	}

	// Create the job
	_, err = k8sClient.BatchV1().Jobs(namespace).Create(context.TODO(), job, v1.CreateOptions{})
	if err != nil {
		log.Printf("Failed to create job %s: %v", jobName, err)
		// Update status to Error if job creation fails and resource still exists
		updateAgenticSessionStatus(name, map[string]interface{}{
			"phase":   "Error",
			"message": fmt.Sprintf("Failed to create job: %v", err),
		})
		return fmt.Errorf("failed to create job: %v", err)
	}

	log.Printf("Created job %s for AgenticSession %s", jobName, name)

	// Update AgenticSession status to Running
	if err := updateAgenticSessionStatus(name, map[string]interface{}{
		"phase":     "Running",
		"message":   "Job created and running",
		"startTime": time.Now().Format(time.RFC3339),
		"jobName":   jobName,
	}); err != nil {
		log.Printf("Failed to update AgenticSession status to Running: %v", err)
		// Don't return error here - the job was created successfully
		// The status update failure might be due to the resource being deleted
	}

	// Start monitoring the job
	go monitorJob(jobName, name)

	return nil
}

func monitorJob(jobName, sessionName string) {
	log.Printf("Starting job monitoring for %s (session: %s)", jobName, sessionName)

	for {
		time.Sleep(10 * time.Second)

		// First check if the AgenticSession still exists
		gvr := getAgenticSessionResource()
		if _, err := dynamicClient.Resource(gvr).Namespace(namespace).Get(context.TODO(), sessionName, v1.GetOptions{}); err != nil {
			if errors.IsNotFound(err) {
				log.Printf("AgenticSession %s no longer exists, stopping job monitoring for %s", sessionName, jobName)
				return
			}
			log.Printf("Error checking AgenticSession %s existence: %v", sessionName, err)
			// Continue monitoring even if we can't check the session
		}

		job, err := k8sClient.BatchV1().Jobs(namespace).Get(context.TODO(), jobName, v1.GetOptions{})
		if err != nil {
			if errors.IsNotFound(err) {
				log.Printf("Job %s not found, stopping monitoring", jobName)
				return
			}
			log.Printf("Error getting job %s: %v", jobName, err)
			continue
		}

		// Check job status
		if job.Status.Succeeded > 0 {
			log.Printf("Job %s completed successfully", jobName)

			// Update AgenticSession status to Completed
			updateAgenticSessionStatus(sessionName, map[string]interface{}{
				"phase":          "Completed",
				"message":        "Job completed successfully",
				"completionTime": time.Now().Format(time.RFC3339),
			})
			return
		}

		if job.Status.Failed >= *job.Spec.BackoffLimit {
			log.Printf("Job %s failed after %d attempts", jobName, job.Status.Failed)

			// Get pod logs for error information
			errorMessage := "Job failed"
			if pods, err := k8sClient.CoreV1().Pods(namespace).List(context.TODO(), v1.ListOptions{
				LabelSelector: fmt.Sprintf("job-name=%s", jobName),
			}); err == nil && len(pods.Items) > 0 {
				// Try to get logs from the first pod
				pod := pods.Items[0]
				if logs, err := k8sClient.CoreV1().Pods(namespace).GetLogs(pod.Name, &corev1.PodLogOptions{}).DoRaw(context.TODO()); err == nil {
					errorMessage = fmt.Sprintf("Job failed: %s", string(logs))
					if len(errorMessage) > 500 {
						errorMessage = errorMessage[:500] + "..."
					}
				}
			}

			// Update AgenticSession status to Failed
			updateAgenticSessionStatus(sessionName, map[string]interface{}{
				"phase":          "Failed",
				"message":        errorMessage,
				"completionTime": time.Now().Format(time.RFC3339),
			})
			return
		}
	}
}

func updateAgenticSessionStatus(name string, statusUpdate map[string]interface{}) error {
	gvr := getAgenticSessionResource()

	// Get current resource
	obj, err := dynamicClient.Resource(gvr).Namespace(namespace).Get(context.TODO(), name, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			log.Printf("AgenticSession %s no longer exists, skipping status update", name)
			return nil // Don't treat this as an error - resource was deleted
		}
		return fmt.Errorf("failed to get AgenticSession %s: %v", name, err)
	}

	// Update status
	if obj.Object["status"] == nil {
		obj.Object["status"] = make(map[string]interface{})
	}

	status := obj.Object["status"].(map[string]interface{})
	for key, value := range statusUpdate {
		status[key] = value
	}

	// Update the resource with retry logic
	_, err = dynamicClient.Resource(gvr).Namespace(namespace).UpdateStatus(context.TODO(), obj, v1.UpdateOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			log.Printf("AgenticSession %s was deleted during status update, skipping", name)
			return nil // Don't treat this as an error - resource was deleted
		}
		return fmt.Errorf("failed to update AgenticSession status: %v", err)
	}

	return nil
}

func watchNamespaces() {
	for {
		watcher, err := k8sClient.CoreV1().Namespaces().Watch(context.TODO(), v1.ListOptions{
			LabelSelector: "ambient-code.io/managed=true",
		})
		if err != nil {
			log.Printf("Failed to create namespace watcher: %v", err)
			time.Sleep(5 * time.Second)
			continue
		}

		log.Println("Watching for managed namespaces...")

		for event := range watcher.ResultChan() {
			switch event.Type {
			case watch.Added:
				namespace := event.Object.(*corev1.Namespace)
				log.Printf("Detected new managed namespace: %s", namespace.Name)

				// Auto-create ProjectSettings for this namespace
				if err := createDefaultProjectSettings(namespace.Name); err != nil {
					log.Printf("Error creating default ProjectSettings for namespace %s: %v", namespace.Name, err)
				}
			case watch.Error:
				obj := event.Object.(*unstructured.Unstructured)
				log.Printf("Watch error for namespaces: %v", obj)
			}
		}

		log.Println("Namespace watch channel closed, restarting...")
		watcher.Stop()
		time.Sleep(2 * time.Second)
	}
}

func watchProjectSettings() {
	gvr := getProjectSettingsResource()

	for {
		// Watch across all namespaces for ProjectSettings
		watcher, err := dynamicClient.Resource(gvr).Watch(context.TODO(), v1.ListOptions{})
		if err != nil {
			log.Printf("Failed to create ProjectSettings watcher: %v", err)
			time.Sleep(5 * time.Second)
			continue
		}

		log.Println("Watching for ProjectSettings events...")

		for event := range watcher.ResultChan() {
			switch event.Type {
			case watch.Added, watch.Modified:
				obj := event.Object.(*unstructured.Unstructured)

				// Add small delay to avoid race conditions
				time.Sleep(100 * time.Millisecond)

				if err := handleProjectSettingsEvent(obj); err != nil {
					log.Printf("Error handling ProjectSettings event: %v", err)
				}
			case watch.Deleted:
				obj := event.Object.(*unstructured.Unstructured)
				settingsName := obj.GetName()
				settingsNamespace := obj.GetNamespace()
				log.Printf("ProjectSettings %s/%s deleted", settingsNamespace, settingsName)
			case watch.Error:
				obj := event.Object.(*unstructured.Unstructured)
				log.Printf("Watch error for ProjectSettings: %v", obj)
			}
		}

		log.Println("ProjectSettings watch channel closed, restarting...")
		watcher.Stop()
		time.Sleep(2 * time.Second)
	}
}

func createDefaultProjectSettings(namespaceName string) error {
	gvr := getProjectSettingsResource()

	// Check if ProjectSettings already exists in this namespace
	_, err := dynamicClient.Resource(gvr).Namespace(namespaceName).Get(context.TODO(), "default", v1.GetOptions{})
	if err == nil {
		log.Printf("ProjectSettings already exists in namespace %s", namespaceName)
		return nil
	}

	if !errors.IsNotFound(err) {
		return fmt.Errorf("error checking existing ProjectSettings: %v", err)
	}

	// Create default ProjectSettings
	defaultSettings := &unstructured.Unstructured{
		Object: map[string]interface{}{
			"apiVersion": "vteam.ambient-code/v1alpha1",
			"kind":       "ProjectSettings",
			"metadata": map[string]interface{}{
				"name":      "default",
				"namespace": namespaceName,
			},
			"spec": map[string]interface{}{
				"displayName": fmt.Sprintf("Default settings for %s", namespaceName),
				"description": "Auto-generated default project settings",
				"bots":        []interface{}{},
				"groupAccess": []interface{}{},
				"availableResources": map[string]interface{}{
					"models": []interface{}{
						map[string]interface{}{
							"name":         "claude-3-5-sonnet-20241022",
							"displayName":  "Claude 3.5 Sonnet",
							"costPerToken": 0.003,
							"maxTokens":    200000,
							"default":      true,
						},
					},
					"resourceLimits": map[string]interface{}{
						"cpu":                "2000m",
						"memory":             "4Gi",
						"storage":            "10Gi",
						"maxDurationMinutes": 60,
					},
					"priorityClasses": []interface{}{"low", "normal", "high"},
					"integrations": []interface{}{
						map[string]interface{}{"type": "browser", "enabled": true},
						map[string]interface{}{"type": "code-execution", "enabled": true},
						map[string]interface{}{"type": "file-upload", "enabled": false},
					},
				},
				"defaults": map[string]interface{}{
					"model":         "claude-3-5-sonnet-20241022",
					"temperature":   0.7,
					"maxTokens":     4000,
					"timeout":       1800,
					"priorityClass": "normal",
				},
				"constraints": map[string]interface{}{
					"maxConcurrentSessions": 5,
					"maxSessionsPerUser":    10,
					"maxCostPerSession":     50.0,
					"maxCostPerUserPerDay":  200.0,
					"allowSessionCloning":   true,
					"allowBotAccounts":      true,
				},
			},
			"status": map[string]interface{}{
				"phase": "Pending",
			},
		},
	}

	_, err = dynamicClient.Resource(gvr).Namespace(namespaceName).Create(context.TODO(), defaultSettings, v1.CreateOptions{})
	if err != nil {
		return fmt.Errorf("failed to create default ProjectSettings: %v", err)
	}

	log.Printf("Created default ProjectSettings for namespace %s", namespaceName)
	return nil
}

func handleProjectSettingsEvent(obj *unstructured.Unstructured) error {
	name := obj.GetName()
	namespace := obj.GetNamespace()

	// Verify the resource still exists before processing
	gvr := getProjectSettingsResource()
	currentObj, err := dynamicClient.Resource(gvr).Namespace(namespace).Get(context.TODO(), name, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			log.Printf("ProjectSettings %s/%s no longer exists, skipping processing", namespace, name)
			return nil
		}
		return fmt.Errorf("failed to verify ProjectSettings %s/%s exists: %v", namespace, name, err)
	}

	// Get the current status
	status, _, _ := unstructured.NestedMap(currentObj.Object, "status")
	phase, _, _ := unstructured.NestedString(status, "phase")

	log.Printf("Processing ProjectSettings %s/%s with phase %s", namespace, name, phase)

	// Only process if status is Pending or if we need to reconcile
	if phase != "Pending" && phase != "" {
		// Still perform reconciliation to ensure resources are up to date
		return reconcileProjectSettings(currentObj)
	}

	// Update status to Active before processing
	if err := updateProjectSettingsStatus(namespace, name, map[string]interface{}{
		"phase":   "Active",
		"message": "Processing project settings",
	}); err != nil {
		log.Printf("Failed to update ProjectSettings status: %v", err)
	}

	return reconcileProjectSettings(currentObj)
}

func reconcileProjectSettings(obj *unstructured.Unstructured) error {
	namespace := obj.GetNamespace()
	name := obj.GetName()

	spec, _, _ := unstructured.NestedMap(obj.Object, "spec")

	// Reconcile bots (ServiceAccounts)
	botsCreated := 0
	if bots, found, _ := unstructured.NestedSlice(spec, "bots"); found {
		for _, botInterface := range bots {
			bot := botInterface.(map[string]interface{})
			botName, _, _ := unstructured.NestedString(bot, "name")
			if botName != "" {
				if err := ensureServiceAccount(namespace, botName); err != nil {
					log.Printf("Error creating ServiceAccount %s in namespace %s: %v", botName, namespace, err)
					continue
				}
				botsCreated++
			}
		}
	}

	// Reconcile group access (RoleBindings)
	groupBindingsCreated := 0
	if groupAccess, found, _ := unstructured.NestedSlice(spec, "groupAccess"); found {
		for _, accessInterface := range groupAccess {
			access := accessInterface.(map[string]interface{})
			groupName, _, _ := unstructured.NestedString(access, "groupName")
			role, _, _ := unstructured.NestedString(access, "role")
			if groupName != "" && role != "" {
				if err := ensureRoleBinding(namespace, groupName, role); err != nil {
					log.Printf("Error creating RoleBinding for group %s in namespace %s: %v", groupName, namespace, err)
					continue
				}
				groupBindingsCreated++
			}
		}
	}

	// Update status with reconciliation results
	conditions := []interface{}{
		map[string]interface{}{
			"type":               "BotsReady",
			"status":             "True",
			"reason":             "ServiceAccountsCreated",
			"message":            fmt.Sprintf("%d ServiceAccounts created successfully", botsCreated),
			"lastTransitionTime": time.Now().Format(time.RFC3339),
		},
		map[string]interface{}{
			"type":               "RBACReady",
			"status":             "True",
			"reason":             "RoleBindingsCreated",
			"message":            fmt.Sprintf("%d RoleBindings created successfully", groupBindingsCreated),
			"lastTransitionTime": time.Now().Format(time.RFC3339),
		},
	}

	statusUpdate := map[string]interface{}{
		"phase":                  "Active",
		"botsCreated":            botsCreated,
		"groupBindingsCreated":   groupBindingsCreated,
		"lastReconciled":         time.Now().Format(time.RFC3339),
		"conditions":             conditions,
	}

	return updateProjectSettingsStatus(namespace, name, statusUpdate)
}

func ensureServiceAccount(namespace, name string) error {
	// Check if ServiceAccount already exists
	_, err := k8sClient.CoreV1().ServiceAccounts(namespace).Get(context.TODO(), name, v1.GetOptions{})
	if err == nil {
		log.Printf("ServiceAccount %s already exists in namespace %s", name, namespace)
		return nil
	}

	if !errors.IsNotFound(err) {
		return fmt.Errorf("error checking existing ServiceAccount: %v", err)
	}

	// Create ServiceAccount
	sa := &corev1.ServiceAccount{
		ObjectMeta: v1.ObjectMeta{
			Name:      name,
			Namespace: namespace,
			Labels: map[string]string{
				"ambient-code.io/managed": "true",
				"ambient-code.io/bot":     "true",
			},
		},
	}

	_, err = k8sClient.CoreV1().ServiceAccounts(namespace).Create(context.TODO(), sa, v1.CreateOptions{})
	if err != nil {
		return fmt.Errorf("failed to create ServiceAccount: %v", err)
	}

	log.Printf("Created ServiceAccount %s in namespace %s", name, namespace)
	return nil
}

func ensureRoleBinding(namespace, groupName, role string) error {
	// Map role to actual Kubernetes role
	roleName := mapRoleToKubernetesRole(role)
	rbName := fmt.Sprintf("%s-%s", groupName, role)

	// Check if RoleBinding already exists
	_, err := k8sClient.RbacV1().RoleBindings(namespace).Get(context.TODO(), rbName, v1.GetOptions{})
	if err == nil {
		log.Printf("RoleBinding %s already exists in namespace %s", rbName, namespace)
		return nil
	}

	if !errors.IsNotFound(err) {
		return fmt.Errorf("error checking existing RoleBinding: %v", err)
	}

	// Create RoleBinding
    rb := &rbacv1.RoleBinding{
		ObjectMeta: v1.ObjectMeta{
			Name:      rbName,
			Namespace: namespace,
			Labels: map[string]string{
				"ambient-code.io/managed": "true",
			},
		},
        RoleRef: rbacv1.RoleRef{
            APIGroup: "rbac.authorization.k8s.io",
            Kind:     "ClusterRole",
            Name:     roleName,
        },
		Subjects: []rbacv1.Subject{
			{
				Kind:     "Group",
				Name:     groupName,
				APIGroup: "rbac.authorization.k8s.io",
			},
		},
	}

	_, err = k8sClient.RbacV1().RoleBindings(namespace).Create(context.TODO(), rb, v1.CreateOptions{})
	if err != nil {
		return fmt.Errorf("failed to create RoleBinding: %v", err)
	}

	log.Printf("Created RoleBinding %s for group %s in namespace %s", rbName, groupName, namespace)
	return nil
}

func mapRoleToKubernetesRole(role string) string {
	switch strings.ToLower(role) {
	case "admin":
        return "ambient-project-admin"
	case "edit":
        return "ambient-project-edit"
	case "view":
        return "ambient-project-view"
	default:
        return "ambient-project-view" // Default to view role
	}
}

func updateProjectSettingsStatus(namespace, name string, statusUpdate map[string]interface{}) error {
	gvr := getProjectSettingsResource()

	// Get current resource
	obj, err := dynamicClient.Resource(gvr).Namespace(namespace).Get(context.TODO(), name, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			log.Printf("ProjectSettings %s/%s no longer exists, skipping status update", namespace, name)
			return nil
		}
		return fmt.Errorf("failed to get ProjectSettings %s/%s: %v", namespace, name, err)
	}

	// Update status
	if obj.Object["status"] == nil {
		obj.Object["status"] = make(map[string]interface{})
	}

	status := obj.Object["status"].(map[string]interface{})
	for key, value := range statusUpdate {
		status[key] = value
	}

	// Update the resource
	_, err = dynamicClient.Resource(gvr).Namespace(namespace).UpdateStatus(context.TODO(), obj, v1.UpdateOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			log.Printf("ProjectSettings %s/%s was deleted during status update, skipping", namespace, name)
			return nil
		}
		return fmt.Errorf("failed to update ProjectSettings status: %v", err)
	}

	return nil
}

// validateV1Alpha1Session validates v1alpha1 session against project constraints
func validateV1Alpha1Session(obj *unstructured.Unstructured) error {
	sessionNamespace := obj.GetNamespace()

	// Get ProjectSettings from cache
	cacheMutex.RLock()
	projectSettings, exists := projectSettingsCache[sessionNamespace]
	cacheMutex.RUnlock()

	if !exists {
		return fmt.Errorf("no ProjectSettings found for namespace %s", sessionNamespace)
	}

	spec, _, _ := unstructured.NestedMap(obj.Object, "spec")

	// Validate userContext if present
	if userContextRaw, found, _ := unstructured.NestedMap(spec, "userContext"); found {
		if err := validateUserContext(userContextRaw, sessionNamespace); err != nil {
			return fmt.Errorf("userContext validation failed: %v", err)
		}
	}

	// Validate botAccount if present
	if botAccountRaw, found, _ := unstructured.NestedMap(spec, "botAccount"); found {
		if err := validateBotAccount(botAccountRaw, sessionNamespace, projectSettings); err != nil {
			return fmt.Errorf("botAccount validation failed: %v", err)
		}
	}

	// Validate resource overrides
	if resourceOverridesRaw, found, _ := unstructured.NestedMap(spec, "resourceOverrides"); found {
		if err := validateResourceOverrides(resourceOverridesRaw, projectSettings); err != nil {
			return fmt.Errorf("resourceOverrides validation failed: %v", err)
		}
	}

	// Validate LLM settings against available models
	if llmSettings, found, _ := unstructured.NestedMap(spec, "llmSettings"); found {
		if err := validateLLMSettings(llmSettings, projectSettings); err != nil {
			return fmt.Errorf("llmSettings validation failed: %v", err)
		}
	}

	// Check project constraints
	if err := checkProjectConstraints(sessionNamespace, projectSettings); err != nil {
		return fmt.Errorf("project constraints validation failed: %v", err)
	}

	return nil
}

// validateUserContext validates user context for RBAC permissions
func validateUserContext(userContextRaw map[string]interface{}, namespace string) error {
	userId, _, _ := unstructured.NestedString(userContextRaw, "userId")
	if userId == "" {
		return fmt.Errorf("userId is required in userContext")
	}

	// TODO: Implement actual RBAC validation against Kubernetes RBAC
	// This would typically involve checking if the user has permissions to create sessions
	// in the target namespace through SubjectAccessReview
	log.Printf("Validating user %s permissions in namespace %s", userId, namespace)

	return nil
}

// validateBotAccount validates bot account configuration
func validateBotAccount(botAccountRaw map[string]interface{}, namespace string, projectSettings *ProjectSettings) error {
	serviceAccountName, _, _ := unstructured.NestedString(botAccountRaw, "serviceAccountName")
	if serviceAccountName == "" {
		return fmt.Errorf("serviceAccountName is required in botAccount")
	}

	// Check if bot accounts are allowed in this project
	if !projectSettings.Spec.Constraints.AllowBotAccounts {
		return fmt.Errorf("bot accounts are not allowed in this project")
	}

	// Verify ServiceAccount exists
	_, err := k8sClient.CoreV1().ServiceAccounts(namespace).Get(context.TODO(), serviceAccountName, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			return fmt.Errorf("ServiceAccount %s not found in namespace %s", serviceAccountName, namespace)
		}
		return fmt.Errorf("error checking ServiceAccount %s: %v", serviceAccountName, err)
	}

	// Verify ServiceAccount is configured as a bot
	// (Should have the appropriate labels and be listed in ProjectSettings)
	botFound := false
	for _, bot := range projectSettings.Spec.Bots {
		if bot.Name == serviceAccountName {
			botFound = true
			break
		}
	}

	if !botFound {
		return fmt.Errorf("ServiceAccount %s is not configured as a bot in ProjectSettings", serviceAccountName)
	}

	return nil
}

// validateResourceOverrides validates session-specific resource overrides
func validateResourceOverrides(resourceOverridesRaw map[string]interface{}, projectSettings *ProjectSettings) error {
	maxDurationMinutes, found, _ := unstructured.NestedInt64(resourceOverridesRaw, "maxDurationMinutes")
	if found {
		if maxDurationMinutes > int64(projectSettings.Spec.AvailableResources.ResourceLimits.MaxDurationMinutes) {
			return fmt.Errorf("maxDurationMinutes override (%d) exceeds project limit (%d)",
				maxDurationMinutes, projectSettings.Spec.AvailableResources.ResourceLimits.MaxDurationMinutes)
		}
	}

	priorityClass, found, _ := unstructured.NestedString(resourceOverridesRaw, "priorityClass")
	if found {
		// Check if priority class is available in project
		priorityClassAllowed := false
		for _, pc := range projectSettings.Spec.AvailableResources.PriorityClasses {
			if pc == priorityClass {
				priorityClassAllowed = true
				break
			}
		}
		if !priorityClassAllowed {
			return fmt.Errorf("priorityClass %s is not available in this project", priorityClass)
		}
	}

	return nil
}

// validateLLMSettings validates LLM settings against available models
func validateLLMSettings(llmSettings map[string]interface{}, projectSettings *ProjectSettings) error {
	model, _, _ := unstructured.NestedString(llmSettings, "model")
	if model == "" {
		return nil // Use default model
	}

	// Check if model is available in project
	modelFound := false
	for _, availableModel := range projectSettings.Spec.AvailableResources.Models {
		if availableModel.Name == model {
			modelFound = true
			break
		}
	}

	if !modelFound {
		return fmt.Errorf("model %s is not available in this project", model)
	}

	return nil
}

// checkProjectConstraints validates against project-level constraints
func checkProjectConstraints(namespace string, projectSettings *ProjectSettings) error {
	// Count current active sessions in the namespace
	gvr := getAgenticSessionResource()
	sessionList, err := dynamicClient.Resource(gvr).Namespace(namespace).List(context.TODO(), v1.ListOptions{})
	if err != nil {
		return fmt.Errorf("error listing sessions in namespace %s: %v", namespace, err)
	}

	activeSessions := 0
	for _, item := range sessionList.Items {
		status, _, _ := unstructured.NestedMap(item.Object, "status")
		phase, _, _ := unstructured.NestedString(status, "phase")
		if phase == "Pending" || phase == "Creating" || phase == "Running" {
			activeSessions++
		}
	}

	// Check max concurrent sessions constraint
	if activeSessions >= projectSettings.Spec.Constraints.MaxConcurrentSessions {
		return fmt.Errorf("maximum concurrent sessions (%d) exceeded in project",
			projectSettings.Spec.Constraints.MaxConcurrentSessions)
	}

	return nil
}

// extractUserContextFromSession extracts user context from session, providing defaults for v1 sessions
func extractUserContextFromSession(obj *unstructured.Unstructured) UserContext {
	spec, _, _ := unstructured.NestedMap(obj.Object, "spec")

	// Check for v1alpha1 userContext
	if userContextRaw, found, _ := unstructured.NestedMap(spec, "userContext"); found {
		userId, _, _ := unstructured.NestedString(userContextRaw, "userId")
		displayName, _, _ := unstructured.NestedString(userContextRaw, "displayName")
		groupsRaw, _, _ := unstructured.NestedSlice(userContextRaw, "groups")

		var groups []string
		for _, g := range groupsRaw {
			if group, ok := g.(string); ok {
				groups = append(groups, group)
			}
		}

		return UserContext{
			UserID:      userId,
			DisplayName: displayName,
			Groups:      groups,
		}
	}

	// Default values for v1 sessions (backward compatibility)
	return UserContext{
		UserID:      "system-migration",
		DisplayName: "System Migration",
		Groups:      []string{"migrated-users"},
	}
}

// extractBotAccountFromSession extracts bot account from session if present
func extractBotAccountFromSession(obj *unstructured.Unstructured) *BotAccount {
	spec, _, _ := unstructured.NestedMap(obj.Object, "spec")

	if botAccountRaw, found, _ := unstructured.NestedMap(spec, "botAccount"); found {
		serviceAccountName, _, _ := unstructured.NestedString(botAccountRaw, "serviceAccountName")
		automated, _, _ := unstructured.NestedBool(botAccountRaw, "automated")

		return &BotAccount{
			ServiceAccountName: serviceAccountName,
			Automated:          automated,
		}
	}

	return nil
}

// extractResourceOverridesFromSession extracts resource overrides from session if present
func extractResourceOverridesFromSession(obj *unstructured.Unstructured) *ResourceOverrides {
	spec, _, _ := unstructured.NestedMap(obj.Object, "spec")

	if resourceOverridesRaw, found, _ := unstructured.NestedMap(spec, "resourceOverrides"); found {
		maxDurationMinutes, foundDuration, _ := unstructured.NestedInt64(resourceOverridesRaw, "maxDurationMinutes")
		priorityClass, foundPriority, _ := unstructured.NestedString(resourceOverridesRaw, "priorityClass")

		overrides := &ResourceOverrides{}
		if foundDuration {
			overrides.MaxDurationMinutes = int(maxDurationMinutes)
		}
		if foundPriority {
			overrides.PriorityClass = priorityClass
		}

		return overrides
	}

	return nil
}

var (
	boolPtr  = func(b bool) *bool { return &b }
	int32Ptr = func(i int32) *int32 { return &i }
	int64Ptr = func(i int64) *int64 { return &i }
)