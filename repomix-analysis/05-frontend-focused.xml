This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: CLAUDE.md, README.md, components/frontend/DESIGN_GUIDELINES.md, components/frontend/COMPONENT_PATTERNS.md, components/frontend/src/**, components/frontend/package.json, components/frontend/tailwind.config.ts, components/frontend/tsconfig.json, docs/developer-guide/frontend.md
- Files matching these patterns are excluded: **/*.test.ts, **/*.test.tsx, **/*.spec.ts
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
components/
  frontend/
    src/
      app/
        api/
          auth/
            github/
              disconnect/
                route.ts
              install/
                route.ts
              status/
                route.ts
              user/
                callback/
                  route.ts
          cluster-info/
            route.ts
          me/
            route.ts
          projects/
            [name]/
              access/
                route.ts
              agentic-sessions/
                [sessionName]/
                  clone/
                    route.ts
                  content-pod/
                    route.ts
                  content-pod-status/
                    route.ts
                  git/
                    configure-remote/
                      route.ts
                    create-branch/
                      route.ts
                    list-branches/
                      route.ts
                    merge-status/
                      route.ts
                    pull/
                      route.ts
                    push/
                      route.ts
                    status/
                      route.ts
                    synchronize/
                      route.ts
                  github/
                    abandon/
                      route.ts
                    diff/
                      route.ts
                    push/
                      route.ts
                  k8s-resources/
                    route.ts
                  messages/
                    route.ts
                  repos/
                    [repoName]/
                      route.ts
                    route.ts
                  spawn-content-pod/
                    route.ts
                  start/
                    route.ts
                  stop/
                    route.ts
                  workflow/
                    metadata/
                      route.ts
                    route.ts
                  workspace/
                    [...path]/
                      route.ts
                    route.ts
                  route.ts
                route.ts
              integration-secrets/
                route.ts
              keys/
                [keyId]/
                  route.ts
                route.ts
              permissions/
                [subjectType]/
                  [subjectName]/
                    route.ts
                route.ts
              repo/
                blob/
                  route.ts
                tree/
                  route.ts
              runner-secrets/
                config/
                  route.ts
                route.ts
              secrets/
                route.ts
              settings/
                route.ts
              users/
                forks/
                  route.ts
              route.ts
            route.ts
          version/
            route.ts
          workflows/
            ootb/
              route.ts
        integrations/
          github/
            setup/
              page.tsx
          IntegrationsClient.tsx
          page.tsx
        projects/
          [name]/
            keys/
              error.tsx
              loading.tsx
              page.tsx
            permissions/
              page.tsx
            sessions/
              [sessionName]/
                components/
                  accordions/
                    artifacts-accordion.tsx
                    repositories-accordion.tsx
                    workflows-accordion.tsx
                  modals/
                    add-context-modal.tsx
                    commit-changes-dialog.tsx
                    custom-workflow-dialog.tsx
                    manage-remote-dialog.tsx
                  k8s-resource-tree.tsx
                hooks/
                  use-file-operations.ts
                  use-git-operations.ts
                  use-workflow-management.ts
                lib/
                  message-adapter.ts
                  types.ts
                error.tsx
                loading.tsx
                not-found.tsx
                page.tsx
                session-header.tsx
              new/
                model-configuration.tsx
                page.tsx
                repository-dialog.tsx
                repository-list.tsx
              page.tsx
            settings/
              page.tsx
            error.tsx
            loading.tsx
            not-found.tsx
            page.tsx
          error.tsx
          loading.tsx
          page.tsx
        error.tsx
        favicon.ico
        globals.css
        layout.tsx
        loading.tsx
        page.tsx
      components/
        layouts/
          page-container.tsx
          sidebar-layout.tsx
        providers/
          query-provider.tsx
        session/
          MessagesTab.tsx
          OverviewTab.tsx
          ResultsTab.tsx
          WorkspaceTab.tsx
        ui/
          accordion.tsx
          alert.tsx
          avatar.tsx
          badge.tsx
          button.tsx
          card.tsx
          checkbox.tsx
          dialog.tsx
          dropdown-menu.tsx
          form.tsx
          input.tsx
          label.tsx
          message.tsx
          popover.tsx
          progress.tsx
          resizable.tsx
          select.tsx
          separator.tsx
          skeleton.tsx
          stream-message.tsx
          system-message.tsx
          table.tsx
          tabs.tsx
          textarea.tsx
          thinking-message.tsx
          toast.tsx
          toaster.tsx
          tool-message.tsx
          tooltip.tsx
        workspace-sections/
          index.ts
          sessions-section.tsx
          settings-section.tsx
          sharing-section.tsx
        breadcrumbs.tsx
        clone-session-dialog.tsx
        confirmation-dialog.tsx
        create-session-dialog.tsx
        create-workspace-dialog.tsx
        editable-session-name.tsx
        empty-state.tsx
        error-message.tsx
        file-tree.tsx
        form-field-wrapper.tsx
        github-connection-card.tsx
        loading-button.tsx
        multi-agent-selection.tsx
        navigation.tsx
        page-header.tsx
        project-selector.tsx
        project-subpage-header.tsx
        RepoBrowser.tsx
        session-details-modal.tsx
        simple-data-table.tsx
        skeletons.tsx
        status-badge.tsx
        user-bubble.tsx
      hooks/
        index.ts
        use-async-action.ts
        use-clipboard.ts
        use-cluster-info.ts
        use-debounce.ts
        use-local-storage.ts
        use-toast.tsx
      lib/
        agents.ts
        auth.ts
        config.ts
        env.ts
        query-client.ts
        utils.ts
      services/
        api/
          auth.ts
          client.ts
          cluster.ts
          github.ts
          index.ts
          keys.ts
          projects.ts
          repo.ts
          secrets.ts
          sessions.ts
          version.ts
          workflows.ts
          workspace.ts
        queries/
          index.ts
          use-auth.ts
          use-cluster.ts
          use-github.ts
          use-keys.ts
          use-projects.ts
          use-repo.ts
          use-secrets.ts
          use-sessions.ts
          use-version.ts
          use-workflows.ts
          use-workspace.ts
      types/
        api/
          auth.ts
          common.ts
          github.ts
          index.ts
          projects.ts
          sessions.ts
        components/
          forms.ts
          index.ts
        agentic-session.ts
        bot.ts
        index.ts
        project-settings.ts
        project.ts
      utils/
        session-helpers.ts
    COMPONENT_PATTERNS.md
    DESIGN_GUIDELINES.md
    package.json
    tsconfig.json
CLAUDE.md
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="components/frontend/src/app/api/auth/github/disconnect/route.ts">
import { BACKEND_URL } from '@/lib/config'
import { buildForwardHeadersAsync } from '@/lib/auth'

export async function POST(request: Request) {
  const headers = await buildForwardHeadersAsync(request)
  const resp = await fetch(`${BACKEND_URL}/auth/github/disconnect`, {
    method: 'POST',
    headers,
  })
  const text = await resp.text()
  return new Response(text, { status: resp.status, headers: { 'Content-Type': 'application/json' } })
}
</file>

<file path="components/frontend/src/app/api/auth/github/install/route.ts">
import { BACKEND_URL } from '@/lib/config'
import { buildForwardHeadersAsync } from '@/lib/auth'

export async function POST(request: Request) {
  const headers = await buildForwardHeadersAsync(request)
  const body = await request.text()

  const resp = await fetch(`${BACKEND_URL}/auth/github/install`, {
    method: 'POST',
    headers,
    body,
  })

  const data = await resp.text()
  return new Response(data, { status: resp.status, headers: { 'Content-Type': 'application/json' } })
}
</file>

<file path="components/frontend/src/app/api/auth/github/status/route.ts">
import { BACKEND_URL } from '@/lib/config'
import { buildForwardHeadersAsync } from '@/lib/auth'

export async function GET(request: Request) {
  const headers = await buildForwardHeadersAsync(request)

  const resp = await fetch(`${BACKEND_URL}/auth/github/status`, {
    method: 'GET',
    headers,
  })

  const data = await resp.text()
  return new Response(data, { status: resp.status, headers: { 'Content-Type': 'application/json' } })
}
</file>

<file path="components/frontend/src/app/api/auth/github/user/callback/route.ts">
import { BACKEND_URL } from '@/lib/config'
import { buildForwardHeadersAsync } from '@/lib/auth'

export async function GET(request: Request) {
  const headers = await buildForwardHeadersAsync(request)
  const url = new URL(request.url)
  const resp = await fetch(`${BACKEND_URL}/auth/github/user/callback${url.search}`, {
    method: 'GET',
    headers,
    redirect: 'manual',
  })

  // Forward redirects from backend (e.g., to /integrations)
  const location = resp.headers.get('location')
  if (location && [301, 302, 303, 307, 308].includes(resp.status)) {
    return new Response(null, { status: resp.status, headers: { Location: location } })
  }

  const text = await resp.text()
  return new Response(text, { status: resp.status, headers: { 'Content-Type': 'application/json' } })
}
</file>

<file path="components/frontend/src/app/api/me/route.ts">
import { buildForwardHeadersAsync } from '@/lib/auth';

export async function GET(request: Request) {
  try {
    // Use the shared helper so dev oc whoami and env fallbacks apply uniformly
    const headers = await buildForwardHeadersAsync(request);
    const userId = headers['X-Forwarded-User'] || '';
    const email = headers['X-Forwarded-Email'] || '';
    const username = headers['X-Forwarded-Preferred-Username'] || '';
    const token = headers['X-Forwarded-Access-Token'] || '';

    if (!userId && !username && !email && !token) {
      return Response.json({ authenticated: false }, { status: 200 });
    }

    return Response.json({
      authenticated: true,
      userId,
      email,
      username,
      displayName: username || email || userId,
    });
  } catch (error) {
    console.error('Error reading user headers:', error);
    return Response.json({ authenticated: false }, { status: 200 });
  }
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/access/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

export async function GET(
  request: Request,
  { params }: { params: Promise<{ name: string }> }
) {
  try {
    const { name } = await params;
    const headers = await buildForwardHeadersAsync(request);

    const resp = await fetch(`${BACKEND_URL}/projects/${encodeURIComponent(name)}/access`, { headers });
    const data = await resp.json().catch(() => ({}));
    return Response.json(data, { status: resp.status });
  } catch (error) {
    console.error('Error performing access check:', error);
    return Response.json({ error: 'Failed to perform access check' }, { status: 500 });
  }
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/agentic-sessions/[sessionName]/clone/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

export async function POST(
  request: Request,
  { params }: { params: Promise<{ name: string; sessionName: string }> }
) {
  try {
    const { name, sessionName } = await params;
    const body = await request.text();
    const headers = await buildForwardHeadersAsync(request);
    const response = await fetch(`${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions/${encodeURIComponent(sessionName)}/clone`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...headers },
      body,
    });
    const text = await response.text();
    return new Response(text, { status: response.status, headers: { 'Content-Type': 'application/json' } });
  } catch (error) {
    console.error('Error cloning agentic session:', error);
    return Response.json({ error: 'Failed to clone agentic session' }, { status: 500 });
  }
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/agentic-sessions/[sessionName]/github/abandon/route.ts">
import { BACKEND_URL } from '@/lib/config'
import { buildForwardHeadersAsync } from '@/lib/auth'

export async function POST(
  request: Request,
  { params }: { params: Promise<{ name: string; sessionName: string }> },
) {
  const { name, sessionName } = await params
  const headers = await buildForwardHeadersAsync(request)
  const body = await request.text()
  const resp = await fetch(`${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions/${encodeURIComponent(sessionName)}/github/abandon`, {
    method: 'POST',
    headers: { ...headers, 'Content-Type': 'application/json' },
    body,
  })
  const data = await resp.text()
  return new Response(data, { status: resp.status, headers: { 'Content-Type': 'application/json' } })
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/agentic-sessions/[sessionName]/github/diff/route.ts">
import { BACKEND_URL } from '@/lib/config'
import { buildForwardHeadersAsync } from '@/lib/auth'

export async function GET(
  request: Request,
  { params }: { params: Promise<{ name: string; sessionName: string }> },
) {
  const { name, sessionName } = await params
  const headers = await buildForwardHeadersAsync(request)
  const url = new URL(request.url)
  const repoIndex = url.searchParams.get('repoIndex')
  const repoPath = url.searchParams.get('repoPath')
  const qs = new URLSearchParams()
  if (repoIndex) qs.set('repoIndex', repoIndex)
  if (repoPath) qs.set('repoPath', repoPath)
  const resp = await fetch(`${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions/${encodeURIComponent(sessionName)}/github/diff?${qs.toString()}`, { headers })
  const data = await resp.text()
  return new Response(data, { status: resp.status, headers: { 'Content-Type': 'application/json' } })
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/agentic-sessions/[sessionName]/github/push/route.ts">
import { BACKEND_URL } from '@/lib/config'
import { buildForwardHeadersAsync } from '@/lib/auth'

export async function POST(
  request: Request,
  { params }: { params: Promise<{ name: string; sessionName: string }> },
) {
  const { name, sessionName } = await params
  const headers = await buildForwardHeadersAsync(request)
  const body = await request.text()
  const resp = await fetch(`${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions/${encodeURIComponent(sessionName)}/github/push`, {
    method: 'POST',
    headers: { ...headers, 'Content-Type': 'application/json' },
    body,
  })
  const data = await resp.text()
  return new Response(data, { status: resp.status, headers: { 'Content-Type': 'application/json' } })
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/agentic-sessions/[sessionName]/messages/route.ts">
import { BACKEND_URL } from '@/lib/config'
import { buildForwardHeadersAsync } from '@/lib/auth'

export async function GET(
  request: Request,
  { params }: { params: Promise<{ name: string; sessionName: string }> },
) {
  const { name, sessionName } = await params
  const headers = await buildForwardHeadersAsync(request)
  const resp = await fetch(`${BACKEND_URL}/projects/${encodeURIComponent(name)}/sessions/${encodeURIComponent(sessionName)}/messages`, {
    method: 'GET',
    headers,
  })
  const data = await resp.text()
  return new Response(data, { status: resp.status, headers: { 'Content-Type': 'application/json' } })
}

export async function POST(
  request: Request,
  { params }: { params: Promise<{ name: string; sessionName: string }> },
) {
  const { name, sessionName } = await params
  const headers = await buildForwardHeadersAsync(request)
  const body = await request.text()
  const resp = await fetch(`${BACKEND_URL}/projects/${encodeURIComponent(name)}/sessions/${encodeURIComponent(sessionName)}/messages`, {
    method: 'POST',
    headers: { ...headers, 'Content-Type': 'application/json' },
    body,
  })
  const data = await resp.text()
  return new Response(data, { status: resp.status, headers: { 'Content-Type': 'application/json' } })
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/agentic-sessions/[sessionName]/stop/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

export async function POST(
  request: Request,
  { params }: { params: Promise<{ name: string; sessionName: string }> }
) {
  try {
    const { name, sessionName } = await params;
    const headers = await buildForwardHeadersAsync(request);
    const response = await fetch(`${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions/${encodeURIComponent(sessionName)}/stop`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...headers },
    });
    const text = await response.text();
    return new Response(text, { status: response.status, headers: { 'Content-Type': 'application/json' } });
  } catch (error) {
    console.error('Error stopping agentic session:', error);
    return Response.json({ error: 'Failed to stop agentic session' }, { status: 500 });
  }
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/agentic-sessions/[sessionName]/workspace/[...path]/route.ts">
import { buildForwardHeadersAsync } from '@/lib/auth'
import { BACKEND_URL } from '@/lib/config';

export async function GET(
  request: Request,
  { params }: { params: Promise<{ name: string; sessionName: string; path: string[] }> },
) {
  const { name, sessionName, path } = await params
  const headers = await buildForwardHeadersAsync(request)
  const rel = path.join('/')
  const resp = await fetch(`${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions/${encodeURIComponent(sessionName)}/workspace/${encodeURIComponent(rel)}`, { headers })
  const contentType = resp.headers.get('content-type') || 'application/octet-stream'
  const buf = await resp.arrayBuffer()
  return new Response(buf, { status: resp.status, headers: { 'Content-Type': contentType } })
}


export async function PUT(
  request: Request,
  { params }: { params: Promise<{ name: string; sessionName: string; path: string[] }> },
) {
  const { name, sessionName, path } = await params
  const headers = await buildForwardHeadersAsync(request)
  const rel = path.join('/')
  const contentType = request.headers.get('content-type') || 'text/plain; charset=utf-8'
  const textBody = await request.text()
  const resp = await fetch(`${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions/${encodeURIComponent(sessionName)}/workspace/${encodeURIComponent(rel)}`, {
    method: 'PUT',
    headers: { ...headers, 'Content-Type': contentType },
    body: textBody,
  })
  const respBody = await resp.text()
  return new Response(respBody, { status: resp.status, headers: { 'Content-Type': 'application/json' } })
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/agentic-sessions/[sessionName]/workspace/route.ts">
import { buildForwardHeadersAsync } from '@/lib/auth'
import { BACKEND_URL } from '@/lib/config';

export async function GET(
  request: Request,
  { params }: { params: Promise<{ name: string; sessionName: string }> },
) {
  const { name, sessionName } = await params
  const headers = await buildForwardHeadersAsync(request)
  // Per-job content service (sidecar) name
  const url = new URL(request.url)
  const subpath = url.searchParams.get('path')
  const query = subpath ? `?path=${encodeURIComponent(subpath)}` : ''
  const resp = await fetch(
    `${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions/${encodeURIComponent(sessionName)}/workspace${query}`,
    { headers },
  )
  const contentType = resp.headers.get('content-type') || 'application/json'
  const body = await resp.text()
  return new Response(body, { status: resp.status, headers: { 'Content-Type': contentType } })
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/agentic-sessions/[sessionName]/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

type Ctx = { params: Promise<{ name: string; sessionName: string }> };

// GET /api/projects/[name]/agentic-sessions/[sessionName]
export async function GET(request: Request, { params }: Ctx) {
  try {
    const { name, sessionName } = await params;
    const headers = await buildForwardHeadersAsync(request);
    const response = await fetch(`${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions/${encodeURIComponent(sessionName)}`, { headers });
    const text = await response.text();
    return new Response(text, { status: response.status, headers: { 'Content-Type': 'application/json' } });
  } catch (error) {
    console.error('Error fetching agentic session:', error);
    return Response.json({ error: 'Failed to fetch agentic session' }, { status: 500 });
  }
}

// PUT /api/projects/[name]/agentic-sessions/[sessionName]
export async function PUT(request: Request, { params }: Ctx) {
  try {
    const { name, sessionName } = await params;
    const body = await request.text();
    const headers = await buildForwardHeadersAsync(request);
    const response = await fetch(`${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions/${encodeURIComponent(sessionName)}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', ...headers },
      body,
    });
    const text = await response.text();
    return new Response(text, { status: response.status, headers: { 'Content-Type': 'application/json' } });
  } catch (error) {
    console.error('Error updating agentic session:', error);
    return Response.json({ error: 'Failed to update agentic session' }, { status: 500 });
  }
}

// DELETE /api/projects/[name]/agentic-sessions/[sessionName]
export async function DELETE(request: Request, { params }: Ctx) {
  try {
    const { name, sessionName } = await params;
    const headers = await buildForwardHeadersAsync(request);
    const response = await fetch(`${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions/${encodeURIComponent(sessionName)}`, {
      method: 'DELETE',
      headers,
    });
    if (response.status === 204) return new Response(null, { status: 204 });
    const text = await response.text();
    return new Response(text, { status: response.status, headers: { 'Content-Type': 'application/json' } });
  } catch (error) {
    console.error('Error deleting agentic session:', error);
    return Response.json({ error: 'Failed to delete agentic session' }, { status: 500 });
  }
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/keys/[keyId]/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

// DELETE /api/projects/[name]/keys/[keyId] - Delete project access key
export async function DELETE(
  request: Request,
  { params }: { params: Promise<{ name: string; keyId: string }> }
) {
  try {
    const { name, keyId } = await params;
    const headers = await buildForwardHeadersAsync(request);

    const response = await fetch(`${BACKEND_URL}/projects/${name}/keys/${encodeURIComponent(keyId)}`, {
      method: 'DELETE',
      headers,
    });

    if (!response.ok && response.status !== 204) {
      const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
      return Response.json(errorData, { status: response.status });
    }

    return new Response(null, { status: 204 });
  } catch (error) {
    console.error('Error deleting project key:', error);
    return Response.json({ error: 'Failed to delete project key' }, { status: 500 });
  }
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/keys/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

// GET /api/projects/[name]/keys - List project access keys
export async function GET(
  request: Request,
  { params }: { params: Promise<{ name: string }> }
) {
  try {
    const { name } = await params;
    const headers = await buildForwardHeadersAsync(request);

    const response = await fetch(`${BACKEND_URL}/projects/${name}/keys`, { headers });
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
      return Response.json(errorData, { status: response.status });
    }
    const data = await response.json();
    return Response.json(data);
  } catch (error) {
    console.error('Error fetching project keys:', error);
    return Response.json({ error: 'Failed to fetch project keys' }, { status: 500 });
  }
}

// POST /api/projects/[name]/keys - Create project access key
export async function POST(
  request: Request,
  { params }: { params: Promise<{ name: string }> }
) {
  try {
    const { name } = await params;
    const body = await request.json();
    const headers = await buildForwardHeadersAsync(request);

    const response = await fetch(`${BACKEND_URL}/projects/${name}/keys`, {
      method: 'POST',
      headers,
      body: JSON.stringify(body),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
      return Response.json(errorData, { status: response.status });
    }

    const data = await response.json();
    return Response.json(data, { status: 201 });
  } catch (error) {
    console.error('Error creating project key:', error);
    return Response.json({ error: 'Failed to create project key' }, { status: 500 });
  }
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/permissions/[subjectType]/[subjectName]/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

// DELETE /api/projects/[name]/permissions/[subjectType]/[subjectName] - Remove permission
export async function DELETE(
  request: Request,
  { params }: { params: Promise<{ name: string; subjectType: string; subjectName: string }> }
) {
  try {
    const { name, subjectType, subjectName } = await params;
    const headers = await buildForwardHeadersAsync(request);

    const response = await fetch(`${BACKEND_URL}/projects/${name}/permissions/${encodeURIComponent(subjectType)}/${encodeURIComponent(subjectName)}`, {
      method: 'DELETE',
      headers,
    });

    if (!response.ok && response.status !== 204) {
      const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
      return Response.json(errorData, { status: response.status });
    }

    return new Response(null, { status: 204 });
  } catch (error) {
    console.error('Error removing project permission:', error);
    return Response.json({ error: 'Failed to remove project permission' }, { status: 500 });
  }
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/permissions/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

// GET /api/projects/[name]/permissions - List project permissions (users & groups)
export async function GET(
  request: Request,
  { params }: { params: Promise<{ name: string }> }
) {
  try {
    const { name } = await params;
    const headers = await buildForwardHeadersAsync(request);

    const response = await fetch(`${BACKEND_URL}/projects/${name}/permissions`, { headers });
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
      return Response.json(errorData, { status: response.status });
    }
    const data = await response.json();
    return Response.json(data);
  } catch (error) {
    console.error('Error fetching project permissions:', error);
    return Response.json({ error: 'Failed to fetch project permissions' }, { status: 500 });
  }
}

// POST /api/projects/[name]/permissions - Add permission assignment
export async function POST(
  request: Request,
  { params }: { params: Promise<{ name: string }> }
) {
  try {
    const { name } = await params;
    const body = await request.json();
    const headers = await buildForwardHeadersAsync(request);

    const response = await fetch(`${BACKEND_URL}/projects/${name}/permissions`, {
      method: 'POST',
      headers,
      body: JSON.stringify(body),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
      return Response.json(errorData, { status: response.status });
    }

    const data = await response.json();
    return Response.json(data, { status: 201 });
  } catch (error) {
    console.error('Error adding project permission:', error);
    return Response.json({ error: 'Failed to add project permission' }, { status: 500 });
  }
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/runner-secrets/config/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

// GET /api/projects/[name]/runner-secrets/config
export async function GET(
  request: Request,
  { params }: { params: Promise<{ name: string }> }
) {
  try {
    const { name } = await params;
    const headers = await buildForwardHeadersAsync(request);
    const response = await fetch(`${BACKEND_URL}/projects/${encodeURIComponent(name)}/runner-secrets/config`, { headers });
    const text = await response.text();
    return new Response(text, { status: response.status, headers: { 'Content-Type': 'application/json' } });
  } catch (error) {
    console.error('Error getting runner secrets config:', error);
    return Response.json({ error: 'Failed to get runner secrets config' }, { status: 500 });
  }
}

// PUT /api/projects/[name]/runner-secrets/config
export async function PUT(
  request: Request,
  { params }: { params: Promise<{ name: string }> }
) {
  try {
    const { name } = await params;
    const body = await request.text();
    const headers = await buildForwardHeadersAsync(request);
    const response = await fetch(`${BACKEND_URL}/projects/${encodeURIComponent(name)}/runner-secrets/config`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', ...headers },
      body,
    });
    const text = await response.text();
    return new Response(text, { status: response.status, headers: { 'Content-Type': 'application/json' } });
  } catch (error) {
    console.error('Error updating runner secrets config:', error);
    return Response.json({ error: 'Failed to update runner secrets config' }, { status: 500 });
  }
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/runner-secrets/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

// GET /api/projects/[name]/runner-secrets
export async function GET(
  request: Request,
  { params }: { params: Promise<{ name: string }> }
) {
  try {
    const { name } = await params;
    const headers = await buildForwardHeadersAsync(request);
    const response = await fetch(`${BACKEND_URL}/projects/${encodeURIComponent(name)}/runner-secrets`, { headers });
    const text = await response.text();
    return new Response(text, { status: response.status, headers: { 'Content-Type': 'application/json' } });
  } catch (error) {
    console.error('Error getting runner secrets:', error);
    return Response.json({ error: 'Failed to get runner secrets' }, { status: 500 });
  }
}

// PUT /api/projects/[name]/runner-secrets
export async function PUT(
  request: Request,
  { params }: { params: Promise<{ name: string }> }
) {
  try {
    const { name } = await params;
    const body = await request.text();
    const headers = await buildForwardHeadersAsync(request);
    const response = await fetch(`${BACKEND_URL}/projects/${encodeURIComponent(name)}/runner-secrets`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', ...headers },
      body,
    });
    const text = await response.text();
    return new Response(text, { status: response.status, headers: { 'Content-Type': 'application/json' } });
  } catch (error) {
    console.error('Error updating runner secrets:', error);
    return Response.json({ error: 'Failed to update runner secrets' }, { status: 500 });
  }
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/secrets/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

// GET /api/projects/[name]/secrets - List Opaque secrets in a project
export async function GET(
  request: Request,
  { params }: { params: Promise<{ name: string }> }
) {
  try {
    const { name } = await params;
    const headers = await buildForwardHeadersAsync(request);
    const response = await fetch(`${BACKEND_URL}/projects/${encodeURIComponent(name)}/secrets`, { headers });
    const text = await response.text();
    return new Response(text, { status: response.status, headers: { 'Content-Type': 'application/json' } });
  } catch (error) {
    console.error('Error listing secrets:', error);
    return Response.json({ error: 'Failed to list secrets' }, { status: 500 });
  }
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/settings/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { BACKEND_URL } from "@/lib/config";

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ name: string }> }
) {
  try {
    const { name: projectName } = await params;

    // Forward the request to the backend
    const response = await fetch(`${BACKEND_URL}/projects/${projectName}/settings`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        // Forward authentication headers from the client request
        "X-User-ID": request.headers.get("X-User-ID") || "",
        "X-User-Groups": request.headers.get("X-User-Groups") || "",
      },
    });

    // Forward the response from backend
    const data = await response.text();

    return new NextResponse(data, {
      status: response.status,
      headers: {
        "Content-Type": "application/json",
      },
    });
  } catch (error) {
    console.error("Failed to fetch project settings:", error);
    return NextResponse.json(
      { error: "Failed to fetch project settings" },
      { status: 500 }
    );
  }
}

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ name: string }> }
) {
  try {
    const { name: projectName } = await params;
    const body = await request.text();

    // Forward the request to the backend
    const response = await fetch(`${BACKEND_URL}/projects/${projectName}/settings`, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        // Forward authentication headers from the client request
        "X-User-ID": request.headers.get("X-User-ID") || "",
        "X-User-Groups": request.headers.get("X-User-Groups") || "",
      },
      body: body,
    });

    // Forward the response from backend
    const data = await response.text();

    return new NextResponse(data, {
      status: response.status,
      headers: {
        "Content-Type": "application/json",
      },
    });
  } catch (error) {
    console.error("Failed to update project settings:", error);
    return NextResponse.json(
      { error: "Failed to update project settings" },
      { status: 500 }
    );
  }
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/users/forks/route.ts">
import { BACKEND_URL } from '@/lib/config'
import { buildForwardHeadersAsync } from '@/lib/auth'

export async function GET(
  request: Request,
  { params }: { params: Promise<{ name: string }> },
) {
  const { name } = await params
  const headers = await buildForwardHeadersAsync(request)
  const url = new URL(request.url)
  const qs = url.search
  const resp = await fetch(`${BACKEND_URL}/projects/${encodeURIComponent(name)}/users/forks${qs}`, { headers, cache: 'no-store' })
  // Pass through upstream response body and content-type
  const contentType = resp.headers.get('content-type') || 'application/json'
  return new Response(resp.body, { status: resp.status, headers: { 'Content-Type': contentType, 'Cache-Control': 'no-store' } })
}

export async function POST(
  request: Request,
  { params }: { params: Promise<{ name: string }> },
) {
  const { name } = await params
  const headers = await buildForwardHeadersAsync(request)
  const body = await request.text()
  const resp = await fetch(`${BACKEND_URL}/projects/${encodeURIComponent(name)}/users/forks`, {
    method: 'POST',
    headers,
    body,
  })
  const data = await resp.text()
  return new Response(data, { status: resp.status, headers: { 'Content-Type': 'application/json' } })
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

// GET /api/projects/[name] - Get project by name
export async function GET(
  request: Request,
  { params }: { params: Promise<{ name: string }> }
) {
  try {
    const { name } = await params;
    const headers = await buildForwardHeadersAsync(request);

    const response = await fetch(`${BACKEND_URL}/projects/${name}`, { headers });
    if (!response.ok) {
      throw new Error(`Backend responded with status: ${response.status}`);
    }
    const data = await response.json();
    return Response.json(data);
  } catch (error) {
    console.error('Error fetching project:', error);
    return Response.json({ error: 'Failed to fetch project' }, { status: 500 });
  }
}

// PUT /api/projects/[name] - Update project
export async function PUT(
  request: Request,
  { params }: { params: Promise<{ name: string }> }
) {
  try {
    const { name } = await params;
    const body = await request.json();
    const headers = await buildForwardHeadersAsync(request);

    const response = await fetch(`${BACKEND_URL}/projects/${name}`, {
      method: 'PUT',
      headers,
      body: JSON.stringify(body),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
      return Response.json(errorData, { status: response.status });
    }

    const data = await response.json();
    return Response.json(data);
  } catch (error) {
    console.error('Error updating project:', error);
    return Response.json({ error: 'Failed to update project' }, { status: 500 });
  }
}

// DELETE /api/projects/[name] - Delete project
export async function DELETE(
  request: Request,
  { params }: { params: Promise<{ name: string }> }
) {
  try {
    const { name } = await params;
    const headers = await buildForwardHeadersAsync(request);

    const response = await fetch(`${BACKEND_URL}/projects/${name}`, {
      method: 'DELETE',
      headers,
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
      return Response.json(errorData, { status: response.status });
    }

    if (response.status === 204) {
      return new Response(null, { status: 204 });
    }

    const data = await response.json();
    return Response.json(data);
  } catch (error) {
    console.error('Error deleting project:', error);
    return Response.json({ error: 'Failed to delete project' }, { status: 500 });
  }
}
</file>

<file path="components/frontend/src/app/api/projects/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { BACKEND_URL } from "@/lib/config";
import { buildForwardHeadersAsync } from "@/lib/auth";

export async function GET(request: NextRequest) {
  try {
    const headers = await buildForwardHeadersAsync(request);

    const response = await fetch(`${BACKEND_URL}/projects`, {
      method: 'GET',
      headers,
    });

    // Forward the response from backend
    const data = await response.text();

    return new NextResponse(data, {
      status: response.status,
      headers: {
        "Content-Type": "application/json",
      },
    });
  } catch (error) {
    console.error("Failed to fetch projects:", error);
    return NextResponse.json(
      { error: "Failed to fetch projects" },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.text();

    const headers = await buildForwardHeadersAsync(request);

    const response = await fetch(`${BACKEND_URL}/projects`, {
      method: 'POST',
      headers,
      body: body,
    });

    // Forward the response from backend
    const data = await response.text();

    return new NextResponse(data, {
      status: response.status,
      headers: {
        "Content-Type": "application/json",
      },
    });
  } catch (error) {
    console.error("Failed to create project:", error);
    return NextResponse.json(
      { error: "Failed to create project" },
      { status: 500 }
    );
  }
}
</file>

<file path="components/frontend/src/app/integrations/page.tsx">
import React from 'react'
import IntegrationsClient from '@/app/integrations/IntegrationsClient'

export const dynamic = 'force-dynamic'
export const revalidate = 0

export default function IntegrationsPage() {
  const appSlug = process.env.GITHUB_APP_SLUG
  return <IntegrationsClient appSlug={appSlug} />
}
</file>

<file path="components/frontend/src/components/ui/avatar.tsx">
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className
      )}
      {...props}
    />
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className
      )}
      {...props}
    />
  )
}

export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="components/frontend/src/components/ui/badge.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }
</file>

<file path="components/frontend/src/components/ui/checkbox.tsx">
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }
</file>

<file path="components/frontend/src/components/ui/dropdown-menu.tsx">
"use client";

import * as React from "react";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { CheckIcon, ChevronRightIcon, Dot } from "lucide-react";

import { cn } from "@/lib/utils";

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRightIcon className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <CheckIcon className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Dot className="h-4 w-4 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  );
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
};
</file>

<file path="components/frontend/src/components/ui/form.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  useFormState,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState } = useFormContext()
  const formState = useFormState({ name: fieldContext.name })
  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

function FormItem({ className, ...props }: React.ComponentProps<"div">) {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div
        data-slot="form-item"
        className={cn("grid gap-2", className)}
        {...props}
      />
    </FormItemContext.Provider>
  )
}

function FormLabel({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  const { error, formItemId } = useFormField()

  return (
    <Label
      data-slot="form-label"
      data-error={!!error}
      className={cn("data-[error=true]:text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
}

function FormControl({ ...props }: React.ComponentProps<typeof Slot>) {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      data-slot="form-control"
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
}

function FormDescription({ className, ...props }: React.ComponentProps<"p">) {
  const { formDescriptionId } = useFormField()

  return (
    <p
      data-slot="form-description"
      id={formDescriptionId}
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function FormMessage({ className, ...props }: React.ComponentProps<"p">) {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : props.children

  if (!body) {
    return null
  }

  return (
    <p
      data-slot="form-message"
      id={formMessageId}
      className={cn("text-destructive text-sm", className)}
      {...props}
    >
      {body}
    </p>
  )
}

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}
</file>

<file path="components/frontend/src/components/ui/label.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }
</file>

<file path="components/frontend/src/components/ui/progress.tsx">
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }
</file>

<file path="components/frontend/src/components/ui/resizable.tsx">
"use client"

import { GripVertical } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"

import { cn } from "@/lib/utils"

const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn(
      "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
      className
    )}
    {...props}
  />
)

const ResizablePanel = ResizablePrimitive.Panel

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
      className
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <GripVertical className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
)

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }
</file>

<file path="components/frontend/src/components/ui/select.tsx">
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}
</file>

<file path="components/frontend/src/components/ui/tabs.tsx">
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="components/frontend/src/components/multi-agent-selection.tsx">
"use client";

import React, { useMemo } from "react";
import type { AgentPersona } from "@/types/agentic-session";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { DropdownMenu, DropdownMenuCheckboxItem, DropdownMenuContent, DropdownMenuTrigger } from "@/components/ui/dropdown-menu";

type Props = {
  agents: AgentPersona[];
  selectedAgents: string[];
  onChange: (next: string[]) => void;
  maxAgents?: number;
  disabled?: boolean;
};

export function MultiAgentSelection({ agents, selectedAgents, onChange, maxAgents = 8, disabled = false }: Props) {
  const selectedCount = selectedAgents.length;
  const availableAgents = useMemo(() => agents || [], [agents]);

  const toggle = (persona: string) => {
    if (disabled) return;
    const isSelected = selectedAgents.includes(persona);
    if (isSelected) {
      onChange(selectedAgents.filter(p => p !== persona));
    } else if (selectedAgents.length < maxAgents) {
      onChange([...selectedAgents, persona]);
    }
  };

  const clearAll = () => {
    if (!disabled) onChange([]);
  };

  return (
    <div className="space-y-2">
      <div className="flex items-center gap-2">
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <Button type="button" variant="outline" size="sm" disabled={disabled}>
              Select agents ({selectedCount}/{maxAgents})
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent align="start" className="w-80 max-h-80 overflow-auto">
            {availableAgents.map(agent => {
              const checked = selectedAgents.includes(agent.persona);
              return (
                <DropdownMenuCheckboxItem
                  key={agent.persona}
                  checked={checked}
                  onCheckedChange={() => toggle(agent.persona)}
                >
                  <div className="flex flex-col">
                    <span className="text-sm">{agent.name}</span>
                    <span className="text-xs text-muted-foreground">{agent.role}</span>
                  </div>
                </DropdownMenuCheckboxItem>
              );
            })}
          </DropdownMenuContent>
        </DropdownMenu>
        <Button type="button" variant="ghost" size="sm" disabled={disabled || selectedCount === 0} onClick={clearAll}>
          Clear
        </Button>
      </div>

      {selectedCount > 0 && (
        <div className="flex flex-wrap gap-2">
          {selectedAgents.map(persona => {
            const agent = availableAgents.find(a => a.persona === persona);
            if (!agent) return null;
            return (
              <Badge key={persona} variant="secondary" className="flex items-center gap-1">
                {agent.name}
                <button
                  type="button"
                  className="ml-1 hover:opacity-70"
                  onClick={() => toggle(persona)}
                  disabled={disabled}
                >
                  
                </button>
              </Badge>
            );
          })}
        </div>
      )}
    </div>
  );
}

export default MultiAgentSelection;
</file>

<file path="components/frontend/src/components/project-subpage-header.tsx">
"use client";

import { ReactNode } from "react";
import { cn } from "@/lib/utils";

type ProjectSubpageHeaderProps = {
  title: ReactNode;
  description?: ReactNode;
  actions?: ReactNode;
  left?: ReactNode; // Optional left slot (breadcrumbs/sub-nav)
  className?: string;
};

export function ProjectSubpageHeader({ title, description, actions, left, className }: ProjectSubpageHeaderProps) {
  return (
    <div className={cn("flex items-center justify-between mb-6", className)}>
      <div className="flex items-center gap-3">
        {left && <div className="shrink-0">{left}</div>}
        <div>
          <h2 className="text-2xl font-semibold flex items-center gap-2">
            {title}
          </h2>
          {description && (
            <p className="text-muted-foreground">{description}</p>
          )}
        </div>
      </div>
      <div className="flex items-center gap-4">
        {actions}
      </div>
    </div>
  );
}
</file>

<file path="components/frontend/src/lib/auth.ts">
// Utilities for extracting user auth context from Next.js API requests
// We avoid any dev fallbacks and strictly forward what is provided.

export type ForwardHeaders = Record<string, string>;

// Execute a shell command safely in Node.js runtime (server-side only)
async function tryExec(cmd: string): Promise<string | undefined> {
  if (typeof window !== 'undefined') return undefined;
  try {
    const { exec } = await import('node:child_process');
    const { promisify } = await import('node:util');
    const execAsync = promisify(exec);
    const { stdout } = await execAsync(cmd, { timeout: 2000 });
    return stdout?.trim() || undefined;
  } catch {
    return undefined;
  }
}

// Extract bearer token from either Authorization or X-Forwarded-Access-Token
export function extractAccessToken(request: Request): string | undefined {
  const forwarded = request.headers.get('X-Forwarded-Access-Token')?.trim();
  if (forwarded) return forwarded;
  const auth = request.headers.get('Authorization');
  if (!auth) return undefined;
  const match = auth.match(/^Bearer\s+(.+)$/i);
  if (match?.[1]) return match[1].trim();
  // Fallback to environment-provided token for local dev with oc login
  const envToken = process.env.OC_TOKEN?.trim();
  return envToken || undefined;
}

// Build headers to forward to backend, using only real incoming values.
export function buildForwardHeaders(request: Request, extra?: Record<string, string>): ForwardHeaders {
  const headers: ForwardHeaders = {
    'Content-Type': 'application/json',
  };

  const xfUser = request.headers.get('X-Forwarded-User');
  const xfEmail = request.headers.get('X-Forwarded-Email');
  const xfUsername = request.headers.get('X-Forwarded-Preferred-Username');
  const xfGroups = request.headers.get('X-Forwarded-Groups');
  const project = request.headers.get('X-OpenShift-Project');
  const token = extractAccessToken(request);

  if (xfUser) headers['X-Forwarded-User'] = xfUser;
  if (xfEmail) headers['X-Forwarded-Email'] = xfEmail;
  if (xfUsername) headers['X-Forwarded-Preferred-Username'] = xfUsername;
  if (xfGroups) headers['X-Forwarded-Groups'] = xfGroups;
  if (project) headers['X-OpenShift-Project'] = project;
  if (token) headers['X-Forwarded-Access-Token'] = token;

  // If still missing identity info, use environment (helpful for local oc login)
  if (!headers['X-Forwarded-User'] && process.env.OC_USER) {
    headers['X-Forwarded-User'] = process.env.OC_USER;
  }
  if (!headers['X-Forwarded-Preferred-Username'] && process.env.OC_USER) {
    headers['X-Forwarded-Preferred-Username'] = process.env.OC_USER;
  }
  if (!headers['X-Forwarded-Email'] && process.env.OC_EMAIL) {
    headers['X-Forwarded-Email'] = process.env.OC_EMAIL;
  }
  
  // Add token fallback for local development
  if (!headers['X-Forwarded-Access-Token'] && process.env.OC_TOKEN) {
    headers['X-Forwarded-Access-Token'] = process.env.OC_TOKEN;
  }

  // Optional dev-only automatic discovery via oc CLI
  // Enable by setting ENABLE_OC_WHOAMI=1 in your dev env
  const enableOc = process.env.ENABLE_OC_WHOAMI === '1' || process.env.ENABLE_OC_WHOAMI === 'true';
  const runningInNode = typeof window === 'undefined';
  const needsIdentity = !headers['X-Forwarded-User'] && !headers['X-Forwarded-Preferred-Username'];
  const needsToken = !headers['X-Forwarded-Access-Token'];

  // We cannot await top-level in this sync function, so expose best-effort sync
  // pattern by stashing promises on the object and resolving outside if needed.
  // For simplicity, perform a lazy, best-effort fetch and only if in server runtime.
  if (enableOc && runningInNode && (needsIdentity || needsToken)) {
    // Fire-and-forget: we won't block the request if oc isn't present
    (async () => {
      try {
        if (needsIdentity) {
          const user = await tryExec('oc whoami');
          if (user && !headers['X-Forwarded-User']) headers['X-Forwarded-User'] = user;
          if (user && !headers['X-Forwarded-Preferred-Username']) headers['X-Forwarded-Preferred-Username'] = user;
        }
        if (needsToken) {
          const t = await tryExec('oc whoami -t');
          if (t) headers['X-Forwarded-Access-Token'] = t;
        }
      } catch {
        // ignore
      }
    })();
  }

  if (extra) {
    for (const [k, v] of Object.entries(extra)) {
      if (v !== undefined && v !== null) headers[k] = String(v);
    }
  }

  return headers;
}

// Async version that can optionally consult oc CLI in dev and wait for results
export async function buildForwardHeadersAsync(request: Request, extra?: Record<string, string>): Promise<ForwardHeaders> {
  const headers = buildForwardHeaders(request, extra);

  const enableOc = process.env.ENABLE_OC_WHOAMI === '1' || process.env.ENABLE_OC_WHOAMI === 'true';
  const runningInNode = typeof window === 'undefined';
  const needsIdentity = !headers['X-Forwarded-User'] && !headers['X-Forwarded-Preferred-Username'];
  const needsToken = !headers['X-Forwarded-Access-Token'];

  if (enableOc && runningInNode && (needsIdentity || needsToken)) {
    if (needsIdentity) {
      const user = await tryExec('oc whoami');
      if (user && !headers['X-Forwarded-User']) headers['X-Forwarded-User'] = user;
      if (user && !headers['X-Forwarded-Preferred-Username']) headers['X-Forwarded-Preferred-Username'] = user;
    }
    if (needsToken) {
      const t = await tryExec('oc whoami -t');
      if (t) headers['X-Forwarded-Access-Token'] = t;
    }
  }

  return headers;
}
</file>

<file path="components/frontend/src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="components/frontend/src/types/bot.ts">
// Bot management types for the Ambient Agentic Runner frontend
// Extends the project.ts types with detailed bot management functionality

export interface BotConfig {
  name: string;
  description?: string;
  enabled: boolean;
  token?: string; // Only shown to admins
  createdAt?: string;
  lastUsed?: string;
}

export interface CreateBotRequest {
  name: string;
  description?: string;
  enabled?: boolean;
}

export interface UpdateBotRequest {
  description?: string;
  enabled?: boolean;
}

export interface BotListResponse {
  items: BotConfig[];
}

export interface BotResponse {
  bot: BotConfig;
}

export interface User {
  id: string;
  username: string;
  roles: string[];
  permissions: string[];
}

// User role and permission types for admin checking
export enum UserRole {
  ADMIN = "admin",
  USER = "user",
  VIEWER = "viewer"
}

export enum Permission {
  CREATE_BOT = "create_bot",
  DELETE_BOT = "delete_bot",
  VIEW_BOT_TOKEN = "view_bot_token",
  MANAGE_BOTS = "manage_bots"
}

// Form validation types
export interface BotFormData {
  name: string;
  description: string;
  enabled: boolean;
}

export interface BotFormErrors {
  name?: string;
  description?: string;
  enabled?: string;
}

// Bot status types
export enum BotStatus {
  ACTIVE = "active",
  INACTIVE = "inactive",
  ERROR = "error"
}

// API error response
export interface ApiError {
  message: string;
  code?: string;
  details?: string;
}
</file>

<file path="components/frontend/src/types/project-settings.ts">
export type LLMSettings = {
  model: string;
  temperature: number;
  maxTokens: number;
};

export type ProjectDefaultSettings = {
  llmSettings: LLMSettings;
  defaultTimeout: number;
  allowedWebsiteDomains?: string[];
  maxConcurrentSessions: number;
};

export type ProjectResourceLimits = {
  maxCpuPerSession: string;
  maxMemoryPerSession: string;
  maxStoragePerSession: string;
  diskQuotaGB: number;
};

export type ObjectMeta = {
  name: string;
  namespace: string;
  creationTimestamp: string;
  uid?: string;
};

export type ProjectSettings = {
  projectName: string;
  adminUsers: string[];
  defaultSettings: ProjectDefaultSettings;
  resourceLimits: ProjectResourceLimits;
  metadata: ObjectMeta;
};

export type ProjectSettingsUpdateRequest = {
  projectName: string;
  adminUsers: string[];
  defaultSettings: ProjectDefaultSettings;
  resourceLimits: ProjectResourceLimits;
};
</file>

<file path="components/frontend/src/app/api/cluster-info/route.ts">
import { BACKEND_URL } from '@/lib/config';

/**
 * GET /api/cluster-info
 * Returns cluster information (OpenShift vs vanilla Kubernetes)
 * This endpoint does not require authentication as it's public cluster information
 */
export async function GET() {
  try {
    const response = await fetch(`${BACKEND_URL}/cluster-info`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
      return Response.json(errorData, { status: response.status });
    }

    const data = await response.json();
    return Response.json(data);
  } catch (error) {
    console.error('Error fetching cluster info:', error);
    return Response.json({ error: 'Failed to fetch cluster info' }, { status: 500 });
  }
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/agentic-sessions/[sessionName]/content-pod/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

export async function DELETE(
  request: Request,
  { params }: { params: Promise<{ name: string; sessionName: string }> },
) {
  const { name, sessionName } = await params;
  const headers = await buildForwardHeadersAsync(request);
  const resp = await fetch(
    `${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions/${encodeURIComponent(sessionName)}/content-pod`,
    { method: 'DELETE', headers }
  );
  const data = await resp.text();
  return new Response(data, { status: resp.status, headers: { 'Content-Type': 'application/json' } });
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/agentic-sessions/[sessionName]/content-pod-status/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

export async function GET(
  request: Request,
  { params }: { params: Promise<{ name: string; sessionName: string }> },
) {
  const { name, sessionName } = await params;
  const headers = await buildForwardHeadersAsync(request);
  const resp = await fetch(
    `${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions/${encodeURIComponent(sessionName)}/content-pod-status`,
    { headers }
  );
  const data = await resp.text();
  return new Response(data, { status: resp.status, headers: { 'Content-Type': 'application/json' } });
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/agentic-sessions/[sessionName]/git/configure-remote/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

export async function POST(
  request: Request,
  { params }: { params: Promise<{ name: string; sessionName: string }> },
) {
  const { name, sessionName } = await params;
  const headers = await buildForwardHeadersAsync(request);
  const body = await request.text();
  
  const resp = await fetch(
    `${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions/${encodeURIComponent(sessionName)}/git/configure-remote`,
    { 
      method: 'POST', 
      headers,
      body,
    }
  );
  
  const data = await resp.text();
  return new Response(data, { 
    status: resp.status, 
    headers: { 'Content-Type': 'application/json' } 
  });
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/agentic-sessions/[sessionName]/git/create-branch/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

export async function POST(
  request: Request,
  { params }: { params: Promise<{ name: string; sessionName: string }> },
) {
  const { name, sessionName } = await params;
  const headers = await buildForwardHeadersAsync(request);
  const body = await request.text();
  
  const resp = await fetch(
    `${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions/${encodeURIComponent(sessionName)}/git/create-branch`,
    { 
      method: 'POST', 
      headers,
      body,
    }
  );
  
  const data = await resp.text();
  return new Response(data, { 
    status: resp.status, 
    headers: { 'Content-Type': 'application/json' } 
  });
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/agentic-sessions/[sessionName]/git/list-branches/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

export async function GET(
  request: Request,
  { params }: { params: Promise<{ name: string; sessionName: string }> },
) {
  const { name, sessionName } = await params;
  const { searchParams } = new URL(request.url);
  const path = searchParams.get('path') || 'artifacts';
  
  const headers = await buildForwardHeadersAsync(request);
  const resp = await fetch(
    `${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions/${encodeURIComponent(sessionName)}/git/list-branches?path=${encodeURIComponent(path)}`,
    { headers }
  );
  const data = await resp.text();
  return new Response(data, { status: resp.status, headers: { 'Content-Type': 'application/json' } });
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/agentic-sessions/[sessionName]/git/merge-status/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

export async function GET(
  request: Request,
  { params }: { params: Promise<{ name: string; sessionName: string }> },
) {
  const { name, sessionName } = await params;
  const { searchParams } = new URL(request.url);
  const path = searchParams.get('path') || 'artifacts';
  const branch = searchParams.get('branch') || 'main';
  
  const headers = await buildForwardHeadersAsync(request);
  const resp = await fetch(
    `${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions/${encodeURIComponent(sessionName)}/git/merge-status?path=${encodeURIComponent(path)}&branch=${encodeURIComponent(branch)}`,
    { headers }
  );
  const data = await resp.text();
  return new Response(data, { status: resp.status, headers: { 'Content-Type': 'application/json' } });
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/agentic-sessions/[sessionName]/git/pull/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

export async function POST(
  request: Request,
  { params }: { params: Promise<{ name: string; sessionName: string }> },
) {
  const { name, sessionName } = await params;
  const headers = await buildForwardHeadersAsync(request);
  const body = await request.text();
  
  const resp = await fetch(
    `${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions/${encodeURIComponent(sessionName)}/git/pull`,
    { 
      method: 'POST', 
      headers,
      body,
    }
  );
  
  const data = await resp.text();
  return new Response(data, { 
    status: resp.status, 
    headers: { 'Content-Type': 'application/json' } 
  });
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/agentic-sessions/[sessionName]/git/push/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

export async function POST(
  request: Request,
  { params }: { params: Promise<{ name: string; sessionName: string }> },
) {
  const { name, sessionName } = await params;
  const headers = await buildForwardHeadersAsync(request);
  const body = await request.text();
  
  const resp = await fetch(
    `${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions/${encodeURIComponent(sessionName)}/git/push`,
    { 
      method: 'POST', 
      headers,
      body,
    }
  );
  
  const data = await resp.text();
  return new Response(data, { 
    status: resp.status, 
    headers: { 'Content-Type': 'application/json' } 
  });
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/agentic-sessions/[sessionName]/git/status/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

export async function GET(
  request: Request,
  { params }: { params: Promise<{ name: string; sessionName: string }> },
) {
  const { name, sessionName } = await params;
  const { searchParams } = new URL(request.url);
  const path = searchParams.get('path') || '';
  
  const headers = await buildForwardHeadersAsync(request);
  
  const resp = await fetch(
    `${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions/${encodeURIComponent(sessionName)}/git/status?path=${encodeURIComponent(path)}`,
    { method: 'GET', headers }
  );
  
  const data = await resp.text();
  return new Response(data, { 
    status: resp.status, 
    headers: { 'Content-Type': 'application/json' } 
  });
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/agentic-sessions/[sessionName]/git/synchronize/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

export async function POST(
  request: Request,
  { params }: { params: Promise<{ name: string; sessionName: string }> },
) {
  const { name, sessionName } = await params;
  const headers = await buildForwardHeadersAsync(request);
  const body = await request.text();
  
  const resp = await fetch(
    `${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions/${encodeURIComponent(sessionName)}/git/synchronize`,
    { 
      method: 'POST', 
      headers,
      body,
    }
  );
  
  const data = await resp.text();
  return new Response(data, { 
    status: resp.status, 
    headers: { 'Content-Type': 'application/json' } 
  });
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/agentic-sessions/[sessionName]/k8s-resources/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

export async function GET(
  request: Request,
  { params }: { params: Promise<{ name: string; sessionName: string }> },
) {
  const { name, sessionName } = await params;
  const headers = await buildForwardHeadersAsync(request);
  const resp = await fetch(
    `${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions/${encodeURIComponent(sessionName)}/k8s-resources`,
    { headers }
  );
  const data = await resp.text();
  return new Response(data, { status: resp.status, headers: { 'Content-Type': 'application/json' } });
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/agentic-sessions/[sessionName]/repos/[repoName]/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

export async function DELETE(
  request: Request,
  { params }: { params: Promise<{ name: string; sessionName: string; repoName: string }> },
) {
  const { name, sessionName, repoName } = await params;
  const headers = await buildForwardHeadersAsync(request);
  
  const resp = await fetch(
    `${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions/${encodeURIComponent(sessionName)}/repos/${encodeURIComponent(repoName)}`,
    { 
      method: 'DELETE', 
      headers,
    }
  );
  
  const data = await resp.text();
  return new Response(data, { 
    status: resp.status, 
    headers: { 'Content-Type': 'application/json' } 
  });
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/agentic-sessions/[sessionName]/repos/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

export async function POST(
  request: Request,
  { params }: { params: Promise<{ name: string; sessionName: string }> },
) {
  const { name, sessionName } = await params;
  const headers = await buildForwardHeadersAsync(request);
  const body = await request.text();
  
  const resp = await fetch(
    `${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions/${encodeURIComponent(sessionName)}/repos`,
    { 
      method: 'POST', 
      headers,
      body,
    }
  );
  
  const data = await resp.text();
  return new Response(data, { 
    status: resp.status, 
    headers: { 'Content-Type': 'application/json' } 
  });
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/agentic-sessions/[sessionName]/spawn-content-pod/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

export async function POST(
  request: Request,
  { params }: { params: Promise<{ name: string; sessionName: string }> },
) {
  const { name, sessionName } = await params;
  const headers = await buildForwardHeadersAsync(request);
  const resp = await fetch(
    `${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions/${encodeURIComponent(sessionName)}/spawn-content-pod`,
    { method: 'POST', headers }
  );
  const data = await resp.text();
  return new Response(data, { status: resp.status, headers: { 'Content-Type': 'application/json' } });
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/agentic-sessions/[sessionName]/start/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

export async function POST(
  request: Request,
  { params }: { params: Promise<{ name: string; sessionName: string }> },
) {
  const { name, sessionName } = await params;
  const headers = await buildForwardHeadersAsync(request);
  const resp = await fetch(
    `${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions/${encodeURIComponent(sessionName)}/start`,
    { method: 'POST', headers }
  );
  const data = await resp.text();
  return new Response(data, { status: resp.status, headers: { 'Content-Type': 'application/json' } });
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/agentic-sessions/[sessionName]/workflow/metadata/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

export async function GET(
  request: Request,
  { params }: { params: Promise<{ name: string; sessionName: string }> },
) {
  const { name, sessionName } = await params;
  const headers = await buildForwardHeadersAsync(request);
  const resp = await fetch(
    `${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions/${encodeURIComponent(sessionName)}/workflow/metadata`,
    { headers }
  );
  const data = await resp.text();
  return new Response(data, { status: resp.status, headers: { 'Content-Type': 'application/json' } });
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/agentic-sessions/[sessionName]/workflow/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

export async function POST(
  request: Request,
  { params }: { params: Promise<{ name: string; sessionName: string }> },
) {
  const { name, sessionName } = await params;
  const headers = await buildForwardHeadersAsync(request);
  const body = await request.text();
  
  const resp = await fetch(
    `${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions/${encodeURIComponent(sessionName)}/workflow`,
    { 
      method: 'POST', 
      headers,
      body,
    }
  );
  
  const data = await resp.text();
  return new Response(data, { 
    status: resp.status, 
    headers: { 'Content-Type': 'application/json' } 
  });
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/agentic-sessions/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

// GET /api/projects/[name]/agentic-sessions - List sessions in a project
export async function GET(
  request: Request,
  { params }: { params: Promise<{ name: string }> }
) {
  try {
    const { name } = await params;
    const headers = await buildForwardHeadersAsync(request);
    const response = await fetch(`${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions`, { headers });
    const text = await response.text();
    return new Response(text, { status: response.status, headers: { 'Content-Type': 'application/json' } });
  } catch (error) {
    console.error('Error listing agentic sessions:', error);
    return Response.json({ error: 'Failed to list agentic sessions' }, { status: 500 });
  }
}

// POST /api/projects/[name]/agentic-sessions - Create a new session in a project
export async function POST(
  request: Request,
  { params }: { params: Promise<{ name: string }> }
) {
  try {
    const { name } = await params;
    const body = await request.text();
    const headers = await buildForwardHeadersAsync(request);
    
    console.log('[API Route] Creating session for project:', name);
    console.log('[API Route] Auth headers present:', {
      hasUser: !!headers['X-Forwarded-User'],
      hasUsername: !!headers['X-Forwarded-Preferred-Username'],
      hasToken: !!headers['X-Forwarded-Access-Token'],
      hasEmail: !!headers['X-Forwarded-Email'],
    });
    
    const response = await fetch(`${BACKEND_URL}/projects/${encodeURIComponent(name)}/agentic-sessions`, {
      method: 'POST',
      headers,
      body,
    });
    
    const text = await response.text();
    console.log('[API Route] Backend response status:', response.status);
    if (!response.ok) {
      console.error('[API Route] Backend error:', text);
    }
    
    return new Response(text, { status: response.status, headers: { 'Content-Type': 'application/json' } });
  } catch (error) {
    console.error('Error creating agentic session:', error);
    return Response.json({ error: 'Failed to create agentic session', details: error instanceof Error ? error.message : String(error) }, { status: 500 });
  }
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/integration-secrets/route.ts">
import { BACKEND_URL } from '@/lib/config';
import { buildForwardHeadersAsync } from '@/lib/auth';

// GET /api/projects/[name]/integration-secrets
export async function GET(
  request: Request,
  { params }: { params: Promise<{ name: string }> }
) {
  try {
    const { name } = await params;
    const headers = await buildForwardHeadersAsync(request);
    const response = await fetch(`${BACKEND_URL}/projects/${encodeURIComponent(name)}/integration-secrets`, { headers });
    const text = await response.text();
    return new Response(text, { status: response.status, headers: { 'Content-Type': 'application/json' } });
  } catch (error) {
    console.error('Error getting integration secrets:', error);
    return Response.json({ error: 'Failed to get integration secrets' }, { status: 500 });
  }
}

// PUT /api/projects/[name]/integration-secrets
export async function PUT(
  request: Request,
  { params }: { params: Promise<{ name: string }> }
) {
  try {
    const { name } = await params;
    const body = await request.text();
    const headers = await buildForwardHeadersAsync(request);
    const response = await fetch(`${BACKEND_URL}/projects/${encodeURIComponent(name)}/integration-secrets`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', ...headers },
      body,
    });
    const text = await response.text();
    return new Response(text, { status: response.status, headers: { 'Content-Type': 'application/json' } });
  } catch (error) {
    console.error('Error updating integration secrets:', error);
    return Response.json({ error: 'Failed to update integration secrets' }, { status: 500 });
  }
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/repo/blob/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { BACKEND_URL } from "@/lib/config";
import { buildForwardHeadersAsync } from "@/lib/auth";

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ name: string }> }
) {
  try {
    const { name: projectName } = await params;
    const headers = await buildForwardHeadersAsync(request);

    // Get query parameters
    const searchParams = request.nextUrl.searchParams;
    const repo = searchParams.get('repo');
    const ref = searchParams.get('ref');
    const path = searchParams.get('path');

    // Build query string
    const queryParams = new URLSearchParams();
    if (repo) queryParams.set('repo', repo);
    if (ref) queryParams.set('ref', ref);
    if (path) queryParams.set('path', path);

    // Forward the request to the backend
    const response = await fetch(
      `${BACKEND_URL}/projects/${projectName}/repo/blob?${queryParams.toString()}`,
      {
        method: "GET",
        headers,
      }
    );

    // Forward the response from backend
    const data = await response.text();

    return new NextResponse(data, {
      status: response.status,
      headers: {
        "Content-Type": "application/json",
      },
    });
  } catch (error) {
    console.error("Failed to fetch repo blob:", error);
    return NextResponse.json(
      { error: "Failed to fetch repo blob" },
      { status: 500 }
    );
  }
}
</file>

<file path="components/frontend/src/app/api/projects/[name]/repo/tree/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { BACKEND_URL } from "@/lib/config";
import { buildForwardHeadersAsync } from "@/lib/auth";

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ name: string }> }
) {
  try {
    const { name: projectName } = await params;
    const headers = await buildForwardHeadersAsync(request);

    // Get query parameters
    const searchParams = request.nextUrl.searchParams;
    const repo = searchParams.get('repo');
    const ref = searchParams.get('ref');
    const path = searchParams.get('path');

    // Build query string
    const queryParams = new URLSearchParams();
    if (repo) queryParams.set('repo', repo);
    if (ref) queryParams.set('ref', ref);
    if (path) queryParams.set('path', path);

    // Forward the request to the backend
    const response = await fetch(
      `${BACKEND_URL}/projects/${projectName}/repo/tree?${queryParams.toString()}`,
      {
        method: "GET",
        headers,
      }
    );

    // Forward the response from backend
    const data = await response.text();

    return new NextResponse(data, {
      status: response.status,
      headers: {
        "Content-Type": "application/json",
      },
    });
  } catch (error) {
    console.error("Failed to fetch repo tree:", error);
    return NextResponse.json(
      { error: "Failed to fetch repo tree" },
      { status: 500 }
    );
  }
}
</file>

<file path="components/frontend/src/app/api/version/route.ts">
import { env } from '@/lib/env';

export async function GET() {
  return Response.json({
    version: env.VTEAM_VERSION,
  });
}
</file>

<file path="components/frontend/src/app/api/workflows/ootb/route.ts">
import { BACKEND_URL } from "@/lib/config";

export async function GET() {
  try {
    // No auth required for public OOTB workflows endpoint
    const response = await fetch(`${BACKEND_URL}/workflows/ootb`, {
      method: 'GET',
      headers: {
        "Content-Type": "application/json",
      },
    });

    // Forward the response from backend
    const data = await response.text();

    return new Response(data, {
      status: response.status,
      headers: {
        "Content-Type": "application/json",
      },
    });
  } catch (error) {
    console.error("Failed to fetch OOTB workflows:", error);
    return new Response(
      JSON.stringify({ error: "Failed to fetch OOTB workflows" }),
      { 
        status: 500,
        headers: { "Content-Type": "application/json" }
      }
    );
  }
}
</file>

<file path="components/frontend/src/app/integrations/github/setup/page.tsx">
'use client'

import React, { useEffect, useState } from 'react'
import { Button } from '@/components/ui/button'
import { Alert, AlertDescription } from '@/components/ui/alert'
import { useConnectGitHub } from '@/services/queries'

export default function GitHubSetupPage() {
  const [message, setMessage] = useState<string>('Finalizing GitHub connection...')
  const [error, setError] = useState<string | null>(null)
  const connectMutation = useConnectGitHub()

  useEffect(() => {
    const url = new URL(window.location.href)
    const installationId = url.searchParams.get('installation_id')

    if (!installationId) {
      setMessage('No installation was detected.')
      return
    }

    connectMutation.mutate(
      { installationId: Number(installationId) },
      {
        onSuccess: () => {
          setMessage('GitHub connected. Redirecting...')
          setTimeout(() => {
            window.location.replace('/integrations')
          }, 800)
        },
        onError: (err) => {
          setError(err instanceof Error ? err.message : 'Failed to complete setup')
        },
      }
    )
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  return (
    <div className="max-w-lg mx-auto p-6">
      {error ? (
        <Alert variant="destructive"><AlertDescription>{error}</AlertDescription></Alert>
      ) : (
        <div className="text-sm text-gray-700">{message}</div>
      )}
      <div className="mt-4">
        <Button variant="ghost" onClick={() => window.location.replace('/integrations')}>Back to Integrations</Button>
      </div>
    </div>
  )
}
</file>

<file path="components/frontend/src/app/projects/[name]/keys/error.tsx">
'use client';

import { useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { AlertCircle } from 'lucide-react';

export default function KeysError({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    console.error('Keys page error:', error);
  }, [error]);

  return (
    <div className="container mx-auto p-6">
      <Card className="max-w-lg mx-auto mt-12">
        <CardHeader>
          <div className="flex items-center gap-2">
            <AlertCircle className="h-5 w-5 text-destructive" />
            <CardTitle>Failed to load keys</CardTitle>
          </div>
          <CardDescription>
            {error.message || 'An unexpected error occurred while loading API keys.'}
          </CardDescription>
        </CardHeader>
        <CardContent>
          <Button onClick={reset}>Try again</Button>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="components/frontend/src/app/projects/[name]/keys/loading.tsx">
import { TableSkeleton } from '@/components/skeletons';

export default function KeysLoading() {
  return <TableSkeleton rows={5} columns={3} />;
}
</file>

<file path="components/frontend/src/app/projects/[name]/keys/page.tsx">
'use client';

import { useCallback, useState } from 'react';
import { useParams } from 'next/navigation';
import { formatDistanceToNow } from 'date-fns';
import { Copy, KeyRound, Loader2, Plus, RefreshCw, Trash2, Eye, Edit, Shield } from 'lucide-react';

import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Badge } from '@/components/ui/badge';
import { Label } from '@/components/ui/label';
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { ProjectSubpageHeader } from '@/components/project-subpage-header';
import { ErrorMessage } from '@/components/error-message';
import { EmptyState } from '@/components/empty-state';
import { DestructiveConfirmationDialog } from '@/components/confirmation-dialog';
import { Breadcrumbs } from '@/components/breadcrumbs';

import { useKeys, useCreateKey, useDeleteKey } from '@/services/queries';
import { successToast, errorToast } from '@/hooks/use-toast';
import type { CreateKeyRequest } from '@/services/api/keys';

const ROLE_DEFINITIONS = {
  view: {
    label: 'View',
    description: 'Can see sessions and duplicate to their own project',
    color: 'bg-blue-100 text-blue-800',
    icon: Eye,
  },
  edit: {
    label: 'Edit',
    description: 'Can create sessions in the project',
    color: 'bg-green-100 text-green-800',
    icon: Edit,
  },
  admin: {
    label: 'Admin',
    description: 'Full project management access',
    color: 'bg-purple-100 text-purple-800',
    icon: Shield,
  },
} as const;

export default function ProjectKeysPage() {
  const params = useParams();
  const projectName = params?.name as string;

  // React Query hooks replace all manual state management
  const { data: keys = [], isLoading, error, refetch } = useKeys(projectName);
  const createKeyMutation = useCreateKey();
  const deleteKeyMutation = useDeleteKey();

  // Local UI state
  const [showCreate, setShowCreate] = useState(false);
  const [newKeyName, setNewKeyName] = useState('');
  const [newKeyDesc, setNewKeyDesc] = useState('');
  const [newKeyRole, setNewKeyRole] = useState<'view' | 'edit' | 'admin'>('edit');
  const [oneTimeKey, setOneTimeKey] = useState<string | null>(null);
  const [oneTimeKeyName, setOneTimeKeyName] = useState<string>('');
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [keyToDelete, setKeyToDelete] = useState<{ id: string; name: string } | null>(null);

  const handleCreate = useCallback(() => {
    if (!newKeyName.trim()) return;

    const request: CreateKeyRequest = {
      name: newKeyName.trim(),
      description: newKeyDesc.trim() || undefined,
      role: newKeyRole,
    };

    createKeyMutation.mutate(
      { projectName, data: request },
      {
        onSuccess: (data) => {
          successToast(`Access key "${data.name}" created successfully`);
          setOneTimeKey(data.key);
          setOneTimeKeyName(data.name);
          setNewKeyName('');
          setNewKeyDesc('');
          setShowCreate(false);
        },
        onError: (error) => {
          errorToast(error instanceof Error ? error.message : 'Failed to create key');
        },
      }
    );
  }, [newKeyName, newKeyDesc, newKeyRole, projectName, createKeyMutation]);

  const openDeleteDialog = useCallback((keyId: string, keyName: string) => {
    setKeyToDelete({ id: keyId, name: keyName });
    setShowDeleteDialog(true);
  }, []);

  const confirmDelete = useCallback(() => {
    if (!keyToDelete) return;
    deleteKeyMutation.mutate(
      { projectName, keyId: keyToDelete.id },
      {
        onSuccess: () => {
          successToast(`Access key "${keyToDelete.name}" deleted successfully`);

          setShowDeleteDialog(false);
          setKeyToDelete(null);
        },
      }
    );
  }, [keyToDelete, projectName, deleteKeyMutation]);

  const copy = async (text: string) => {
    try {
      await navigator.clipboard.writeText(text);
    } catch {}
  };

  if (!projectName || (isLoading && keys.length === 0)) {
    return (
      <div className="container mx-auto p-6">
        <div className="flex items-center justify-center h-64">
          <RefreshCw className="animate-spin h-8 w-8" />
          <span className="ml-2">Loading access keys...</span>
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto p-6">
      <Breadcrumbs
        items={[
          { label: 'Projects', href: '/projects' },
          { label: projectName, href: `/projects/${projectName}` },
          { label: 'Keys' },
        ]}
        className="mb-4"
      />
      <ProjectSubpageHeader
        title={
          <>
            <KeyRound className="w-6 h-6" />
            Access Keys
          </>
        }
        description={<>Create and manage API keys for non-user access</>}
        actions={
          <>
            <Button onClick={() => setShowCreate(true)}>
              <Plus className="w-4 h-4 mr-2" />
              Create Key
            </Button>
            <Button variant="outline" onClick={() => refetch()} disabled={isLoading}>
              <RefreshCw className={`w-4 h-4 mr-2 ${isLoading ? 'animate-spin' : ''}`} />
              Refresh
            </Button>
          </>
        }
      />

      {/* Error state */}
      {error && <ErrorMessage error={error} onRetry={() => refetch()} />}

      {/* Mutation errors */}
      {createKeyMutation.isError && (
        <div className="mb-6">
          <ErrorMessage error={createKeyMutation.error} />
        </div>
      )}
      {deleteKeyMutation.isError && (
        <div className="mb-6">
          <ErrorMessage error={deleteKeyMutation.error} />
        </div>
      )}

      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <KeyRound className="w-5 h-5" />
            Access Keys ({keys.length})
          </CardTitle>
          <CardDescription>API keys scoped to this project</CardDescription>
        </CardHeader>
        <CardContent>
          {keys.length > 0 ? (
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Name</TableHead>
                  <TableHead>Description</TableHead>
                  <TableHead>Created</TableHead>
                  <TableHead>Last Used</TableHead>
                  <TableHead>Role</TableHead>
                  <TableHead>Actions</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {keys.map((k) => {
                  const isDeletingThis = deleteKeyMutation.isPending && deleteKeyMutation.variables?.keyId === k.id;
                  return (
                    <TableRow key={k.id}>
                      <TableCell className="font-medium">{k.name}</TableCell>
                      <TableCell>
                        {k.description || (
                          <span className="text-muted-foreground italic">No description</span>
                        )}
                      </TableCell>
                      <TableCell>
                        {k.createdAt ? (
                          formatDistanceToNow(new Date(k.createdAt), { addSuffix: true })
                        ) : (
                          <span className="text-muted-foreground">Unknown</span>
                        )}
                      </TableCell>
                      <TableCell>
                        {k.lastUsedAt ? (
                          formatDistanceToNow(new Date(k.lastUsedAt), { addSuffix: true })
                        ) : (
                          <span className="text-muted-foreground">Never</span>
                        )}
                      </TableCell>
                      <TableCell>
                        {k.role ? (
                          (() => {
                            const role = k.role as keyof typeof ROLE_DEFINITIONS;
                            const cfg = ROLE_DEFINITIONS[role];
                            const Icon = cfg.icon;
                            return (
                              <Badge className={cfg.color} style={{ cursor: 'default' }}>
                                <Icon className="w-3 h-3 mr-1" />
                                {cfg.label}
                              </Badge>
                            );
                          })()
                        ) : (
                          <span className="text-muted-foreground"></span>
                        )}
                      </TableCell>
                      <TableCell>
                        <Button
                          variant="ghost"
                          size="sm"
                          onClick={() => openDeleteDialog(k.id, k.name)}
                          disabled={isDeletingThis}
                        >
                          {isDeletingThis ? (
                            <Loader2 className="w-4 h-4 animate-spin" />
                          ) : (
                            <Trash2 className="w-4 h-4" />
                          )}
                        </Button>
                      </TableCell>
                    </TableRow>
                  );
                })}
              </TableBody>
            </Table>
          ) : (
            <EmptyState
              icon={KeyRound}
              title="No access keys"
              description="Create an API key to enable non-user access"
              action={{
                label: 'Create Your First Key',
                onClick: () => setShowCreate(true),
              }}
            />
          )}
        </CardContent>
      </Card>

      {/* Create Key Dialog */}
      <Dialog open={showCreate} onOpenChange={setShowCreate}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>Create Access Key</DialogTitle>
            <DialogDescription>Provide a name and optional description</DialogDescription>
          </DialogHeader>
          <div className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="key-name">Name *</Label>
              <Input
                id="key-name"
                value={newKeyName}
                onChange={(e) => setNewKeyName(e.target.value)}
                placeholder="my-ci-key"
                maxLength={64}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="key-desc">Description</Label>
              <Input
                id="key-desc"
                value={newKeyDesc}
                onChange={(e) => setNewKeyDesc(e.target.value)}
                placeholder="Used by CI pipelines"
                maxLength={200}
              />
            </div>
            <div className="space-y-2">
              <Label>Role</Label>
              <div className="space-y-3">
                {(['view', 'edit', 'admin'] as const).map((roleKey) => {
                  const cfg = ROLE_DEFINITIONS[roleKey];
                  const Icon = cfg.icon;
                  const id = `key-role-${roleKey}`;
                  return (
                    <div key={roleKey} className="flex items-start gap-3">
                      <input
                        type="radio"
                        name="key-role"
                        id={id}
                        className="mt-1 h-4 w-4"
                        value={roleKey}
                        checked={newKeyRole === roleKey}
                        onChange={() => setNewKeyRole(roleKey)}
                        disabled={createKeyMutation.isPending}
                      />
                      <Label htmlFor={id} className="flex-1 cursor-pointer">
                        <div className="flex items-center gap-2">
                          <Icon className="w-4 h-4" />
                          <span className="font-medium">{cfg.label}</span>
                        </div>
                        <div className="text-sm text-muted-foreground ml-6">{cfg.description}</div>
                      </Label>
                    </div>
                  );
                })}
              </div>
            </div>
          </div>
          <DialogFooter>
            <Button
              variant="outline"
              onClick={() => setShowCreate(false)}
              disabled={createKeyMutation.isPending}
            >
              Cancel
            </Button>
            <Button onClick={handleCreate} disabled={createKeyMutation.isPending || !newKeyName.trim()}>
              {createKeyMutation.isPending ? (
                <>
                  <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                  Creating...
                </>
              ) : (
                'Create Key'
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* One-time Key Viewer */}
      <Dialog open={oneTimeKey !== null} onOpenChange={(open) => !open && setOneTimeKey(null)}>
        <DialogContent className="sm:max-w-[600px]">
          <DialogHeader>
            <DialogTitle>Copy Your New Access Key</DialogTitle>
            <DialogDescription>
              This is the only time the full key will be shown. Store it securely. Key name: <b>{oneTimeKeyName}</b>
            </DialogDescription>
          </DialogHeader>
          <div className="flex items-center gap-2">
            <code className="text-sm bg-muted px-2 py-2 rounded break-all w-full">{oneTimeKey || ''}</code>
            <Button variant="ghost" size="sm" onClick={() => oneTimeKey && copy(oneTimeKey)}>
              <Copy className="w-4 h-4" />
            </Button>
          </div>
          <DialogFooter>
            <Button onClick={() => setOneTimeKey(null)}>Done</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Delete confirmation dialog */}
      <DestructiveConfirmationDialog
        open={showDeleteDialog}
        onOpenChange={setShowDeleteDialog}
        onConfirm={confirmDelete}
        title="Delete Access Key"
        description={`Are you sure you want to delete the access key "${keyToDelete?.name}"? This action cannot be undone and any systems using this key will lose access.`}
        confirmText="Delete Key"
        loading={deleteKeyMutation.isPending}
      />
    </div>
  );
}
</file>

<file path="components/frontend/src/app/projects/[name]/sessions/[sessionName]/components/accordions/artifacts-accordion.tsx">
"use client";

import { Folder, NotepadText, Download, FolderSync, Loader2 } from "lucide-react";
import { AccordionItem, AccordionTrigger, AccordionContent } from "@/components/ui/accordion";
import { Button } from "@/components/ui/button";
import { FileTree, type FileTreeNode } from "@/components/file-tree";

type WorkspaceFile = {
  name: string;
  path: string;
  isDir: boolean;
  size?: number;
};

type ArtifactsAccordionProps = {
  files: WorkspaceFile[];
  currentSubPath: string;
  viewingFile: { path: string; content: string } | null;
  isLoadingFile: boolean;
  onFileOrFolderSelect: (node: FileTreeNode) => void;
  onRefresh: () => void;
  onDownloadFile: () => void;
  onNavigateBack: () => void;
};

export function ArtifactsAccordion({
  files,
  currentSubPath,
  viewingFile,
  isLoadingFile,
  onFileOrFolderSelect,
  onRefresh,
  onDownloadFile,
  onNavigateBack,
}: ArtifactsAccordionProps) {
  return (
    <AccordionItem value="artifacts" className="border rounded-lg px-3 bg-white">
      <AccordionTrigger className="text-base font-semibold hover:no-underline py-3">
        <div className="flex items-center gap-2">
          <NotepadText className="h-4 w-4" />
          <span>Artifacts</span>
        </div>
      </AccordionTrigger>
      <AccordionContent className="pt-2 pb-3">
        <div className="space-y-3">
          <p className="text-sm text-muted-foreground">
            Artifacts created by the AI will be added here.
          </p>
          
          {/* File Browser for Artifacts */}
          <div className="border rounded-lg overflow-hidden">
            {/* Header with breadcrumbs and actions */}
            <div className="px-2 py-1.5 border-b flex items-center justify-between bg-muted/30">
              <div className="flex items-center gap-1 text-xs text-muted-foreground min-w-0 flex-1">
                {/* Back button when in subfolder or viewing file */}
                {(currentSubPath || viewingFile) && (
                  <Button 
                    variant="ghost" 
                    size="sm" 
                    onClick={onNavigateBack}
                    className="h-6 px-1.5 mr-1"
                  >
                     Back
                  </Button>
                )}
                
                {/* Breadcrumb path */}
                <Folder className="inline h-3 w-3 mr-1 flex-shrink-0" />
                <code className="bg-muted px-1 py-0.5 rounded text-xs truncate">
                  artifacts
                  {currentSubPath && `/${currentSubPath}`}
                  {viewingFile && `/${viewingFile.path}`}
                </code>
              </div>

              {/* Action buttons */}
              {viewingFile ? (
                /* Download button when viewing file */
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={onDownloadFile}
                  className="h-6 px-2 flex-shrink-0"
                  title="Download file"
                >
                  <Download className="h-3 w-3" />
                </Button>
              ) : (
                /* Refresh button when not viewing file */
                <Button 
                  variant="ghost" 
                  size="sm" 
                  onClick={onRefresh} 
                  className="h-6 px-2 flex-shrink-0"
                >
                  <FolderSync className="h-3 w-3" />
                </Button>
              )}
            </div>
            
            {/* Content area */}
            <div className="p-2 max-h-64 overflow-y-auto">
              {isLoadingFile ? (
                <div className="flex items-center justify-center py-8">
                  <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
                </div>
              ) : viewingFile ? (
                /* File content view */
                <div className="text-xs">
                  <pre className="bg-muted/50 p-2 rounded overflow-x-auto">
                    <code>{viewingFile.content}</code>
                  </pre>
                </div>
              ) : files.length === 0 ? (
                /* Empty state */
                <div className="text-center py-4 text-sm text-muted-foreground">
                  <NotepadText className="h-8 w-8 mx-auto mb-2 opacity-30" />
                  <p>No artifacts yet</p>
                  <p className="text-xs mt-1">AI-generated artifacts will appear here</p>
                </div>
              ) : (
                /* File tree */
                <FileTree 
                  nodes={files.map((item): FileTreeNode => ({
                    name: item.name,
                    path: item.path,
                    type: item.isDir ? 'folder' : 'file',
                    sizeKb: item.size ? item.size / 1024 : undefined,
                  }))}
                  onSelect={onFileOrFolderSelect}
                />
              )}
            </div>
          </div>
        </div>
      </AccordionContent>
    </AccordionItem>
  );
}
</file>

<file path="components/frontend/src/app/projects/[name]/sessions/[sessionName]/components/accordions/repositories-accordion.tsx">
"use client";

import { useState } from "react";
import { GitBranch, X, Link, Loader2 } from "lucide-react";
import { AccordionItem, AccordionTrigger, AccordionContent } from "@/components/ui/accordion";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";

type Repository = {
  input: {
    url: string;
    branch?: string;
  };
};

type RepositoriesAccordionProps = {
  repositories?: Repository[];
  onAddRepository: () => void;
  onRemoveRepository: (repoName: string) => void;
};

export function RepositoriesAccordion({
  repositories = [],
  onAddRepository,
  onRemoveRepository,
}: RepositoriesAccordionProps) {
  const [removingRepo, setRemovingRepo] = useState<string | null>(null);

  const handleRemove = async (repoName: string) => {
    if (confirm(`Remove repository ${repoName}?`)) {
      setRemovingRepo(repoName);
      try {
        await onRemoveRepository(repoName);
      } finally {
        setRemovingRepo(null);
      }
    }
  };

  return (
    <AccordionItem value="context" className="border rounded-lg px-3 bg-white">
      <AccordionTrigger className="text-base font-semibold hover:no-underline py-3">
        <div className="flex items-center gap-2">
          <Link className="h-4 w-4" />
          <span>Context</span>
          {repositories.length > 0 && (
            <Badge variant="secondary" className="ml-auto mr-2">
              {repositories.length}
            </Badge>
          )}
        </div>
      </AccordionTrigger>
      <AccordionContent className="pt-2 pb-3">
        <div className="space-y-3">
          <p className="text-sm text-muted-foreground">
            Add additional context to improve AI responses.
          </p>
          
          {/* Repository List */}
          {repositories.length === 0 ? (
            <div className="text-center py-6">
              <div className="inline-flex items-center justify-center w-12 h-12 rounded-full bg-gray-100 mb-2">
                <Link className="h-5 w-5 text-gray-400" />
              </div>
              <p className="text-sm text-muted-foreground mb-3">No context added yet</p>
              <Button size="sm" variant="outline" onClick={onAddRepository}>
                <Link className="mr-2 h-3 w-3" />
                Add Context
              </Button>
            </div>
          ) : (
            <div className="space-y-2">
              {repositories.map((repo, idx) => {
                const repoName = repo.input.url.split('/').pop()?.replace('.git', '') || `repo-${idx}`;
                const isRemoving = removingRepo === repoName;
                
                return (
                  <div key={idx} className="flex items-center gap-2 p-2 border rounded bg-muted/30 hover:bg-muted/50 transition-colors">
                    <GitBranch className="h-4 w-4 text-muted-foreground flex-shrink-0" />
                    <div className="flex-1 min-w-0">
                      <div className="text-sm font-medium truncate">{repoName}</div>
                      <div className="text-xs text-muted-foreground truncate">{repo.input.url}</div>
                    </div>
                    <Button 
                      variant="ghost"
                      size="sm" 
                      className="h-7 w-7 p-0 flex-shrink-0"
                      onClick={() => handleRemove(repoName)}
                      disabled={isRemoving}
                    >
                      {isRemoving ? (
                        <Loader2 className="h-3 w-3 animate-spin" />
                      ) : (
                        <X className="h-3 w-3" />
                      )}
                    </Button>
                  </div>
                );
              })}
              <Button onClick={onAddRepository} variant="outline" className="w-full" size="sm">
                <Link className="mr-2 h-3 w-3" />
                Add Context
              </Button>
            </div>
          )}
        </div>
      </AccordionContent>
    </AccordionItem>
  );
}
</file>

<file path="components/frontend/src/app/projects/[name]/sessions/[sessionName]/components/modals/add-context-modal.tsx">
"use client";

import { useState } from "react";
import { Loader2, Info } from "lucide-react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Alert, AlertDescription } from "@/components/ui/alert";

type AddContextModalProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onAddRepository: (url: string, branch: string) => Promise<void>;
  isLoading?: boolean;
};

export function AddContextModal({
  open,
  onOpenChange,
  onAddRepository,
  isLoading = false,
}: AddContextModalProps) {
  const [contextUrl, setContextUrl] = useState("");
  const [contextBranch, setContextBranch] = useState("main");

  const handleSubmit = async () => {
    if (!contextUrl.trim()) return;
    
    await onAddRepository(contextUrl.trim(), contextBranch.trim() || 'main');
    
    // Reset form
    setContextUrl("");
    setContextBranch("main");
  };

  const handleCancel = () => {
    setContextUrl("");
    setContextBranch("main");
    onOpenChange(false);
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[600px]">
        <DialogHeader>
          <DialogTitle>Add Context</DialogTitle>
          <DialogDescription>
            Add additional context to improve AI responses.
          </DialogDescription>
        </DialogHeader>
        
        <div className="space-y-4">
          <Alert>
            <Info className="h-4 w-4" />
            <AlertDescription>
              Note: additional data sources like Jira, Google Drive, files, and MCP Servers are on the roadmap!
            </AlertDescription>
          </Alert>

          <div className="space-y-2">
            <Label htmlFor="context-url">Repository URL</Label>
            <Input
              id="context-url"
              placeholder="https://github.com/org/repo"
              value={contextUrl}
              onChange={(e) => setContextUrl(e.target.value)}
            />
            <p className="text-xs text-muted-foreground">
              Currently supports GitHub repositories for code context
            </p>
          </div>

          <div className="space-y-2">
            <Label htmlFor="context-branch">Branch (optional)</Label>
            <Input
              id="context-branch"
              placeholder="main"
              value={contextBranch}
              onChange={(e) => setContextBranch(e.target.value)}
            />
            <p className="text-xs text-muted-foreground">
              Leave empty to use the default branch
            </p>
          </div>
        </div>

        <DialogFooter>
          <Button
            type="button"
            variant="outline"
            onClick={handleCancel}
          >
            Cancel
          </Button>
          <Button
            type="button"
            onClick={handleSubmit}
            disabled={!contextUrl.trim() || isLoading}
          >
            {isLoading ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Adding...
              </>
            ) : (
              'Add'
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="components/frontend/src/app/projects/[name]/sessions/[sessionName]/components/modals/commit-changes-dialog.tsx">
"use client";

import { useState } from "react";
import { Loader2 } from "lucide-react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import type { GitStatus } from "@/services/api/workspace";

type CommitChangesDialogProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onCommit: (message: string) => Promise<void>;
  gitStatus: GitStatus | null;
  directoryName: string;
  isCommitting?: boolean;
};

export function CommitChangesDialog({
  open,
  onOpenChange,
  onCommit,
  gitStatus,
  directoryName,
  isCommitting = false,
}: CommitChangesDialogProps) {
  const [commitMessage, setCommitMessage] = useState("");

  const handleCommit = async () => {
    if (!commitMessage.trim()) return;
    
    await onCommit(commitMessage.trim());
    setCommitMessage("");
  };

  const handleCancel = () => {
    setCommitMessage("");
    onOpenChange(false);
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-md">
        <DialogHeader>
          <DialogTitle>Commit Changes</DialogTitle>
          <DialogDescription>
            Commit {gitStatus?.uncommittedFiles || 0} files to {directoryName}
          </DialogDescription>
        </DialogHeader>
        
        <div className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="commit-message">Commit Message *</Label>
            <Input
              id="commit-message"
              placeholder="Update feature specification"
              value={commitMessage}
              onChange={(e) => setCommitMessage(e.target.value)}
              onKeyDown={(e) => {
                if (e.key === 'Enter' && commitMessage.trim()) {
                  handleCommit();
                }
              }}
              autoFocus
            />
          </div>
          
          {gitStatus && (
            <div className="text-xs text-muted-foreground bg-muted p-2 rounded">
              <div className="font-medium mb-1">Changes to commit:</div>
              <div className="space-y-0.5">
                <div>Files: {gitStatus.uncommittedFiles ?? 0}</div>
                <div className="text-green-600">+{gitStatus.totalAdded ?? 0} lines</div>
                {(gitStatus.totalRemoved ?? 0) > 0 && (
                  <div className="text-red-600">-{gitStatus.totalRemoved} lines</div>
                )}
              </div>
            </div>
          )}
        </div>
        
        <DialogFooter>
          <Button
            variant="outline"
            onClick={handleCancel}
          >
            Cancel
          </Button>
          <Button
            onClick={handleCommit}
            disabled={!commitMessage.trim() || isCommitting}
          >
            {isCommitting ? (
              <>
                <Loader2 className="mr-2 h-3 w-3 animate-spin" />
                Committing...
              </>
            ) : (
              'Commit'
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="components/frontend/src/app/projects/[name]/sessions/[sessionName]/components/modals/custom-workflow-dialog.tsx">
"use client";

import { useState } from "react";
import { Loader2 } from "lucide-react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";

type CustomWorkflowDialogProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSubmit: (url: string, branch: string, path: string) => void;
  isActivating?: boolean;
};

export function CustomWorkflowDialog({
  open,
  onOpenChange,
  onSubmit,
  isActivating = false,
}: CustomWorkflowDialogProps) {
  const [customWorkflowUrl, setCustomWorkflowUrl] = useState("");
  const [customWorkflowBranch, setCustomWorkflowBranch] = useState("main");
  const [customWorkflowPath, setCustomWorkflowPath] = useState("");

  const handleSubmit = () => {
    if (!customWorkflowUrl.trim()) return;
    
    onSubmit(
      customWorkflowUrl.trim(),
      customWorkflowBranch.trim() || "main",
      customWorkflowPath.trim() || ""
    );
    
    // Reset form
    setCustomWorkflowUrl("");
    setCustomWorkflowBranch("main");
    setCustomWorkflowPath("");
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Load Custom Workflow</DialogTitle>
          <DialogDescription>
            Enter the Git repository URL and optional path for your custom workflow.
          </DialogDescription>
        </DialogHeader>
        
        <div className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="workflow-url">Git Repository URL *</Label>
            <Input
              id="workflow-url"
              placeholder="https://github.com/org/workflow-repo.git"
              value={customWorkflowUrl}
              onChange={(e) => setCustomWorkflowUrl(e.target.value)}
              disabled={isActivating}
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="workflow-branch">Branch</Label>
            <Input
              id="workflow-branch"
              placeholder="main"
              value={customWorkflowBranch}
              onChange={(e) => setCustomWorkflowBranch(e.target.value)}
              disabled={isActivating}
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="workflow-path">Path (optional)</Label>
            <Input
              id="workflow-path"
              placeholder="workflows/my-workflow"
              value={customWorkflowPath}
              onChange={(e) => setCustomWorkflowPath(e.target.value)}
              disabled={isActivating}
            />
            <p className="text-xs text-muted-foreground">
              Optional subdirectory within the repository containing the workflow
            </p>
          </div>
        </div>

        <DialogFooter>
          <Button
            variant="outline"
            onClick={() => onOpenChange(false)}
            disabled={isActivating}
          >
            Cancel
          </Button>
          <Button
            onClick={handleSubmit}
            disabled={!customWorkflowUrl.trim() || isActivating}
          >
            {isActivating ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Loading...
              </>
            ) : (
              'Load Workflow'
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="components/frontend/src/app/projects/[name]/sessions/[sessionName]/components/modals/manage-remote-dialog.tsx">
"use client";

import { useState, useEffect } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Loader2 } from "lucide-react";

type MergeStatus = {
  canMergeClean: boolean;
  conflictingFiles: string[];
  remoteCommitsAhead?: number;
  localCommitsAhead?: number;
};

type ManageRemoteDialogProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSave: (url: string, branch: string) => Promise<void>;
  directoryName: string;
  currentUrl?: string;
  currentBranch?: string;
  remoteBranches?: string[];
  mergeStatus?: MergeStatus | null;
  isLoading?: boolean;
};

export function ManageRemoteDialog({
  open,
  onOpenChange,
  onSave,
  directoryName,
  currentUrl = "",
  currentBranch = "main",
  remoteBranches = [],
  mergeStatus,
  isLoading = false,
}: ManageRemoteDialogProps) {
  const [remoteUrl, setRemoteUrl] = useState(currentUrl);
  const [remoteBranch, setRemoteBranch] = useState(currentBranch);
  const [showCreateBranch, setShowCreateBranch] = useState(false);
  const [newBranchName, setNewBranchName] = useState("");

  // Update local state when props change
  useEffect(() => {
    setRemoteUrl(currentUrl);
    setRemoteBranch(currentBranch);
  }, [currentUrl, currentBranch, open]);

  const handleSave = async () => {
    if (!remoteUrl.trim()) return;
    
    await onSave(remoteUrl.trim(), remoteBranch.trim() || "main");
    setShowCreateBranch(false);
  };

  const handleCancel = () => {
    setShowCreateBranch(false);
    onOpenChange(false);
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-md">
        <DialogHeader>
          <DialogTitle>Manage Remote for {directoryName}</DialogTitle>
          <DialogDescription>
            Configure repository URL and select branch for git operations
          </DialogDescription>
        </DialogHeader>
        
        <div className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="remote-repo-url">Repository URL *</Label>
            <Input
              id="remote-repo-url"
              placeholder="https://github.com/org/my-repo.git"
              value={remoteUrl}
              onChange={(e) => setRemoteUrl(e.target.value)}
            />
          </div>

          {!showCreateBranch ? (
            <div className="space-y-2">
              <Label htmlFor="remote-branch">Branch</Label>
              <div className="flex gap-2">
                <Select 
                  value={remoteBranch} 
                  onValueChange={(branch) => setRemoteBranch(branch)}
                >
                  <SelectTrigger className="flex-1">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    {!remoteBranches.includes(remoteBranch) && remoteBranch && (
                      <SelectItem value={remoteBranch}>{remoteBranch} (current)</SelectItem>
                    )}
                    {remoteBranches.map(b => (
                      <SelectItem key={b} value={b}>{b}</SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                <Button 
                  size="sm"
                  variant="outline"
                  onClick={() => {
                    setShowCreateBranch(true);
                    setNewBranchName("");
                  }}
                >
                  New
                </Button>
              </div>
            </div>
          ) : (
            <div className="space-y-2">
              <Label>Create New Branch</Label>
              <Input
                placeholder="branch-name"
                value={newBranchName}
                onChange={e => setNewBranchName(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === 'Enter' && newBranchName.trim()) {
                    setRemoteBranch(newBranchName.trim());
                    setShowCreateBranch(false);
                  }
                }}
                autoFocus
              />
              <div className="flex gap-2">
                <Button 
                  size="sm"
                  className="flex-1"
                  onClick={() => {
                    setRemoteBranch(newBranchName.trim());
                    setShowCreateBranch(false);
                  }}
                  disabled={!newBranchName.trim()}
                >
                  Set Branch
                </Button>
                <Button 
                  size="sm"
                  variant="outline"
                  onClick={() => {
                    setShowCreateBranch(false);
                    setNewBranchName("");
                  }}
                >
                  Cancel
                </Button>
              </div>
            </div>
          )}
          
          {mergeStatus && !showCreateBranch && (
            <div className="text-xs text-muted-foreground border-t pt-2">
              {mergeStatus.canMergeClean ? (
                <span className="text-green-600"> Can merge cleanly</span>
              ) : (
                <span className="text-amber-600"> {mergeStatus.conflictingFiles.length} conflicts</span>
              )}
            </div>
          )}
        </div>

        <DialogFooter>
          <Button
            variant="outline"
            onClick={handleCancel}
            disabled={isLoading}
          >
            Cancel
          </Button>
          <Button
            onClick={handleSave}
            disabled={!remoteUrl.trim() || isLoading}
          >
            {isLoading ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Saving...
              </>
            ) : (
              "Save Remote"
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="components/frontend/src/app/projects/[name]/sessions/[sessionName]/components/k8s-resource-tree.tsx">
'use client';

import { useState } from 'react';
import { ChevronRight, ChevronDown, Box, Container, HardDrive, AlertCircle, CheckCircle2, Clock } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';

type K8sResourceTreeProps = {
  jobName?: string;
  jobStatus?: string;
  pods?: Array<{
    name: string;
    phase: string;
    containers: Array<{
      name: string;
      state: string;
      exitCode?: number;
      reason?: string;
    }>;
    events?: string[];
  }>;
  pvcName?: string;
  pvcExists?: boolean;
  pvcSize?: string;
  events?: string[];
};

export function K8sResourceTree({
  jobName,
  jobStatus = 'Unknown',
  pods = [],
  pvcName,
  pvcExists,
  pvcSize,
  events = [],
}: K8sResourceTreeProps) {
  const [expandedJob, setExpandedJob] = useState(true);
  const [expandedPods, setExpandedPods] = useState<Record<string, boolean>>({});

  const getStatusColor = (status: string) => {
    const lower = status.toLowerCase();
    if (lower.includes('running') || lower.includes('active')) return 'bg-blue-100 text-blue-800 border-blue-300';
    if (lower.includes('succeeded') || lower.includes('completed')) return 'bg-green-100 text-green-800 border-green-300';
    if (lower.includes('failed') || lower.includes('error')) return 'bg-red-100 text-red-800 border-red-300';
    if (lower.includes('waiting') || lower.includes('pending')) return 'bg-yellow-100 text-yellow-800 border-yellow-300';
    return 'bg-gray-100 text-gray-800 border-gray-300';
  };

  const getStatusIcon = (status: string) => {
    const lower = status.toLowerCase();
    if (lower.includes('running') || lower.includes('active')) return <Clock className="w-3 h-3" />;
    if (lower.includes('succeeded') || lower.includes('completed')) return <CheckCircle2 className="w-3 h-3" />;
    if (lower.includes('failed') || lower.includes('error')) return <AlertCircle className="w-3 h-3" />;
    return <Clock className="w-3 h-3" />;
  };

  const EventsDialog = ({ events, title }: { events: string[]; title: string }) => {
    const [open, setOpen] = useState(false);
    return (
      <Dialog open={open} onOpenChange={setOpen}>
        <Button variant="outline" size="sm" className="h-6 text-xs" onClick={() => setOpen(true)}>
          Events ({events.length})
        </Button>
        <DialogContent className="max-w-2xl max-h-[600px] overflow-y-auto">
          <DialogHeader>
            <DialogTitle>{title}</DialogTitle>
            <DialogDescription>Kubernetes events for this resource</DialogDescription>
          </DialogHeader>
          <div className="space-y-2">
            {events.length === 0 ? (
              <p className="text-sm text-gray-500">No events</p>
            ) : (
              events.map((event, idx) => (
                <div key={idx} className="text-xs font-mono bg-gray-50 p-2 rounded border">
                  {event}
                </div>
              ))
            )}
          </div>
        </DialogContent>
      </Dialog>
    );
  };

  if (!jobName) {
    return (
      <Card>
        <CardHeader>
          <CardTitle className="text-sm">Kubernetes Resources</CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-sm text-gray-500">No job information available</p>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle className="text-sm">Kubernetes Resources</CardTitle>
      </CardHeader>
      <CardContent className="space-y-2">
        {/* Job */}
        <div className="space-y-1">
          <div className="flex items-center gap-2">
            <button
              onClick={() => setExpandedJob(!expandedJob)}
              className="p-0 hover:bg-gray-100 rounded transition-colors"
            >
              {expandedJob ? (
                <ChevronDown className="w-4 h-4 text-gray-500" />
              ) : (
                <ChevronRight className="w-4 h-4 text-gray-500" />
              )}
            </button>
            <Badge variant="outline" className="text-xs">
              <Box className="w-3 h-3 mr-1" />
              Job
            </Badge>
            <span className="text-sm font-mono">{jobName}</span>
            <Badge className={`text-xs ${getStatusColor(jobStatus)}`}>
              {getStatusIcon(jobStatus)}
              <span className="ml-1">{jobStatus}</span>
            </Badge>
            {events.length > 0 && <EventsDialog events={events} title={`Job: ${jobName}`} />}
          </div>

          {expandedJob && (
            <div className="ml-6 space-y-2 border-l-2 border-gray-200 pl-4">
              {/* Pods */}
              {pods.map((pod) => (
                <div key={pod.name} className="space-y-1">
                  <div className="flex items-center gap-2">
                    <button
                      onClick={() => setExpandedPods({ ...expandedPods, [pod.name]: !expandedPods[pod.name] })}
                      className="p-0 hover:bg-gray-100 rounded transition-colors"
                    >
                      {expandedPods[pod.name] ? (
                        <ChevronDown className="w-4 h-4 text-gray-500" />
                      ) : (
                        <ChevronRight className="w-4 h-4 text-gray-500" />
                      )}
                    </button>
                    <Badge variant="outline" className="text-xs">
                      <Container className="w-3 h-3 mr-1" />
                      Pod
                    </Badge>
                    <span className="text-sm font-mono truncate max-w-xs" title={pod.name}>
                      {pod.name}
                    </span>
                    <Badge className={`text-xs ${getStatusColor(pod.phase)}`}>
                      {getStatusIcon(pod.phase)}
                      <span className="ml-1">{pod.phase}</span>
                    </Badge>
                    {pod.events && pod.events.length > 0 && (
                      <EventsDialog events={pod.events} title={`Pod: ${pod.name}`} />
                    )}
                  </div>

                  {expandedPods[pod.name] && (
                    <div className="ml-6 space-y-1 border-l-2 border-gray-200 pl-4">
                      {/* Containers */}
                      {pod.containers.map((container) => (
                        <div key={container.name} className="flex items-center gap-2">
                          <Badge variant="outline" className="text-xs">
                            <Box className="w-3 h-3 mr-1" />
                            Container
                          </Badge>
                          <span className="text-sm font-mono">{container.name}</span>
                          <Badge className={`text-xs ${getStatusColor(container.state)}`}>
                            {getStatusIcon(container.state)}
                            <span className="ml-1">{container.state}</span>
                          </Badge>
                          {container.exitCode !== undefined && (
                            <span className="text-xs text-gray-500">Exit: {container.exitCode}</span>
                          )}
                          {container.reason && (
                            <span className="text-xs text-gray-500">({container.reason})</span>
                          )}
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              ))}

              {/* PVC */}
              {pvcName && (
                <div className="flex items-center gap-2">
                  <Badge variant="outline" className="text-xs">
                    <HardDrive className="w-3 h-3 mr-1" />
                    PVC
                  </Badge>
                  <span className="text-sm font-mono">{pvcName}</span>
                  <Badge className={`text-xs ${pvcExists ? 'bg-green-100 text-green-800 border-green-300' : 'bg-red-100 text-red-800 border-red-300'}`}>
                    {pvcExists ? 'Exists' : 'Not Found'}
                  </Badge>
                  {pvcSize && <span className="text-xs text-gray-500">{pvcSize}</span>}
                </div>
              )}
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="components/frontend/src/app/projects/[name]/sessions/[sessionName]/hooks/use-file-operations.ts">
"use client";

import { useState, useCallback } from "react";
import { errorToast, successToast } from "@/hooks/use-toast";
import { readWorkspaceFile } from "@/services/api/workspace";
import type { FileTreeNode } from "@/components/file-tree";

type ViewingFile = {
  path: string;
  content: string;
};

type UseFileOperationsProps = {
  projectName: string;
  sessionName: string;
  basePath: string;
};

export function useFileOperations({
  projectName,
  sessionName,
  basePath,
}: UseFileOperationsProps) {
  const [currentSubPath, setCurrentSubPath] = useState<string>("");
  const [viewingFile, setViewingFile] = useState<ViewingFile | null>(null);
  const [loadingFile, setLoadingFile] = useState(false);

  // Navigate into folder or load file content
  const handleFileOrFolderSelect = useCallback(async (node: FileTreeNode) => {
    if (node.type === 'folder') {
      // Navigate into folder
      const newSubPath = currentSubPath ? `${currentSubPath}/${node.name}` : node.name;
      setCurrentSubPath(newSubPath);
      setViewingFile(null);
    } else {
      // Load file content inline
      setLoadingFile(true);
      try {
        const fullPath = currentSubPath 
          ? `${basePath}/${currentSubPath}/${node.name}`
          : `${basePath}/${node.name}`;
        
        const content = await readWorkspaceFile(projectName, sessionName, fullPath);
        setViewingFile({ path: node.name, content });
      } catch (error) {
        console.error("Failed to load file:", error);
        errorToast(error instanceof Error ? error.message : 'Failed to load file');
      } finally {
        setLoadingFile(false);
      }
    }
  }, [projectName, sessionName, basePath, currentSubPath]);

  // Download the currently viewing file
  const handleDownloadFile = useCallback(() => {
    if (!viewingFile) return;

    try {
      const fullPath = currentSubPath
        ? `${basePath}/${currentSubPath}/${viewingFile.path}`
        : `${basePath}/${viewingFile.path}`;

      const downloadUrl = `/api/projects/${encodeURIComponent(projectName)}/agentic-sessions/${encodeURIComponent(sessionName)}/workspace/${encodeURIComponent(fullPath)}`;

      // Create a hidden link and click it to trigger download
      const link = document.createElement('a');
      link.href = downloadUrl;
      link.download = viewingFile.path;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

      successToast(`Downloading ${viewingFile.path}...`);
    } catch (err) {
      errorToast(err instanceof Error ? err.message : "Failed to download file");
    }
  }, [viewingFile, currentSubPath, basePath, projectName, sessionName]);

  // Navigate back to parent folder
  const navigateBack = useCallback(() => {
    if (viewingFile) {
      // Go back to file tree
      setViewingFile(null);
    } else if (currentSubPath) {
      // Go back to parent folder
      const pathParts = currentSubPath.split('/');
      pathParts.pop();
      setCurrentSubPath(pathParts.join('/'));
    }
  }, [viewingFile, currentSubPath]);

  // Reset to root
  const resetToRoot = useCallback(() => {
    setCurrentSubPath("");
    setViewingFile(null);
  }, []);

  return {
    currentSubPath,
    viewingFile,
    loadingFile,
    handleFileOrFolderSelect,
    handleDownloadFile,
    navigateBack,
    resetToRoot,
    setCurrentSubPath,
    setViewingFile,
  };
}
</file>

<file path="components/frontend/src/app/projects/[name]/sessions/[sessionName]/hooks/use-git-operations.ts">
"use client";

import { useState, useCallback } from "react";
import { 
  useGitPull, 
  useGitPush, 
  useGitStatus,
  useConfigureGitRemote,
  useSynchronizeGit 
} from "@/services/queries/use-workspace";
import { successToast, errorToast } from "@/hooks/use-toast";

type UseGitOperationsProps = {
  projectName: string;
  sessionName: string;
  directoryPath: string;
  remoteBranch?: string;
};

export function useGitOperations({
  projectName,
  sessionName,
  directoryPath,
  remoteBranch = "main",
}: UseGitOperationsProps) {
  const [synchronizing, setSynchronizing] = useState(false);
  
  const gitPullMutation = useGitPull();
  const gitPushMutation = useGitPush();
  const configureRemoteMutation = useConfigureGitRemote();
  const synchronizeGitMutation = useSynchronizeGit();
  
  // Use React Query for git status
  const { data: gitStatus, refetch: fetchGitStatus } = useGitStatus(
    projectName,
    sessionName,
    directoryPath,
    { enabled: !!projectName && !!sessionName && !!directoryPath }
  );

  // Configure remote for the directory
  const configureRemote = useCallback(async (remoteUrl: string, branch: string) => {
    try {
      await configureRemoteMutation.mutateAsync({
        projectName,
        sessionName,
        path: directoryPath,
        remoteUrl: remoteUrl.trim(),
        branch: branch.trim() || "main",
      });
      
      successToast("Remote configured successfully");
      await fetchGitStatus();
      
      return true;
    } catch (error) {
      console.error("Failed to configure remote:", error);
      errorToast(error instanceof Error ? error.message : "Failed to configure remote");
      return false;
    }
  }, [projectName, sessionName, directoryPath, configureRemoteMutation, fetchGitStatus]);

  // Pull changes from remote
  const handleGitPull = useCallback((onSuccess?: () => void) => {
    gitPullMutation.mutate(
      {
        projectName,
        sessionName,
        path: directoryPath,
        branch: remoteBranch,
      },
      {
        onSuccess: () => {
          successToast("Changes pulled successfully");
          fetchGitStatus();
          onSuccess?.();
        },
        onError: (err) => errorToast(err instanceof Error ? err.message : "Failed to pull changes"),
      }
    );
  }, [gitPullMutation, projectName, sessionName, directoryPath, remoteBranch, fetchGitStatus]);

  // Push changes to remote
  const handleGitPush = useCallback((onSuccess?: () => void) => {
    const timestamp = new Date().toISOString();
    const message = `Workflow progress - ${timestamp}`;
    
    gitPushMutation.mutate(
      {
        projectName,
        sessionName,
        path: directoryPath,
        branch: remoteBranch,
        message,
      },
      {
        onSuccess: () => {
          successToast("Changes pushed successfully");
          fetchGitStatus();
          onSuccess?.();
        },
        onError: (err) => errorToast(err instanceof Error ? err.message : "Failed to push changes"),
      }
    );
  }, [gitPushMutation, projectName, sessionName, directoryPath, remoteBranch, fetchGitStatus]);

  // Synchronize: pull then push
  const handleGitSynchronize = useCallback(async (onSuccess?: () => void) => {
    try {
      setSynchronizing(true);
      
      // Pull first
      await gitPullMutation.mutateAsync({
        projectName,
        sessionName,
        path: directoryPath,
        branch: remoteBranch,
      });
      
      // Then push
      const timestamp = new Date().toISOString();
      const message = `Workflow progress - ${timestamp}`;
      
      await gitPushMutation.mutateAsync({
        projectName,
        sessionName,
        path: directoryPath,
        branch: remoteBranch,
        message,
      });
      
      successToast("Changes synchronized successfully");
      fetchGitStatus();
      onSuccess?.();
    } catch (error) {
      errorToast(error instanceof Error ? error.message : "Failed to synchronize");
    } finally {
      setSynchronizing(false);
    }
  }, [gitPullMutation, gitPushMutation, projectName, sessionName, directoryPath, remoteBranch, fetchGitStatus]);

  // Commit changes without pushing
  const handleCommit = useCallback(async (commitMessage: string) => {
    if (!commitMessage.trim()) {
      errorToast("Commit message is required");
      return false;
    }

    try {
      await synchronizeGitMutation.mutateAsync({
        projectName,
        sessionName,
        path: directoryPath,
        message: commitMessage.trim(),
        branch: remoteBranch,
      });

      successToast('Changes committed successfully');
      fetchGitStatus();
      return true;
    } catch (error) {
      console.error("Failed to commit:", error);
      errorToast(error instanceof Error ? error.message : 'Failed to commit');
      return false;
    }
  }, [projectName, sessionName, directoryPath, remoteBranch, synchronizeGitMutation, fetchGitStatus]);

  return {
    gitStatus,
    synchronizing,
    committing: synchronizeGitMutation.isPending,
    fetchGitStatus,
    configureRemote,
    handleGitPull,
    handleGitPush,
    handleGitSynchronize,
    handleCommit,
    isPulling: gitPullMutation.isPending,
    isPushing: gitPushMutation.isPending,
    isConfiguringRemote: configureRemoteMutation.isPending,
  };
}
</file>

<file path="components/frontend/src/app/projects/[name]/sessions/[sessionName]/hooks/use-workflow-management.ts">
"use client";

import { useState, useCallback } from "react";
import { successToast, errorToast } from "@/hooks/use-toast";
import type { WorkflowConfig } from "../lib/types";

type UseWorkflowManagementProps = {
  projectName: string;
  sessionName: string;
  onWorkflowActivated?: () => void;
};

export function useWorkflowManagement({
  projectName,
  sessionName,
  onWorkflowActivated,
}: UseWorkflowManagementProps) {
  const [selectedWorkflow, setSelectedWorkflow] = useState<string>("none");
  const [pendingWorkflow, setPendingWorkflow] = useState<WorkflowConfig | null>(null);
  const [activeWorkflow, setActiveWorkflow] = useState<string | null>(null);
  const [workflowActivating, setWorkflowActivating] = useState(false);

  // Set pending workflow (user selected but not yet activated)
  const setPending = useCallback((workflow: WorkflowConfig | null) => {
    setPendingWorkflow(workflow);
  }, []);

  // Activate the pending workflow
  const activateWorkflow = useCallback(async () => {
    if (!pendingWorkflow) return false;
    
    setWorkflowActivating(true);
    
    try {
      // 1. Update CR with workflow configuration
      const response = await fetch(`/api/projects/${projectName}/agentic-sessions/${sessionName}/workflow`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          gitUrl: pendingWorkflow.gitUrl,
          branch: pendingWorkflow.branch,
          path: pendingWorkflow.path || "",
        }),
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Failed to update workflow");
      }
      
      // 2. Send WebSocket message to trigger workflow clone and restart
      await fetch(`/api/projects/${projectName}/agentic-sessions/${sessionName}/messages`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          type: "workflow_change",
          gitUrl: pendingWorkflow.gitUrl,
          branch: pendingWorkflow.branch,
          path: pendingWorkflow.path || "",
        }),
      });
      
      successToast(`Activating workflow: ${pendingWorkflow.name}`);
      setActiveWorkflow(pendingWorkflow.id);
      setPendingWorkflow(null);
      
      // Wait for restart to complete (give runner time to clone and restart)
      await new Promise(resolve => setTimeout(resolve, 3000));
      
      onWorkflowActivated?.();
      successToast("Workflow activated successfully");
      
      return true;
    } catch (error) {
      console.error("Failed to activate workflow:", error);
      errorToast(error instanceof Error ? error.message : "Failed to activate workflow");
      return false;
    } finally {
      setWorkflowActivating(false);
    }
  }, [pendingWorkflow, projectName, sessionName, onWorkflowActivated]);

  // Handle workflow selection change
  const handleWorkflowChange = useCallback((value: string, ootbWorkflows: WorkflowConfig[], onCustom: () => void) => {
    setSelectedWorkflow(value);
    
    if (value === "none") {
      setPendingWorkflow(null);
      return;
    }
    
    if (value === "custom") {
      onCustom();
      return;
    }
    
    // Find the selected workflow from OOTB workflows
    const workflow = ootbWorkflows.find(w => w.id === value);
    if (!workflow) {
      errorToast(`Workflow ${value} not found`);
      return;
    }
    
    if (!workflow.enabled) {
      errorToast(`Workflow ${workflow.name} is not yet available`);
      return;
    }
    
    // Set as pending (user must click Activate)
    setPendingWorkflow(workflow);
  }, []);

  // Set custom workflow as pending
  const setCustomWorkflow = useCallback((url: string, branch: string, path: string) => {
    setPendingWorkflow({
      id: "custom",
      name: "Custom workflow",
      description: `Custom workflow from ${url}`,
      gitUrl: url,
      branch: branch || "main",
      path: path || "",
      enabled: true,
    });
    setSelectedWorkflow("custom");
  }, []);

  return {
    selectedWorkflow,
    setSelectedWorkflow,
    pendingWorkflow,
    setPending,
    activeWorkflow,
    setActiveWorkflow,
    workflowActivating,
    activateWorkflow,
    handleWorkflowChange,
    setCustomWorkflow,
  };
}
</file>

<file path="components/frontend/src/app/projects/[name]/sessions/[sessionName]/lib/message-adapter.ts">
import type { SessionMessage } from "@/types";
import type { MessageObject, ToolUseMessages } from "@/types/agentic-session";
import type { RawWireMessage, InnerEnvelope, ToolUseBlockWithTimestamp, ToolResultBlockWithTimestamp } from "./types";

/**
 * Converts raw wire messages from the backend into structured MessageObject and ToolUseMessages
 * for display in the UI. This handles all the complex message parsing and transformation logic.
 */
export function adaptSessionMessages(
  messages: SessionMessage[],
  isInteractive: boolean = false
): Array<MessageObject | ToolUseMessages> {
  try {
    const toolUseBlocks: ToolUseBlockWithTimestamp[] = [];
    const toolResultBlocks: ToolResultBlockWithTimestamp[] = [];
    const agenticMessages: MessageObject[] = [];

  for (const raw of messages as RawWireMessage[]) {
    const envelope: InnerEnvelope = ((raw?.payload as InnerEnvelope) ?? (raw as unknown as InnerEnvelope)) || {};
    const innerType: string = (raw as unknown as InnerEnvelope)?.type || envelope.type || "";
    const innerTs: string = raw?.timestamp || envelope.timestamp || new Date().toISOString();
    const payloadValue = envelope.payload;
    const innerPayload: Record<string, unknown> = (payloadValue && typeof payloadValue === 'object' && !Array.isArray(payloadValue))
      ? (payloadValue as Record<string, unknown>)
      : ((typeof envelope === 'object' ? (envelope as unknown as Record<string, unknown>) : {}) as Record<string, unknown>);
    const partial = (envelope.partial as InnerEnvelope["partial"]) || ((raw as unknown as { partial?: InnerEnvelope["partial"] })?.partial) || undefined;

    switch (innerType) {
      case "message.partial": {
        const text = partial?.data || "";
        if (text) {
          agenticMessages.push({
            type: "agent_message",
            content: { type: "text_block", text },
            model: "claude",
            timestamp: innerTs,
          });
        }
        break;
      }
      case "agent.message": {
        if (partial?.data) {
          const text = String(partial.data || "");
          if (text) {
            agenticMessages.push({
              type: "agent_message",
              content: { type: "text_block", text },
              model: "claude",
              timestamp: innerTs,
            });
            break;
          }
        }

        const toolName = (innerPayload?.tool as string | undefined);
        const toolInput = (innerPayload?.input as Record<string, unknown> | undefined) || {};
        const providedId = (innerPayload?.id as string | undefined);
        const result = innerPayload?.tool_result as unknown as { tool_use_id?: string; content?: unknown; is_error?: boolean } | undefined;
        
        if (toolName) {
          const id = providedId ? String(providedId) : String(envelope?.seq ?? `${toolName}-${toolUseBlocks.length}`);
          toolUseBlocks.push({
            block: { type: "tool_use_block", id, name: toolName, input: toolInput },
            timestamp: innerTs,
          });
        } else if (result?.tool_use_id) {
          toolResultBlocks.push({
            block: {
              type: "tool_result_block",
              tool_use_id: String(result.tool_use_id),
              content: (result.content as string | Array<Record<string, unknown>> | null | undefined) ?? null,
              is_error: Boolean(result.is_error),
            },
            timestamp: innerTs,
          });
        } else if ((innerPayload as Record<string, unknown>)?.type === 'result.message') {
          let rp: Record<string, unknown> = (innerPayload.payload as Record<string, unknown>) || {};
          if (rp && typeof rp === 'object' && 'payload' in rp && rp.payload && typeof rp.payload === 'object') {
            rp = rp.payload as Record<string, unknown>;
          }
          agenticMessages.push({
            type: "result_message",
            subtype: String(rp.subtype || ""),
            duration_ms: Number(rp.duration_ms || 0),
            duration_api_ms: Number(rp.duration_api_ms || 0),
            is_error: Boolean(rp.is_error || false),
            num_turns: Number(rp.num_turns || 0),
            session_id: String(rp.session_id || ""),
            total_cost_usd: (typeof rp.total_cost_usd === 'number' ? rp.total_cost_usd : null),
            usage: (typeof rp.usage === 'object' && rp.usage ? rp.usage as Record<string, unknown> : null),
            result: (typeof rp.result === 'string' ? rp.result : null),
            timestamp: innerTs,
          });
          if (typeof rp.result === 'string' && rp.result.trim()) {
            agenticMessages.push({
              type: "agent_message",
              content: { type: "text_block", text: String(rp.result) },
              model: "claude",
              timestamp: innerTs,
            });
          }
        } else {
          const envelopePayload = envelope.payload;
          const contentText = (innerPayload.content as Record<string, unknown> | undefined)?.text;
          const messageText = innerPayload.message;
          const nestedContentText = (innerPayload.payload as Record<string, unknown> | undefined)?.content as Record<string, unknown> | undefined;
          const text = (typeof envelopePayload === 'string')
            ? String(envelopePayload)
            : (
                (typeof contentText === 'string' ? String(contentText) : undefined)
                || (typeof messageText === 'string' ? String(messageText) : undefined)
                || (typeof nestedContentText?.text === 'string' ? String(nestedContentText.text) : '')
              );
          if (text) {
            agenticMessages.push({
              type: "agent_message",
              content: { type: "text_block", text },
              model: "claude",
              timestamp: innerTs,
            });
          }
        }
        break;
      }
      case "system.message": {
        let text = "";
        let isDebug = false;
        
        // The envelope object might have message/payload at different levels
        // Try envelope.payload first, then fall back to envelope itself
        const envelopeObj = envelope as { message?: string; payload?: string | { message?: string; payload?: string; debug?: boolean }; debug?: boolean };
        
        // Check if envelope.payload is a string
        if (typeof envelopeObj.payload === 'string') {
          text = envelopeObj.payload;
        }
        // Check if envelope.payload is an object with message or payload
        else if (typeof envelopeObj.payload === 'object' && envelopeObj.payload !== null) {
          const payloadObj = envelopeObj.payload as { message?: string; payload?: string; debug?: boolean };
          text = payloadObj.message || (typeof payloadObj.payload === 'string' ? payloadObj.payload : "");
          isDebug = payloadObj.debug === true;
        }
        // Fall back to envelope.message directly
        else if (typeof envelopeObj.message === 'string') {
          text = envelopeObj.message;
        }
        
        if (envelopeObj.debug === true) {
          isDebug = true;
        }
        
        // Always create a system message - show the raw envelope if we couldn't extract text
        agenticMessages.push({
          type: "system_message",
          subtype: "system.message",
          data: { 
            message: text || `[system event: ${JSON.stringify(envelope)}]`,
            debug: isDebug 
          },
          timestamp: innerTs,
        });
        break;
      }
      case "user.message":
      case "user_message": {
        const text = (innerPayload?.content as string | undefined) || "";
        if (text) {
          agenticMessages.push({
            type: "user_message",
            content: { type: "text_block", text },
            timestamp: innerTs,
          });
        }
        break;
      }
      case "agent.running": {
        agenticMessages.push({ type: "agent_running", timestamp: innerTs });
        break;
      }
      case "agent.waiting": {
        agenticMessages.push({ type: "agent_waiting", timestamp: innerTs });
        break;
      }
      default: {
        agenticMessages.push({
          type: "system_message",
          subtype: innerType || "unknown",
          data: innerPayload || {},
          timestamp: innerTs,
        });
      }
    }
  }

  const toolUseMessages: ToolUseMessages[] = [];
  for (const tu of toolUseBlocks) {
    const match = toolResultBlocks.find((tr) => tr.block.tool_use_id === tu.block.id);
    if (match) {
      toolUseMessages.push({
        type: "tool_use_messages",
        timestamp: tu.timestamp,
        toolUseBlock: tu.block,
        resultBlock: match.block,
      });
    } else {
      toolUseMessages.push({
        type: "tool_use_messages",
        timestamp: tu.timestamp,
        toolUseBlock: tu.block,
        resultBlock: { type: "tool_result_block", tool_use_id: tu.block.id, content: null, is_error: false },
      });
    }
  }

    const all = [...agenticMessages, ...toolUseMessages];
    const sorted = all.sort((a, b) => {
      const at = new Date(a.timestamp || 0).getTime();
      const bt = new Date(b.timestamp || 0).getTime();
      return at - bt;
    });
    
    return isInteractive ? sorted.filter((m) => m.type !== "result_message") : sorted;
  } catch (error) {
    console.error('Failed to adapt session messages:', error);
    return []; // Return empty array on error
  }
}
</file>

<file path="components/frontend/src/app/projects/[name]/sessions/[sessionName]/lib/types.ts">
import type { SessionMessage } from "@/types";
import type { ToolUseBlock, ToolResultBlock } from "@/types/agentic-session";

export type RawWireMessage = SessionMessage & { payload?: unknown; timestamp?: string };

export type InnerEnvelope = {
  type?: string;
  timestamp?: string;
  payload?: Record<string, unknown> | string;
  partial?: { id: string; index: number; total: number; data: string };
  seq?: number;
};

export type ToolUseBlockWithTimestamp = {
  block: ToolUseBlock;
  timestamp: string;
};

export type ToolResultBlockWithTimestamp = {
  block: ToolResultBlock;
  timestamp: string;
};

export type GitStatus = {
  initialized: boolean;
  hasChanges: boolean;
  uncommittedFiles: number;
  filesAdded: number;
  filesRemoved: number;
  totalAdded: number;
  totalRemoved: number;
};

export type DirectoryOption = {
  type: 'artifacts' | 'repo' | 'workflow';
  name: string;
  path: string;
};

export type DirectoryRemote = {
  url: string;
  branch: string;
};

export type WorkflowConfig = {
  id: string;
  name: string;
  description: string;
  gitUrl: string;
  branch: string;
  path?: string;
  enabled: boolean;
};

export type WorkflowCommand = {
  id: string;
  name: string;
  slashCommand: string;
  description?: string;
  icon?: string;
};

export type WorkflowAgent = {
  id: string;
  name: string;
  description?: string;
};

export type WorkflowMetadata = {
  commands: Array<WorkflowCommand>;
  agents: Array<WorkflowAgent>;
};
</file>

<file path="components/frontend/src/app/projects/[name]/sessions/[sessionName]/error.tsx">
'use client';

import { useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { AlertCircle } from 'lucide-react';

export default function SessionDetailError({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    console.error('Session detail error:', error);
  }, [error]);

  return (
    <div className="container mx-auto p-6">
      <Card className="max-w-lg mx-auto mt-12">
        <CardHeader>
          <div className="flex items-center gap-2">
            <AlertCircle className="h-5 w-5 text-destructive" />
            <CardTitle>Failed to load session</CardTitle>
          </div>
          <CardDescription>
            {error.message || 'An unexpected error occurred while loading this session.'}
          </CardDescription>
        </CardHeader>
        <CardContent>
          <Button onClick={reset}>Try again</Button>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="components/frontend/src/app/projects/[name]/sessions/[sessionName]/loading.tsx">
import { DetailPageSkeleton } from '@/components/skeletons';

export default function SessionDetailLoading() {
  return <DetailPageSkeleton />;
}
</file>

<file path="components/frontend/src/app/projects/[name]/sessions/new/repository-list.tsx">
"use client";

import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Edit2, Plus, Trash2, ArrowRight } from "lucide-react";
import { EmptyState } from "@/components/empty-state";
import { FolderGit2 } from "lucide-react";

type Repo = {
  input: { url: string; branch: string };
  output?: { url: string; branch: string };
};

type RepositoryListProps = {
  repos: Repo[];
  mainRepoIndex: number;
  onAddRepo: () => void;
  onEditRepo: (index: number) => void;
  onRemoveRepo: (index: number) => void;
  onSetMainRepo: (index: number) => void;
};

export function RepositoryList({
  repos,
  mainRepoIndex,
  onAddRepo,
  onEditRepo,
  onRemoveRepo,
  onSetMainRepo,
}: RepositoryListProps) {
  if (!repos || repos.length === 0) {
    return (
      <div className="space-y-2">
        <div className="flex items-center justify-between">
          <label className="text-sm font-medium">Repositories</label>
          <Button type="button" variant="outline" size="sm" onClick={onAddRepo}>
            <Plus className="w-4 h-4 mr-1" />
            Add Repository
          </Button>
        </div>
        <EmptyState
          icon={FolderGit2}
          title="No repositories configured"
          description="Add at least one repository for Claude to work with."
          action={{
            label: "Add Your First Repository",
            onClick: onAddRepo,
          }}
        />
      </div>
    );
  }

  return (
    <div className="space-y-2">
      <div className="flex items-center justify-between">
        <label className="text-sm font-medium">Repositories</label>
        <Button type="button" variant="outline" size="sm" onClick={onAddRepo}>
          <Plus className="w-4 h-4 mr-1" />
          Add Repository
        </Button>
      </div>
      <div className="space-y-2">
        {repos.map((repo, idx) => (
          <div key={idx} className="border rounded p-3 space-y-2">
            <div className="flex items-start justify-between gap-2">
              <div className="flex-1 space-y-1">
                <div className="flex items-center gap-2">
                  <span className="text-sm font-medium">Input:</span>
                  <code className="text-xs bg-muted px-1.5 py-0.5 rounded">{repo.input.url}</code>
                  {repo.input.branch && (
                    <Badge variant="outline" className="text-xs">
                      {repo.input.branch}
                    </Badge>
                  )}
                </div>
                {repo.output?.url && (
                  <div className="flex items-center gap-2">
                    <span className="text-sm font-medium">Output:</span>
                    <ArrowRight className="w-3 h-3" />
                    <code className="text-xs bg-muted px-1.5 py-0.5 rounded">{repo.output.url}</code>
                    {repo.output.branch && (
                      <Badge variant="outline" className="text-xs">
                        {repo.output.branch || "auto"}
                      </Badge>
                    )}
                  </div>
                )}
              </div>
              <div className="flex items-center gap-1">
                {idx === mainRepoIndex && (
                  <Badge className="text-xs">Working Directory</Badge>
                )}
                {idx !== mainRepoIndex && (
                  <Button
                    type="button"
                    variant="ghost"
                    size="sm"
                    onClick={() => onSetMainRepo(idx)}
                    title="Set as working directory"
                  >
                    <span className="text-xs">Set as Working Directory</span>
                  </Button>
                )}
                <Button type="button" variant="ghost" size="sm" onClick={() => onEditRepo(idx)}>
                  <Edit2 className="w-4 h-4" />
                </Button>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => onRemoveRepo(idx)}
                  disabled={repos.length === 1}
                >
                  <Trash2 className="w-4 h-4" />
                </Button>
              </div>
            </div>
          </div>
        ))}
      </div>
      <p className="text-xs text-muted-foreground">
        The {repos[mainRepoIndex]?.input?.url || "selected"} repo is Claude&apos;s working directory. Other
        repos are available as add_dirs.
      </p>
    </div>
  );
}
</file>

<file path="components/frontend/src/app/projects/[name]/error.tsx">
'use client';

import { useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { AlertCircle } from 'lucide-react';

export default function ProjectError({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    console.error('Project page error:', error);
  }, [error]);

  return (
    <div className="container mx-auto p-6">
      <Card className="max-w-lg mx-auto mt-12">
        <CardHeader>
          <div className="flex items-center gap-2">
            <AlertCircle className="h-5 w-5 text-destructive" />
            <CardTitle>Failed to load project</CardTitle>
          </div>
          <CardDescription>
            {error.message || 'An unexpected error occurred while loading this project.'}
          </CardDescription>
        </CardHeader>
        <CardContent>
          <Button onClick={reset}>Try again</Button>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="components/frontend/src/app/projects/[name]/loading.tsx">
import { DetailPageSkeleton } from '@/components/skeletons';

export default function ProjectDetailLoading() {
  return <DetailPageSkeleton />;
}
</file>

<file path="components/frontend/src/app/projects/[name]/not-found.tsx">
import Link from 'next/link';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { FileQuestion } from 'lucide-react';

export default function ProjectNotFound() {
  return (
    <div className="container mx-auto p-6">
      <Card className="max-w-lg mx-auto mt-12">
        <CardHeader>
          <div className="flex items-center gap-2">
            <FileQuestion className="h-5 w-5 text-muted-foreground" />
            <CardTitle>Project not found</CardTitle>
          </div>
          <CardDescription>
            The project you&apos;re looking for doesn&apos;t exist or you don&apos;t have access to it.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <Link href="/projects">
            <Button>Back to projects</Button>
          </Link>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="components/frontend/src/app/projects/loading.tsx">
import { CardGridSkeleton } from '@/components/skeletons';

export default function ProjectsLoading() {
  return <CardGridSkeleton items={6} />;
}
</file>

<file path="components/frontend/src/app/error.tsx">
'use client';

import { useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { AlertCircle } from 'lucide-react';

export default function RootError({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    console.error('Root error:', error);
  }, [error]);

  return (
    <div className="container mx-auto p-6 flex items-center justify-center min-h-screen">
      <Card className="max-w-md">
        <CardHeader>
          <div className="flex items-center gap-2">
            <AlertCircle className="h-5 w-5 text-destructive" />
            <CardTitle>Something went wrong</CardTitle>
          </div>
          <CardDescription>
            {error.message || 'An unexpected error occurred'}
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          {error.digest && (
            <p className="text-sm text-muted-foreground">
              Error ID: {error.digest}
            </p>
          )}
          <Button onClick={reset} className="w-full">
            Try again
          </Button>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="components/frontend/src/app/page.tsx">
"use client";

import { useEffect } from "react";
import { useRouter } from "next/navigation";
import { Loader2 } from "lucide-react";

export default function HomeRedirect() {
  const router = useRouter();
  useEffect(() => {
    // Redirect to RFE workflows as the new main interface
    router.replace("/projects");
  }, [router]);

  return (
    <div className="container mx-auto py-8">
      <div className="flex items-center justify-center h-64">
        <div className="text-center">
          <Loader2 className="mx-auto h-8 w-8 animate-spin mb-4" />
          <p className="text-muted-foreground">Redirecting to Workspaces...</p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/frontend/src/components/layouts/page-container.tsx">
import * as React from 'react';
import { cn } from '@/lib/utils';

type PageContainerProps = {
  children: React.ReactNode;
  className?: string;
  maxWidth?: 'sm' | 'md' | 'lg' | 'xl' | '2xl' | 'full';
  padding?: 'none' | 'sm' | 'md' | 'lg';
};

const maxWidthClasses = {
  sm: 'max-w-screen-sm',
  md: 'max-w-screen-md',
  lg: 'max-w-screen-lg',
  xl: 'max-w-screen-xl',
  '2xl': 'max-w-screen-2xl',
  full: 'max-w-full',
};

const paddingClasses = {
  none: '',
  sm: 'p-4',
  md: 'p-6',
  lg: 'p-8',
};

export function PageContainer({
  children,
  className,
  maxWidth = 'xl',
  padding = 'md',
}: PageContainerProps) {
  return (
    <div
      className={cn(
        'mx-auto w-full',
        maxWidthClasses[maxWidth],
        paddingClasses[padding],
        className
      )}
    >
      {children}
    </div>
  );
}

type PageHeaderProps = {
  title: React.ReactNode;
  description?: React.ReactNode;
  actions?: React.ReactNode;
  className?: string;
};

export function PageHeader({
  title,
  description,
  actions,
  className,
}: PageHeaderProps) {
  return (
    <div className={cn('mb-6', className)}>
      <div className="flex items-start justify-between gap-4">
        <div className="flex-1 space-y-1">
          <h1 className="text-3xl font-bold tracking-tight">{title}</h1>
          {description ? (
            <p className="text-muted-foreground">{description}</p>
          ) : null}
        </div>
        {actions ? <div className="flex items-center gap-2">{actions}</div> : null}
      </div>
    </div>
  );
}

type PageSectionProps = {
  children: React.ReactNode;
  title?: string;
  description?: string;
  className?: string;
};

export function PageSection({
  children,
  title,
  description,
  className,
}: PageSectionProps) {
  return (
    <section className={cn('space-y-4', className)}>
      {title ? (
        <div className="space-y-1">
          <h2 className="text-xl font-semibold tracking-tight">{title}</h2>
          {description ? (
            <p className="text-sm text-muted-foreground">{description}</p>
          ) : null}
        </div>
      ) : null}
      {children}
    </section>
  );
}
</file>

<file path="components/frontend/src/components/layouts/sidebar-layout.tsx">
import * as React from 'react';
import { cn } from '@/lib/utils';

type SidebarLayoutProps = {
  sidebar: React.ReactNode;
  children: React.ReactNode;
  sidebarWidth?: string;
  className?: string;
};

export function SidebarLayout({
  sidebar,
  children,
  sidebarWidth = '16rem',
  className,
}: SidebarLayoutProps) {
  return (
    <div className={cn('flex min-h-screen', className)}>
      <aside
        className="hidden md:block border-r bg-muted/10"
        style={{ width: sidebarWidth }}
      >
        <div className="sticky top-0 h-screen overflow-y-auto">
          {sidebar}
        </div>
      </aside>
      <main className="flex-1">
        {children}
      </main>
    </div>
  );
}

type MobileSidebarProps = {
  sidebar: React.ReactNode;
  open: boolean;
  onOpenChange: (open: boolean) => void;
};

export function MobileSidebar({ sidebar, open, onOpenChange }: MobileSidebarProps) {
  React.useEffect(() => {
    if (open) {
      document.body.style.overflow = 'hidden';
    } else {
      document.body.style.overflow = '';
    }
    return () => {
      document.body.style.overflow = '';
    };
  }, [open]);

  if (!open) return null;

  return (
    <>
      <div
        className="fixed inset-0 z-40 bg-black/50 md:hidden"
        onClick={() => onOpenChange(false)}
      />
      <aside className="fixed inset-y-0 left-0 z-50 w-64 bg-background border-r md:hidden">
        <div className="h-full overflow-y-auto">
          {sidebar}
        </div>
      </aside>
    </>
  );
}
</file>

<file path="components/frontend/src/components/providers/query-provider.tsx">
'use client';

/**
 * React Query Provider
 * Wraps the app with QueryClientProvider for data fetching
 */

import { QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import { getQueryClient } from '@/lib/query-client';
import { useState } from 'react';

type QueryProviderProps = {
  children: React.ReactNode;
};

export function QueryProvider({ children }: QueryProviderProps) {
  // Create a client instance per request to avoid sharing state between users
  const [queryClient] = useState(() => getQueryClient());

  return (
    <QueryClientProvider client={queryClient}>
      {children}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}
</file>

<file path="components/frontend/src/components/ui/alert.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "bg-card text-card-foreground",
        destructive:
          "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90",
        info: "bg-blue-50 border-blue-200 text-blue-900 [&>svg]:text-blue-600 *:data-[slot=alert-description]:text-blue-800",
        warning: "bg-amber-50 border-amber-200 text-amber-900 [&>svg]:text-amber-600 *:data-[slot=alert-description]:text-amber-800",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Alert({
  className,
  variant,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof alertVariants>) {
  return (
    <div
      data-slot="alert"
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props}
    />
  )
}

function AlertTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-title"
      className={cn(
        "col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight",
        className
      )}
      {...props}
    />
  )
}

function AlertDescription({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-description"
      className={cn(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed",
        className
      )}
      {...props}
    />
  )
}

export { Alert, AlertTitle, AlertDescription }
</file>

<file path="components/frontend/src/components/ui/button.tsx">
"use client";

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }
</file>

<file path="components/frontend/src/components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-2 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}
</file>

<file path="components/frontend/src/components/ui/input.tsx">
"use client";

import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }
</file>

<file path="components/frontend/src/components/ui/popover.tsx">
"use client"

import * as React from "react"
import { cn } from "@/lib/utils"

interface PopoverContextType {
  open: boolean
  setOpen: (open: boolean) => void
}

const PopoverContext = React.createContext<PopoverContextType | undefined>(undefined)

function usePopoverContext() {
  const context = React.useContext(PopoverContext)
  if (!context) {
    throw new Error("Popover components must be used within Popover")
  }
  return context
}

interface PopoverProps {
  children: React.ReactNode
  open?: boolean
  onOpenChange?: (open: boolean) => void
}

export function Popover({ children, open: controlledOpen, onOpenChange }: PopoverProps) {
  const [uncontrolledOpen, setUncontrolledOpen] = React.useState(false)
  
  const open = controlledOpen !== undefined ? controlledOpen : uncontrolledOpen
  const setOpen = onOpenChange || setUncontrolledOpen

  return (
    <PopoverContext.Provider value={{ open, setOpen }}>
      <div className="relative inline-block">
        {children}
      </div>
    </PopoverContext.Provider>
  )
}

interface PopoverTriggerProps {
  children: React.ReactNode
  asChild?: boolean
  className?: string
}

export function PopoverTrigger({ children, asChild, className }: PopoverTriggerProps) {
  const { open, setOpen } = usePopoverContext()

  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation()
    setOpen(!open)
  }

  if (asChild && React.isValidElement(children)) {
    return React.cloneElement(children as React.ReactElement<React.HTMLAttributes<HTMLElement>>, {
      onClick: handleClick,
      className: cn((children as React.ReactElement<React.HTMLAttributes<HTMLElement>>).props?.className, className),
    })
  }

  return (
    <button onClick={handleClick} className={className}>
      {children}
    </button>
  )
}

interface PopoverContentProps {
  children: React.ReactNode
  className?: string
  align?: "start" | "center" | "end"
  side?: "top" | "right" | "bottom" | "left"
}

export function PopoverContent({ 
  children, 
  className, 
  align = "center",
  side = "bottom" 
}: PopoverContentProps) {
  const { open, setOpen } = usePopoverContext()
  const contentRef = React.useRef<HTMLDivElement>(null)

  React.useEffect(() => {
    if (!open) return

    const handleClickOutside = (e: MouseEvent) => {
      if (contentRef.current && !contentRef.current.contains(e.target as Node)) {
        setOpen(false)
      }
    }

    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === "Escape") {
        setOpen(false)
      }
    }

    document.addEventListener("mousedown", handleClickOutside)
    document.addEventListener("keydown", handleEscape)

    return () => {
      document.removeEventListener("mousedown", handleClickOutside)
      document.removeEventListener("keydown", handleEscape)
    }
  }, [open, setOpen])

  if (!open) return null

  const alignmentClasses = {
    start: "left-0",
    center: "left-1/2 -translate-x-1/2",
    end: "right-0",
  }

  const sideClasses = {
    top: "bottom-full mb-2",
    right: "left-full ml-2 top-0",
    bottom: "top-full mt-2",
    left: "right-full mr-2 top-0",
  }

  return (
    <div
      ref={contentRef}
      className={cn(
        "absolute z-50 min-w-[200px] rounded-md border bg-popover p-3 text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95",
        sideClasses[side],
        alignmentClasses[align],
        className
      )}
    >
      {children}
    </div>
  )
}
</file>

<file path="components/frontend/src/components/ui/separator.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<"div"> & {
  orientation?: "horizontal" | "vertical"
  decorative?: boolean
}) {
  return (
    <div
      role={decorative ? "none" : "separator"}
      aria-orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full my-4" : "h-full w-[1px] mx-4",
        className
      )}
      {...props}
    />
  )
}

export { Separator }
</file>

<file path="components/frontend/src/components/ui/skeleton.tsx">
import { cn } from "@/lib/utils";

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  );
}

export { Skeleton };
</file>

<file path="components/frontend/src/components/ui/table.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn("w-full caption-bottom text-sm", className)}
        {...props}
      />
    </div>
  )
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("[&_tr]:border-b", className)}
      {...props}
    />
  )
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("[&_tr:last-child]:border-0", className)}
      {...props}
    />
  )
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
        className
      )}
      {...props}
    />
  )
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        className
      )}
      {...props}
    />
  )
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        "text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCaption({
  className,
  ...props
}: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("text-muted-foreground mt-4 text-sm", className)}
      {...props}
    />
  )
}

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
</file>

<file path="components/frontend/src/components/ui/textarea.tsx">
"use client";

import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }
</file>

<file path="components/frontend/src/components/ui/thinking-message.tsx">
"use client";

import React, { useState } from "react";
import { cn } from "@/lib/utils";
import { Badge } from "@/components/ui/badge";
import { Loader2, Brain } from "lucide-react";
import type { ThinkingBlock } from "@/types/agentic-session";

export type ThinkingMessageProps = {
  block: ThinkingBlock;
  className?: string;
};

export const ThinkingMessage: React.FC<ThinkingMessageProps> = ({ block, className }) => {
  const [expanded, setExpanded] = useState(false);

  return (
    <div className={cn("mb-4", className)}>
      <div className="flex items-start space-x-3">
        <div className="flex-shrink-0">
          <div className="w-8 h-8 rounded-full flex items-center justify-center bg-yellow-500">
            <Brain className="w-4 h-4 text-white" />
          </div>
        </div>

        <div className="flex-1 min-w-0">
          <div className="bg-white rounded-lg border shadow-sm p-3">
            <div className="flex items-center justify-between mb-2">
              <Badge variant="outline" className="text-xs">Thinking</Badge>
              <button
                className="text-xs text-blue-600 hover:underline"
                onClick={() => setExpanded((e) => !e)}
              >
                {expanded ? "Hide" : "Show"} details
              </button>
            </div>

            {!expanded && (
              <div className="flex items-center text-gray-600 text-xs">
                <Loader2 className="w-3 h-3 mr-2 animate-spin" /> Hidden reasoning available
              </div>
            )}

            {expanded && (
              <div className="space-y-3">
                  <div className="text-xs">
                    <div className="mb-1 text-gray-600">
                      <span className="font-semibold">Signature:</span> {block.signature}
                    </div>
                    <pre className="bg-gray-50 border rounded p-2 whitespace-pre-wrap break-words text-gray-800">
                      {block.thinking}
                    </pre>
                  </div>
                
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
};

export default ThinkingMessage;
</file>

<file path="components/frontend/src/components/ui/toaster.tsx">
"use client"

import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"
import { useToast } from "@/hooks/use-toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}
</file>

<file path="components/frontend/src/components/ui/tooltip.tsx">
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
</file>

<file path="components/frontend/src/components/workspace-sections/index.ts">
export { SessionsSection } from './sessions-section';
export { SharingSection } from './sharing-section';
export { SettingsSection } from './settings-section';
</file>

<file path="components/frontend/src/components/workspace-sections/sharing-section.tsx">
'use client';

import { useCallback, useMemo, useState } from 'react';
import { Eye, Edit, Shield, Users, User as UserIcon, Plus, RefreshCw, Loader2, Trash2, Info } from 'lucide-react';

import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Tabs, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { DestructiveConfirmationDialog } from '@/components/confirmation-dialog';

import { useProjectPermissions, useAddProjectPermission, useRemoveProjectPermission } from '@/services/queries';
import { successToast, errorToast } from '@/hooks/use-toast';
import type { PermissionRole, SubjectType } from '@/types/project';

const ROLE_DEFINITIONS = {
  view: {
    label: 'View',
    description: 'Can see sessions and duplicate to their own workspace',
    permissions: ['sessions:read', 'sessions:duplicate'] as const,
    color: 'bg-blue-100 text-blue-800',
    icon: Eye,
  },
  edit: {
    label: 'Edit',
    description: 'Can create sessions in the workspace',
    permissions: ['sessions:read', 'sessions:create', 'sessions:duplicate'] as const,
    color: 'bg-green-100 text-green-800',
    icon: Edit,
  },
  admin: {
    label: 'Admin',
    description: 'Full workspace management access',
    permissions: ['*'] as const,
    color: 'bg-purple-100 text-purple-800',
    icon: Shield,
  },
} as const;

type GrantPermissionForm = {
  subjectType: SubjectType;
  subjectName: string;
  role: PermissionRole;
};

type SharingSectionProps = {
  projectName: string;
};

export function SharingSection({ projectName }: SharingSectionProps) {
  const { data: permissions = [], isLoading, refetch } = useProjectPermissions(projectName);
  const addPermissionMutation = useAddProjectPermission();
  const removePermissionMutation = useRemoveProjectPermission();

  const [showGrantDialog, setShowGrantDialog] = useState(false);
  const [grantForm, setGrantForm] = useState<GrantPermissionForm>({
    subjectType: 'group',
    subjectName: '',
    role: 'view',
  });
  const [grantError, setGrantError] = useState<string | null>(null);
  const userRole: PermissionRole | undefined = undefined;

  const [showRevokeDialog, setShowRevokeDialog] = useState(false);
  const [toRevoke, setToRevoke] = useState<{ subjectType: SubjectType; subjectName: string; role: PermissionRole } | null>(null);

  const isAdmin = userRole === 'admin' || userRole === undefined;

  const handleGrant = useCallback(() => {
    if (!grantForm.subjectName.trim()) {
      setGrantError(`${grantForm.subjectType === 'group' ? 'Group' : 'User'} name is required`);
      return;
    }

    const key = `${grantForm.subjectType}:${grantForm.subjectName}`.toLowerCase();
    if (permissions.some((i) => `${i.subjectType}:${i.subjectName}`.toLowerCase() === key)) {
      setGrantError('This subject already has access to the workspace');
      return;
    }

    setGrantError(null);
    addPermissionMutation.mutate(
      {
        projectName,
        permission: {
          subjectType: grantForm.subjectType,
          subjectName: grantForm.subjectName,
          role: grantForm.role,
        },
      },
      {
        onSuccess: () => {
          successToast(`Permission granted to ${grantForm.subjectName} successfully`);
          setShowGrantDialog(false);
          setGrantForm({ subjectType: 'group', subjectName: '', role: 'view' });
        },
        onError: (error) => {
          const message = error instanceof Error ? error.message : 'Failed to grant permission';
          setGrantError(message);
          errorToast(message);
        },
      }
    );
  }, [grantForm, permissions, projectName, addPermissionMutation]);

  const handleRevoke = useCallback(() => {
    if (!toRevoke) return;

    removePermissionMutation.mutate(
      {
        projectName,
        subjectType: toRevoke.subjectType,
        subjectName: toRevoke.subjectName,
      },
      {
        onSuccess: () => {
          successToast(`Permission revoked from ${toRevoke.subjectName} successfully`);
          setShowRevokeDialog(false);
          setToRevoke(null);
        },
        onError: (error) => {
          errorToast(error instanceof Error ? error.message : 'Failed to revoke permission');
        },
      }
    );
  }, [toRevoke, projectName, removePermissionMutation]);

  const emptyState = useMemo(
    () => (
      <div className="text-center py-8">
        <Users className="w-8 h-8 text-muted-foreground mx-auto mb-2" />
        <p className="text-sm text-muted-foreground mb-4">No users or groups have access yet</p>
        {isAdmin && (
          <Button onClick={() => setShowGrantDialog(true)} size="sm">
            <Plus className="w-4 h-4 mr-2" />
            Grant First Permission
          </Button>
        )}
      </div>
    ),
    [isAdmin]
  );

  return (
    <>
      {!isAdmin && (
        <Card className="mb-6 border-blue-200 bg-blue-50">
          <CardContent className="pt-6 flex items-center gap-2">
            <Info className="w-4 h-4 text-blue-600" />
            <p className="text-blue-700">
              You have {userRole || 'view'} access. Only admins can grant or revoke permissions.
            </p>
          </CardContent>
        </Card>
      )}

      <Card className="flex-1">
        <CardHeader>
          <div className="flex items-start justify-between">
            <div>
              <CardTitle>
                Sharing
              </CardTitle>
              <CardDescription>Users and groups with access to this workspace and their roles</CardDescription>
            </div>
            <div className="flex gap-2">
              <Button variant="outline" onClick={() => refetch()} disabled={isLoading}>
                <RefreshCw className={`w-4 h-4 mr-2 ${isLoading ? 'animate-spin' : ''}`} />
                Refresh
              </Button>
              {isAdmin && (
                <Button onClick={() => setShowGrantDialog(true)}>
                  <Plus className="w-4 h-4 mr-2" />
                  Grant Permission
                </Button>
              )}
            </div>
          </div>
        </CardHeader>
        <CardContent>
          {permissions.length > 0 ? (
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Subject</TableHead>
                  <TableHead>Type</TableHead>
                  <TableHead>Role</TableHead>
                  {isAdmin && <TableHead className="text-right">Actions</TableHead>}
                </TableRow>
              </TableHeader>
              <TableBody>
                {permissions.map((p) => {
                  const roleConfig = ROLE_DEFINITIONS[p.role];
                  const RoleIcon = roleConfig.icon;
                  const isRevokingThis =
                    removePermissionMutation.isPending &&
                    removePermissionMutation.variables?.subjectName === p.subjectName &&
                    removePermissionMutation.variables?.subjectType === p.subjectType;

                  return (
                    <TableRow key={`${p.subjectType}:${p.subjectName}:${p.role}`}>
                      <TableCell className="font-medium">{p.subjectName}</TableCell>
                      <TableCell>
                        <div className="flex items-center gap-2 text-sm text-muted-foreground">
                          {p.subjectType === 'group' ? (
                            <Users className="w-3 h-3" />
                          ) : (
                            <UserIcon className="w-3 h-3" />
                          )}
                          {p.subjectType === 'group' ? 'Group' : 'User'}
                        </div>
                      </TableCell>
                      <TableCell>
                        <Badge className={roleConfig.color} style={{ cursor: 'default' }}>
                          <RoleIcon className="w-3 h-3 mr-1" />
                          {roleConfig.label}
                        </Badge>
                      </TableCell>

                      {isAdmin && (
                        <TableCell className="text-right">
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => {
                              setToRevoke(p);
                              setShowRevokeDialog(true);
                            }}
                            disabled={isRevokingThis}
                          >
                            {isRevokingThis ? (
                              <Loader2 className="w-4 h-4 animate-spin" />
                            ) : (
                              <Trash2 className="w-4 h-4" />
                            )}
                          </Button>
                        </TableCell>
                      )}
                    </TableRow>
                  );
                })}
              </TableBody>
            </Table>
          ) : (
            emptyState
          )}
        </CardContent>
      </Card>

      {/* Grant Permission Dialog */}
      <Dialog open={showGrantDialog} onOpenChange={setShowGrantDialog}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Grant Permission</DialogTitle>
            <DialogDescription>Add a user or group to this workspace with a role</DialogDescription>
          </DialogHeader>
          <div className="space-y-4">
            <div className="space-y-2">
              <Label>Subject Type</Label>
              <Tabs
                value={grantForm.subjectType}
                onValueChange={(value) => {
                  if (addPermissionMutation.isPending) return;
                  setGrantForm((prev) => ({ ...prev, subjectType: value as SubjectType }));
                }}
              >
                <TabsList className="grid grid-cols-2 w-full">
                  <TabsTrigger value="group">Group</TabsTrigger>
                  <TabsTrigger value="user">User</TabsTrigger>
                </TabsList>
              </Tabs>
            </div>
            <div className="space-y-2">
              <Label htmlFor="subjectName">
                {grantForm.subjectType === 'group' ? 'Group' : 'User'} Name
              </Label>
              <Input
                id="subjectName"
                placeholder={`Enter ${grantForm.subjectType} name`}
                value={grantForm.subjectName}
                onChange={(e) => setGrantForm((prev) => ({ ...prev, subjectName: e.target.value }))}
                disabled={addPermissionMutation.isPending}
              />
            </div>
            <div className="space-y-2">
              <Label>Role</Label>
              <div className="space-y-3">
                {Object.entries(ROLE_DEFINITIONS).map(([roleKey, roleConfig]) => {
                  const RoleIcon = roleConfig.icon;
                  const id = `role-${roleKey}`;
                  return (
                    <div key={roleKey} className="flex items-start gap-3">
                      <input
                        type="radio"
                        name="grant-role"
                        id={id}
                        className="mt-1 h-4 w-4"
                        value={roleKey}
                        checked={grantForm.role === (roleKey as PermissionRole)}
                        onChange={() => setGrantForm((prev) => ({ ...prev, role: roleKey as PermissionRole }))}
                        disabled={addPermissionMutation.isPending}
                      />
                      <Label htmlFor={id} className="flex-1 cursor-pointer">
                        <div className="flex items-center gap-2">
                          <RoleIcon className="w-4 h-4" />
                          <span className="font-medium">{roleConfig.label}</span>
                        </div>
                        <div className="text-sm text-muted-foreground ml-6">{roleConfig.description}</div>
                      </Label>
                    </div>
                  );
                })}
              </div>
            </div>
            {grantError && <div className="text-sm text-red-600 bg-red-50 p-2 rounded">{grantError}</div>}
          </div>
          <DialogFooter>
            <Button
              variant="outline"
              onClick={() => setShowGrantDialog(false)}
              disabled={addPermissionMutation.isPending}
            >
              Cancel
            </Button>
            <Button onClick={handleGrant} disabled={addPermissionMutation.isPending}>
              {addPermissionMutation.isPending ? (
                <>
                  <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                  Granting...
                </>
              ) : (
                <>
                  <Plus className="w-4 h-4 mr-2" />
                  Grant Permission
                </>
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Revoke Permission Dialog */}
      <DestructiveConfirmationDialog
        open={showRevokeDialog}
        onOpenChange={setShowRevokeDialog}
        onConfirm={handleRevoke}
        title="Revoke Permission"
        description={`Are you sure you want to revoke access for "${toRevoke?.subjectName}" (${toRevoke?.subjectType})? They will immediately lose access to this workspace.`}
        confirmText="Revoke"
        loading={removePermissionMutation.isPending}
      />
    </>
  );
}
</file>

<file path="components/frontend/src/components/confirmation-dialog.tsx">
"use client";

/**
 * Confirmation Dialog Component
 * Reusable dialog for confirming destructive actions
 */

import * as React from 'react';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Loader2, AlertTriangle } from 'lucide-react';
import { cn } from '@/lib/utils';

export type ConfirmationDialogProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onConfirm: () => void | Promise<void>;
  title: string;
  description: string;
  confirmText?: string;
  cancelText?: string;
  variant?: 'default' | 'destructive';
  loading?: boolean;
  icon?: React.ReactNode;
};

export function ConfirmationDialog({
  open,
  onOpenChange,
  onConfirm,
  title,
  description,
  confirmText = 'Confirm',
  cancelText = 'Cancel',
  variant = 'default',
  loading = false,
  icon,
}: ConfirmationDialogProps) {
  const handleConfirm = async () => {
    await onConfirm();
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          {icon && (
            <div className={cn('mb-2', variant === 'destructive' && 'text-destructive')}>{icon}</div>
          )}
          <DialogTitle>{title}</DialogTitle>
          <DialogDescription>{description}</DialogDescription>
        </DialogHeader>
        <DialogFooter>
          <Button variant="outline" onClick={() => onOpenChange(false)} disabled={loading}>
            {cancelText}
          </Button>
          <Button
            variant={variant === 'destructive' ? 'destructive' : 'default'}
            onClick={handleConfirm}
            disabled={loading}
          >
            {loading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
            {confirmText}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

/**
 * Destructive confirmation dialog with warning icon
 */
export function DestructiveConfirmationDialog(
  props: Omit<ConfirmationDialogProps, 'variant' | 'icon'>
) {
  return (
    <ConfirmationDialog
      {...props}
      variant="destructive"
      icon={<AlertTriangle className="h-6 w-6" />}
    />
  );
}
</file>

<file path="components/frontend/src/components/create-session-dialog.tsx">
"use client";

import { useState } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import { Loader2 } from "lucide-react";
import { useRouter } from "next/navigation";

import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Input } from "@/components/ui/input";
import { Checkbox } from "@/components/ui/checkbox";
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion";
import type { CreateAgenticSessionRequest } from "@/types/agentic-session";
import { useCreateSession } from "@/services/queries/use-sessions";
import { successToast, errorToast } from "@/hooks/use-toast";

const models = [
  { value: "claude-sonnet-4-5", label: "Claude Sonnet 4.5" },
  { value: "claude-opus-4-1", label: "Claude Opus 4.1" },
  { value: "claude-haiku-4-5", label: "Claude Haiku 4.5" },
];

const formSchema = z.object({
  model: z.string().min(1, "Please select a model"),
  temperature: z.number().min(0).max(2),
  maxTokens: z.number().min(100).max(8000),
  timeout: z.number().min(60).max(1800),
  anthropicApiKey: z.string().optional(),
  saveApiKeyForFuture: z.boolean(),
});

type FormValues = z.infer<typeof formSchema>;

type CreateSessionDialogProps = {
  projectName: string;
  trigger: React.ReactNode;
  onSuccess?: () => void;
};

export function CreateSessionDialog({
  projectName,
  trigger,
  onSuccess,
}: CreateSessionDialogProps) {
  const [open, setOpen] = useState(false);
  const router = useRouter();
  const createSessionMutation = useCreateSession();

  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      model: "claude-sonnet-4-5",
      temperature: 0.7,
      maxTokens: 4000,
      timeout: 300,
      anthropicApiKey: "",
      saveApiKeyForFuture: false,
    },
  });

  const onSubmit = async (values: FormValues) => {
    if (!projectName) return;

    const request: CreateAgenticSessionRequest = {
      interactive: true,
      prompt: "Greet the user and briefly explain the workspace capabilities: they can select workflows, add code repositories for context, use slash commands, and you'll help with software engineering tasks. Keep it friendly and concise.",
      llmSettings: {
        model: values.model,
        temperature: values.temperature,
        maxTokens: values.maxTokens,
      },
      timeout: values.timeout,
    };

    // Note: anthropicApiKey and saveApiKeyForFuture are form fields but not currently used by the backend
    // TODO: Add support for these fields if needed in the future

    createSessionMutation.mutate(
      { projectName, data: request },
      {
        onSuccess: (session) => {
          const sessionName = session.metadata.name;
          successToast(`Session "${sessionName}" created successfully`);
          setOpen(false);
          form.reset();
          router.push(`/projects/${encodeURIComponent(projectName)}/sessions/${sessionName}`);
          onSuccess?.();
        },
        onError: (error) => {
          errorToast(error.message || "Failed to create session");
        },
      }
    );
  };

  const handleOpenChange = (newOpen: boolean) => {
    setOpen(newOpen);
    if (!newOpen) {
      form.reset();
    }
  };

  const handleTriggerClick = () => {
    setOpen(true);
  };

  return (
    <>
      <div onClick={handleTriggerClick}>{trigger}</div>
      <Dialog open={open} onOpenChange={handleOpenChange}>
        <DialogContent className="w-full max-w-3xl min-w-[650px]">
          <DialogHeader>
            <DialogTitle>Create Session</DialogTitle>
          </DialogHeader>

          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Model Selection */}
              <FormField
                control={form.control}
                name="model"
                render={({ field }) => (
                  <FormItem className="w-full">
                    <FormLabel>Model</FormLabel>
                    <Select onValueChange={field.onChange} defaultValue={field.value}>
                      <FormControl>
                        <SelectTrigger className="w-full">
                          <SelectValue placeholder="Select a model" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        {models.map((m) => (
                          <SelectItem key={m.value} value={m.value}>
                            {m.label}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />

              {/* Advanced Settings Accordion */}
              <Accordion type="single" collapsible className="w-full">
                <AccordionItem value="advanced-settings" className="border rounded-md">
                  <AccordionTrigger className="px-4 py-3 hover:no-underline">
                    <span className="text-sm font-medium">Change Default Model Settings</span>
                  </AccordionTrigger>
                  <AccordionContent className="px-4 pb-4">
                    <div className="space-y-6 pt-4">
                      {/* Temperature and Timeout */}
                      <div className="grid grid-cols-2 gap-4">
                        <FormField
                          control={form.control}
                          name="temperature"
                          render={({ field }) => (
                            <FormItem>
                              <FormLabel>Temperature</FormLabel>
                              <FormControl>
                                <Input
                                  type="number"
                                  step="0.1"
                                  min="0"
                                  max="2"
                                  {...field}
                                  onChange={(e) => field.onChange(parseFloat(e.target.value))}
                                />
                              </FormControl>
                              <FormDescription>Controls randomness (0.0 - 2.0)</FormDescription>
                              <FormMessage />
                            </FormItem>
                          )}
                        />

                        <FormField
                          control={form.control}
                          name="timeout"
                          render={({ field }) => (
                            <FormItem>
                              <FormLabel>Timeout (seconds)</FormLabel>
                              <FormControl>
                                <Input
                                  type="number"
                                  step="60"
                                  min="60"
                                  max="1800"
                                  {...field}
                                  onChange={(e) => field.onChange(parseInt(e.target.value))}
                                />
                              </FormControl>
                              <FormDescription>Session timeout (60-1800 seconds)</FormDescription>
                              <FormMessage />
                            </FormItem>
                          )}
                        />
                      </div>

                      {/* Max Output Tokens */}
                      <FormField
                        control={form.control}
                        name="maxTokens"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Max Output Tokens</FormLabel>
                            <FormControl>
                              <Input
                                type="number"
                                step="100"
                                min="100"
                                max="8000"
                                {...field}
                                onChange={(e) => field.onChange(parseInt(e.target.value))}
                              />
                            </FormControl>
                            <FormDescription>Maximum response length (100-8000)</FormDescription>
                            <FormMessage />
                          </FormItem>
                        )}
                      />

                      {/* Bring Your Own Key Section */}
                      <div className="pt-4 border-t">
                        <FormField
                          control={form.control}
                          name="anthropicApiKey"
                          render={({ field }) => (
                            <FormItem>
                              <FormLabel>Bring Your Own Key</FormLabel>
                              <FormControl>
                                <Input
                                  type="password"
                                  placeholder="sk-ant-api03-..."
                                  {...field}
                                />
                              </FormControl>
                              <FormDescription>
                                Optional: Use your own Anthropic API key for this session
                              </FormDescription>
                              <FormMessage />
                            </FormItem>
                          )}
                        />

                        <FormField
                          control={form.control}
                          name="saveApiKeyForFuture"
                          render={({ field }) => (
                            <FormItem className="flex flex-row items-start space-x-3 space-y-0 mt-3">
                              <FormControl>
                                <Checkbox
                                  checked={field.value}
                                  onCheckedChange={field.onChange}
                                />
                              </FormControl>
                              <div className="space-y-1 leading-none">
                                <FormLabel className="text-sm font-normal">
                                  Save key for future sessions (encrypted)
                                </FormLabel>
                              </div>
                            </FormItem>
                          )}
                        />
                      </div>
                    </div>
                  </AccordionContent>
                </AccordionItem>
              </Accordion>

              <DialogFooter>
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setOpen(false)}
                  disabled={createSessionMutation.isPending}
                >
                  Cancel
                </Button>
                <Button type="submit" disabled={createSessionMutation.isPending}>
                  {createSessionMutation.isPending && (
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  )}
                  Create Session
                </Button>
              </DialogFooter>
            </form>
          </Form>
        </DialogContent>
      </Dialog>
    </>
  );
}
</file>

<file path="components/frontend/src/components/editable-session-name.tsx">
/**
 * EditableSessionName component
 * Allows inline editing of session display names with auto-edit mode for default names
 */

import { useState, useEffect, useRef } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { cn } from '@/lib/utils';
import { Loader2 } from 'lucide-react';

type EditableSessionNameProps = {
  currentName: string;
  onSave: (newName: string) => Promise<void>;
  isSaving?: boolean;
  className?: string;
};

export function EditableSessionName({
  currentName,
  onSave,
  isSaving = false,
  className,
}: EditableSessionNameProps) {
  const [isEditing, setIsEditing] = useState(false);
  const [inputValue, setInputValue] = useState(currentName);
  const [hasChanges, setHasChanges] = useState(false);
  const inputRef = useRef<HTMLInputElement>(null);

  // Focus input when entering edit mode
  useEffect(() => {
    if (isEditing && inputRef.current) {
      inputRef.current.focus();
      inputRef.current.select();
    }
  }, [isEditing]);

  // Update input value when currentName changes
  useEffect(() => {
    setInputValue(currentName);
    setHasChanges(false);
  }, [currentName]);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = e.target.value;
    setInputValue(newValue);
    setHasChanges(newValue.trim() !== currentName && newValue.trim() !== '');
  };

  const handleSave = async () => {
    const trimmedValue = inputValue.trim();
    if (!trimmedValue || trimmedValue === currentName) {
      setIsEditing(false);
      setInputValue(currentName);
      setHasChanges(false);
      return;
    }

    try {
      await onSave(trimmedValue);
      setIsEditing(false);
      setHasChanges(false);
    } catch (error) {
      // Error handling is done by the parent component via toast
      console.error('Failed to save session name:', error);
    }
  };

  const handleCancel = () => {
    setInputValue(currentName);
    setIsEditing(false);
    setHasChanges(false);
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      handleSave();
    } else if (e.key === 'Escape') {
      e.preventDefault();
      handleCancel();
    }
  };

  // If in edit mode, show input
  if (isEditing) {
    return (
      <div className="flex items-center gap-2">
        <Input
          ref={inputRef}
          type="text"
          value={inputValue}
          onChange={handleInputChange}
          onKeyDown={handleKeyDown}
          onBlur={() => {
            // Don't auto-close on blur if there are changes - user might want to click the Update button
            if (!hasChanges) {
              handleCancel();
            }
          }}
          placeholder="New session..."
          disabled={isSaving}
          className={cn('h-auto py-1 px-2 w-auto min-w-[300px] flex-1 !text-[1em] !font-[inherit] !leading-[inherit]', className)}
        />
        <Button
          onClick={handleSave}
          disabled={isSaving || !hasChanges}
          size="sm"
          className="whitespace-nowrap"
        >
          {isSaving ? (
            <>
              <Loader2 className="w-4 h-4 mr-2 animate-spin" />
              Saving...
            </>
          ) : (
            'Update'
          )}
        </Button>
      </div>
    );
  }

  // If not editing, show clickable title
  return (
    <h1
      className={cn(
        'cursor-pointer hover:text-primary transition-colors',
        className
      )}
      onClick={() => setIsEditing(true)}
      title="Click to edit session name"
    >
      {currentName}
    </h1>
  );
}
</file>

<file path="components/frontend/src/components/error-message.tsx">
"use client";

/**
 * ErrorMessage component
 * Displays error messages with optional retry action
 */

import { AlertCircle } from 'lucide-react';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { Button } from '@/components/ui/button';
import { ApiClientError } from '@/types/api';

type ErrorMessageProps = {
  error: Error | ApiClientError | unknown;
  title?: string;
  onRetry?: () => void;
};

export function ErrorMessage({ error, title = 'Error', onRetry }: ErrorMessageProps) {
  const message = error instanceof Error ? error.message : 'An unknown error occurred';

  const errorCode =
    error instanceof ApiClientError && error.code
      ? ` (${error.code})`
      : '';

  return (
    <Alert variant="destructive">
      <AlertCircle className="h-4 w-4" />
      <AlertTitle>{title}{errorCode}</AlertTitle>
      <AlertDescription className="mt-2 flex flex-col gap-2">
        <p>{message}</p>
        {onRetry && (
          <div>
            <Button
              variant="outline"
              size="sm"
              onClick={onRetry}
              className="mt-2"
            >
              Try Again
            </Button>
          </div>
        )}
      </AlertDescription>
    </Alert>
  );
}
</file>

<file path="components/frontend/src/components/file-tree.tsx">
"use client";

import { useState } from "react";
import { Folder, FolderOpen, FileText } from "lucide-react";

export type FileTreeNode = {
  name: string;
  path: string;
  type: "file" | "folder";
  children?: FileTreeNode[];
  expanded?: boolean;
  sizeKb?: number;
  data?: unknown;
};

export type FileTreeProps = {
  nodes: FileTreeNode[];
  selectedPath?: string;
  onSelect: (node: FileTreeNode) => void;
  onToggle?: (node: FileTreeNode) => Promise<void> | void;
  className?: string;
};

export function FileTree({ nodes, selectedPath, onSelect, onToggle, className }: FileTreeProps) {
  return (
    <div className={className}>
      {nodes.map((node) => (
        <FileTreeItem
          key={node.path}
          node={node}
          selectedPath={selectedPath}
          onSelect={onSelect}
          onToggle={onToggle}
        />
      ))}
    </div>
  );
}

type ItemProps = {
  node: FileTreeNode;
  selectedPath?: string;
  onSelect: (node: FileTreeNode) => void;
  onToggle?: (node: FileTreeNode) => Promise<void> | void;
  depth?: number;
};

function FileTreeItem({ node, selectedPath, onSelect, onToggle, depth = 0 }: ItemProps) {
  const [expanded, setExpanded] = useState<boolean>(node.expanded ?? true);
  const isSelected = node.path === selectedPath;

  return (
    <div>
      <div
        className={`flex items-center gap-2 px-2 py-1 text-sm rounded cursor-pointer hover:bg-muted ${
          isSelected ? "bg-muted" : ""
        }`}
        style={{ paddingLeft: `${(depth + 1) * 12}px` }}
        onClick={async () => {
          if (node.type === "folder") {
            // If folder has children, toggle expand/collapse
            if (node.children && node.children.length > 0) {
              const next = !expanded;
              setExpanded(next);
              if (next && onToggle) {
                await onToggle(node);
              }
            } else {
              // If folder has no children (flat listing), call onSelect to navigate
              onSelect(node);
            }
          } else {
            onSelect(node);
          }
        }}
      >
        {node.type === "folder" ? (
          expanded ? (
            <FolderOpen className="h-4 w-4 text-blue-600" />
          ) : (
            <Folder className="h-4 w-4 text-blue-600" />
          )
        ) : (
          <FileText className="h-4 w-4 text-gray-600" />
        )}

        <span className={`flex-1 ${isSelected ? "font-medium" : ""}`}>{node.name}</span>

        {typeof node.sizeKb === "number" && (
          <span className="text-xs text-muted-foreground">{node.sizeKb.toFixed(1)}K</span>
        )}
      </div>

      {node.type === "folder" && expanded && node.children && node.children.length > 0 && (
        <div>
          {node.children.map((child) => (
            <FileTreeItem
              key={child.path}
              node={child}
              selectedPath={selectedPath}
              onSelect={onSelect}
              onToggle={onToggle}
              depth={depth + 1}
            />
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="components/frontend/src/components/form-field-wrapper.tsx">
/**
 * Form Field Wrapper Component
 * Simplifies form field creation with consistent styling
 */

import * as React from 'react';
import { Label } from '@/components/ui/label';
import { cn } from '@/lib/utils';
import { AlertCircle, HelpCircle } from 'lucide-react';

export type FormFieldWrapperProps = {
  label: string;
  htmlFor?: string;
  required?: boolean;
  error?: string;
  help?: string;
  className?: string;
  children: React.ReactNode;
};

export function FormFieldWrapper({
  label,
  htmlFor,
  required = false,
  error,
  help,
  className,
  children,
}: FormFieldWrapperProps) {
  return (
    <div className={cn('space-y-2', className)}>
      <Label htmlFor={htmlFor} className="flex items-center gap-1">
        {label}
        {required && <span className="text-destructive">*</span>}
      </Label>
      {children}
      {help && !error && (
        <p className="text-sm text-muted-foreground flex items-center gap-1">
          <HelpCircle className="h-3 w-3" />
          {help}
        </p>
      )}
      {error && (
        <p className="text-sm text-destructive flex items-center gap-1">
          <AlertCircle className="h-3 w-3" />
          {error}
        </p>
      )}
    </div>
  );
}

/**
 * Grid layout for multiple form fields
 */
export type FormFieldsGridProps = {
  children: React.ReactNode;
  columns?: 1 | 2 | 3;
  className?: string;
};

export function FormFieldsGrid({ children, columns = 1, className }: FormFieldsGridProps) {
  const gridClass = {
    1: 'grid-cols-1',
    2: 'grid-cols-1 md:grid-cols-2',
    3: 'grid-cols-1 md:grid-cols-2 lg:grid-cols-3',
  }[columns];

  return <div className={cn('grid gap-4', gridClass, className)}>{children}</div>;
}

/**
 * Form section with title and description
 */
export type FormSectionProps = {
  title: string;
  description?: string;
  children: React.ReactNode;
  className?: string;
};

export function FormSection({ title, description, children, className }: FormSectionProps) {
  return (
    <div className={cn('space-y-4', className)}>
      <div className="space-y-1">
        <h3 className="text-lg font-medium">{title}</h3>
        {description && <p className="text-sm text-muted-foreground">{description}</p>}
      </div>
      {children}
    </div>
  );
}

/**
 * Form actions footer with consistent spacing
 */
export type FormActionsProps = {
  children: React.ReactNode;
  align?: 'left' | 'right' | 'center';
  className?: string;
};

export function FormActions({ children, align = 'right', className }: FormActionsProps) {
  const alignClass = {
    left: 'justify-start',
    right: 'justify-end',
    center: 'justify-center',
  }[align];

  return <div className={cn('flex gap-2 pt-4', alignClass, className)}>{children}</div>;
}
</file>

<file path="components/frontend/src/components/github-connection-card.tsx">
'use client'

import React from 'react'
import { Button } from '@/components/ui/button'
import { Card } from '@/components/ui/card'
import { useGitHubStatus, useDisconnectGitHub } from '@/services/queries'
import { successToast, errorToast } from '@/hooks/use-toast'

type Props = { 
  appSlug?: string
  showManageButton?: boolean
}

export function GitHubConnectionCard({ appSlug, showManageButton = true }: Props) {
  const { data: status, isLoading, refetch } = useGitHubStatus()
  const disconnectMutation = useDisconnectGitHub()

  const handleConnect = () => {
    if (!appSlug) return
    const setupUrl = new URL('/integrations/github/setup', window.location.origin)
    const redirectUri = encodeURIComponent(setupUrl.toString())
    const url = `https://github.com/apps/${appSlug}/installations/new?redirect_uri=${redirectUri}`
    window.location.href = url
  }

  const handleDisconnect = async () => {
    disconnectMutation.mutate(undefined, {
      onSuccess: () => {
        successToast('GitHub disconnected successfully')
        refetch()
      },
      onError: (error) => {
        errorToast(error instanceof Error ? error.message : 'Failed to disconnect GitHub')
      },
    })
  }

  const handleManage = () => {
    window.open('https://github.com/settings/installations', '_blank')
  }

  return (
    <Card className="bg-white border border-gray-200 shadow-sm">
      <div className="p-6">
        {/* Header section with icon and title */}
        <div className="flex items-start gap-4 mb-6">
          <div className="flex-shrink-0 w-16 h-16 bg-gray-900 rounded-lg flex items-center justify-center">
            <svg className="w-8 h-8 text-white" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true">
              <path fillRule="evenodd" d="M12 2C6.477 2 2 6.484 2 12.017c0 4.425 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483 0-.237-.008-.868-.013-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.272.098-2.65 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0112 6.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.379.202 2.398.1 2.651.64.7 1.028 1.595 1.028 2.688 0 3.848-2.339 4.695-4.566 4.943.359.309.678.92.678 1.855 0 1.338-.012 2.419-.012 2.747 0 .268.18.58.688.482A10.019 10.019 0 0022 12.017C22 6.484 17.522 2 12 2z" clipRule="evenodd" />
            </svg>
          </div>
          <div className="flex-1">
            <h3 className="text-xl font-semibold text-gray-900 mb-1">GitHub</h3>
            <p className="text-gray-600">Connect to GitHub repositories</p>
          </div>
        </div>

        {/* Status section */}
        <div className="mb-4">
          <div className="flex items-center gap-2 mb-2">
            <span className={`w-2 h-2 rounded-full ${status?.installed ? 'bg-green-500' : 'bg-gray-400'}`}></span>
            <span className="text-sm font-medium text-gray-700">
              {status?.installed ? (
                <>Connected{status.githubUserId ? ` as ${status.githubUserId}` : ''}</>
              ) : (
                'Not Connected'
              )}
            </span>
          </div>
          <p className="text-gray-600">
            Connect to GitHub to manage repositories and create pull requests
          </p>
        </div>

        {/* Action buttons */}
        <div className="flex gap-3">
          {status?.installed ? (
            <>
              {showManageButton && (
                <Button 
                  variant="outline" 
                  onClick={handleManage} 
                  disabled={isLoading || disconnectMutation.isPending}
                >
                  Manage in GitHub
                </Button>
              )}
              <Button 
                variant="destructive" 
                onClick={handleDisconnect} 
                disabled={isLoading || disconnectMutation.isPending}
              >
                Disconnect
              </Button>
            </>
          ) : (
            <Button 
              onClick={handleConnect} 
              disabled={isLoading || !appSlug}
              className="bg-blue-600 hover:bg-blue-700 text-white"
            >
              Connect GitHub
            </Button>
          )}
        </div>
      </div>
    </Card>
  )
}
</file>

<file path="components/frontend/src/components/loading-button.tsx">
/**
 * LoadingButton component
 * Button with loading state and spinner
 */

import * as React from 'react';
import { Loader2 } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';

type LoadingButtonProps = React.ComponentProps<typeof Button> & {
  loading?: boolean;
  loadingText?: string;
};

export function LoadingButton({
  loading = false,
  loadingText,
  children,
  disabled,
  className,
  ...props
}: LoadingButtonProps) {
  return (
    <Button
      disabled={loading || disabled}
      className={cn(className)}
      {...props}
    >
      {loading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
      {loading && loadingText ? loadingText : children}
    </Button>
  );
}
</file>

<file path="components/frontend/src/components/page-header.tsx">
/**
 * PageHeader component
 * Consistent page header with title, description, and optional actions
 */

import { ReactNode } from 'react';
import { cn } from '@/lib/utils';

type PageHeaderProps = {
  title: string;
  description?: string;
  actions?: ReactNode;
  className?: string;
};

export function PageHeader({
  title,
  description,
  actions,
  className,
}: PageHeaderProps) {
  return (
    <div className={cn('flex items-start justify-between gap-4', className)}>
      <div className="space-y-1">
        <h1 className="text-3xl font-bold tracking-tight">{title}</h1>
        {description && (
          <p className="text-muted-foreground">{description}</p>
        )}
      </div>
      {actions && <div className="flex gap-2">{actions}</div>}
    </div>
  );
}
</file>

<file path="components/frontend/src/components/project-selector.tsx">
"use client";

import { useEffect, useState } from "react";
import { usePathname, useRouter } from "next/navigation";
import { Select, SelectContent, SelectGroup, SelectItem, SelectLabel, SelectTrigger, SelectValue } from "@/components/ui/select";
import { useProjects } from "@/services/queries";

export function ProjectSelector() {
  const router = useRouter();
  const pathname = usePathname();
  const { data: projects = [] } = useProjects();
  const [value, setValue] = useState<string>("");

  useEffect(() => {
    // Hydrate selection from URL or storage
    const match = pathname?.match(/^\/projects\/([^\/]+)/);
    const urlProject = match?.[1];
    const stored = typeof window !== "undefined" ? localStorage.getItem("selectedProject") || "" : "";
    const initial = urlProject || stored;
    if (initial && projects.some(p => p.name === initial)) {
      setValue(initial);
    }
  }, [pathname, projects]);

  const onChange = (newValue: string) => {
    setValue(newValue);
    try { localStorage.setItem("selectedProject", newValue); } catch {}
    router.push(`/projects/${encodeURIComponent(newValue)}`);
  };

  return (
    <div className="min-w-[220px]">
      <Select value={value} onValueChange={onChange}>
        <SelectTrigger className="w-[240px]" disabled={projects.length === 0}>
          <SelectValue placeholder="Select project" />
        </SelectTrigger>
        <SelectContent>
          {projects.length === 0 ? (
            <SelectGroup>
              <SelectLabel>No projects</SelectLabel>
            </SelectGroup>
          ) : (
            projects.map((p) => (
              <SelectItem key={p.name} value={p.name}>
                {p.displayName || p.name}
              </SelectItem>
            ))
          )}
        </SelectContent>
      </Select>
    </div>
  );
}
</file>

<file path="components/frontend/src/components/RepoBrowser.tsx">
'use client';

import React, { useState, useEffect, useCallback } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { GitBranch } from 'lucide-react';
import * as repoApi from '@/services/api/repo';
import { RepoEntry, RepoBlob } from '@/types';
import { FileTree, type FileTreeNode } from '@/components/file-tree';

type RepoBrowserProps = {
  projectName: string;
  repoUrl: string;
  defaultRef?: string;
  onFileSelect?: (path: string, content: string) => void;
}

// Breadcrumb UI removed in favor of FileTree-based layout

export default function RepoBrowser({
  projectName,
  repoUrl,
  defaultRef = 'main',
  onFileSelect,
}: RepoBrowserProps) {
  const [currentRef] = useState(defaultRef);
  const [nodes, setNodes] = useState<FileTreeNode[]>([]);
  const [selectedPath, setSelectedPath] = useState<string | undefined>(undefined);
  const [fileContent, setFileContent] = useState<RepoBlob | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const formatFileSize = (bytes: number) => {
    if (bytes < 1024) return `${bytes} B`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
  };

  const entryToNode = (entry: RepoEntry, basePath: string = ''): FileTreeNode => {
    const nodePath = basePath ? `${basePath}/${entry.name}` : entry.name;
    return {
      name: entry.name,
      path: nodePath,
      type: entry.type === 'tree' ? 'folder' : 'file',
      expanded: false,
      sizeKb: typeof entry.size === 'number' ? entry.size / 1024 : undefined,
    };
  };

  const updateChildrenByPath = useCallback((nodesIn: FileTreeNode[], targetPath: string, children: FileTreeNode[]): FileTreeNode[] => {
    return nodesIn.map((n) => {
      if (n.path === targetPath) {
        return { ...n, children };
      }
      if (n.type === 'folder' && n.children && n.children.length > 0) {
        return { ...n, children: updateChildrenByPath(n.children, targetPath, children) };
      }
      return n;
    });
  }, []);

  const loadRoot = useCallback(async () => {
    setLoading(true);
    setError(null);
    setFileContent(null);
    setSelectedPath(undefined);
    try {
      const response = await repoApi.getRepoTree(projectName, { repo: repoUrl, ref: currentRef, path: '' });
      const rootNodes = (response.entries || [])
        .filter((e): e is Required<typeof e> & { name: string; type: 'blob' | 'tree' } => 
          !!e.name && (e.type === 'blob' || e.type === 'tree'))
        .map((e) => entryToNode(e));
      setNodes(rootNodes);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to load repository tree';
      setError(errorMessage);
      setNodes([]);
    } finally {
      setLoading(false);
    }
  }, [projectName, repoUrl, currentRef]);

  useEffect(() => {
    loadRoot();
  }, [loadRoot]);

  const onToggle = useCallback(async (node: FileTreeNode) => {
    if (node.type !== 'folder') return;
    try {
      const response = await repoApi.getRepoTree(projectName, { repo: repoUrl, ref: currentRef, path: node.path });
      const children = (response.entries || [])
        .filter((e): e is Required<typeof e> & { name: string; type: 'blob' | 'tree' } => 
          !!e.name && (e.type === 'blob' || e.type === 'tree'))
        .map((e) => entryToNode(e, node.path));
      setNodes((prev) => updateChildrenByPath(prev, node.path, children));
    } catch {
      // ignore toggle error; keep previous state
    }
  }, [projectName, repoUrl, currentRef, updateChildrenByPath]);

  const onSelect = useCallback(async (node: FileTreeNode) => {
    // Only handle file selection
    setSelectedPath(node.path);
    setLoading(true);
    setError(null);
    try {
      const response = await repoApi.getRepoBlob(projectName, { repo: repoUrl, ref: currentRef, path: node.path });
      if (response.ok) {
        const text = await response.text();
        // Try to parse as JSON to get the blob structure
        try {
          const parsed = JSON.parse(text);
          const blobData: RepoBlob = {
            content: parsed.content || text,
            encoding: parsed.encoding || 'utf-8',
            size: parsed.size || text.length,
          };
          setFileContent(blobData);
          if (onFileSelect) {
            onFileSelect(node.path, blobData.content);
          }
        } catch {
          // If not JSON, treat as plain text
          const blobData: RepoBlob = {
            content: text,
            encoding: 'utf-8',
            size: text.length,
          };
          setFileContent(blobData);
          if (onFileSelect) {
            onFileSelect(node.path, text);
          }
        }
      } else {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to load file content';
      setError(errorMessage);
      setFileContent(null);
    } finally {
      setLoading(false);
    }
  }, [projectName, repoUrl, currentRef, onFileSelect]);

  // Directory previews in the right pane are intentionally omitted

  return (
    <Card className="h-full">
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <GitBranch className="w-5 h-5" />
          Spec Repository Browser
        </CardTitle>
        <div className="flex items-center gap-2 text-sm text-gray-600">
          <span>{repoUrl}</span>
          <span>@</span>
          <span className="font-mono bg-gray-100 px-2 py-1 rounded">
            {currentRef}
          </span>
        </div>
      </CardHeader>
      <CardContent>
        {error && (
          <Alert variant="destructive" className="mb-4">
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}

        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          <div className="md:col-span-1 border rounded-lg overflow-hidden">
            <div className="p-2">
              {loading && nodes.length === 0 ? (
                <div className="text-sm text-muted-foreground p-2">Loading</div>
              ) : (
                <FileTree nodes={nodes} selectedPath={selectedPath} onSelect={onSelect} onToggle={onToggle} />
              )}
            </div>
          </div>
          <div className="md:col-span-2 border rounded-lg p-3 min-h-[300px]">
            {fileContent ? (
              <div className="space-y-2">
                <div className="flex items-center justify-between">
                  <div className="text-xs text-muted-foreground">{selectedPath}</div>
                  <div className="text-xs text-muted-foreground">
                    Size: {formatFileSize(fileContent.size)} | Encoding: {fileContent.encoding}
                  </div>
                </div>
                <div className="bg-gray-50 rounded-lg p-4 overflow-auto max-h-[60vh]">
                  <pre className="text-sm whitespace-pre-wrap break-words">{fileContent.content}</pre>
                </div>
              </div>
            ) : loading ? (
              <div className="text-sm text-muted-foreground">Loading</div>
            ) : (
              <div className="text-sm text-muted-foreground">Select a file to view its contents</div>
            )}
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="components/frontend/src/components/session-details-modal.tsx">
"use client";

import { format } from 'date-fns';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Badge } from '@/components/ui/badge';
import type { AgenticSession } from '@/types/agentic-session';
import { getPhaseColor } from '@/utils/session-helpers';

function formatDuration(ms: number): string {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  
  if (hours > 0) {
    const remainingMinutes = minutes % 60;
    const remainingSeconds = seconds % 60;
    return `${hours}h ${remainingMinutes}m ${remainingSeconds}s`;
  } else if (minutes > 0) {
    const remainingSeconds = seconds % 60;
    return `${minutes}m ${remainingSeconds}s`;
  } else {
    return `${seconds}s`;
  }
}

type SessionDetailsModalProps = {
  session: AgenticSession;
  open: boolean;
  onOpenChange: (open: boolean) => void;
  durationMs?: number;
  k8sResources?: {
    pvcName?: string;
    pvcSize?: string;
  };
  messageCount: number;
};

export function SessionDetailsModal({
  session,
  open,
  onOpenChange,
  durationMs,
  k8sResources,
  messageCount,
}: SessionDetailsModalProps) {
  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[500px] max-h-[90vh] overflow-y-auto">
        <DialogHeader className="space-y-3">
          <DialogTitle>Session Details</DialogTitle>
        </DialogHeader>
        
        <div className="space-y-4">
          <div className="space-y-3">
            <div className="flex items-start gap-3">
              <span className="font-semibold text-gray-700 min-w-[100px]">Status:</span>
              <Badge className={getPhaseColor(session.status?.phase || "Pending")}>
                {session.status?.phase || "Pending"}
              </Badge>
            </div>
            
            <div className="flex items-start gap-3">
              <span className="font-semibold text-gray-700 min-w-[100px]">Model:</span>
              <span className="text-gray-900">{session.spec.llmSettings.model}</span>
            </div>
            
            <div className="flex items-start gap-3">
              <span className="font-semibold text-gray-700 min-w-[100px]">Temperature:</span>
              <span className="text-gray-900">{session.spec.llmSettings.temperature}</span>
            </div>
            
            <div className="flex items-start gap-3">
              <span className="font-semibold text-gray-700 min-w-[100px]">Mode:</span>
              <span className="text-gray-900">{session.spec?.interactive ? "Interactive" : "Headless"}</span>
            </div>
            
            {session.status?.startTime && (
              <div className="flex items-start gap-3">
                <span className="font-semibold text-gray-700 min-w-[100px]">Started:</span>
                <span className="text-gray-900">{format(new Date(session.status.startTime), "PPp")}</span>
              </div>
            )}
            
            <div className="flex items-start gap-3">
              <span className="font-semibold text-gray-700 min-w-[100px]">Duration:</span>
              <span className="text-gray-900">{typeof durationMs === "number" ? formatDuration(durationMs) : "-"}</span>
            </div>
            
            {k8sResources?.pvcName && (
              <div className="flex items-start gap-3">
                <span className="font-semibold text-gray-700 min-w-[100px]">PVC:</span>
                <span className="text-gray-900 font-mono break-all">{k8sResources.pvcName}</span>
              </div>
            )}
            
            {k8sResources?.pvcSize && (
              <div className="flex items-start gap-3">
                <span className="font-semibold text-gray-700 min-w-[100px]">PVC Size:</span>
                <span className="text-gray-900">{k8sResources.pvcSize}</span>
              </div>
            )}
            
            {session.status?.jobName && (
              <div className="flex items-start gap-3">
                <span className="font-semibold text-gray-700 min-w-[100px]">K8s Job:</span>
                <span className="text-gray-900 font-mono break-all">{session.status.jobName}</span>
              </div>
            )}
            
            <div className="flex items-start gap-3">
              <span className="font-semibold text-gray-700 min-w-[100px]">Messages:</span>
              <span className="text-gray-900">{messageCount}</span>
            </div>
          </div>
          
          {session.spec.prompt && (
            <div className="pt-2">
              <div className="mb-2">
                <span className="font-semibold text-gray-700">Session prompt:</span>
              </div>
              <div className="max-h-[200px] overflow-y-auto p-4 bg-gray-50 rounded-md border border-gray-200">
                <p className="whitespace-pre-wrap text-sm text-gray-800 leading-relaxed">{session.spec.prompt}</p>
              </div>
            </div>
          )}
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="components/frontend/src/components/simple-data-table.tsx">
"use client";

import * as React from "react";
import { ArrowUpDown } from "lucide-react";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";

export type SimpleDataTableColumn<TData> = {
  header: string;
  accessorKey?: keyof TData;
  cell?: (row: TData) => React.ReactNode;
  sortable?: boolean;
};

export type SimpleDataTableProps<TData> = {
  columns: SimpleDataTableColumn<TData>[];
  data: TData[];
  searchable?: boolean;
  searchPlaceholder?: string;
  onSearch?: (query: string) => void;
  paginated?: boolean;
  pageSize?: number;
  emptyMessage?: string;
};

export function SimpleDataTable<TData extends Record<string, unknown>>({
  columns,
  data,
  searchable = false,
  searchPlaceholder = "Search...",
  onSearch,
  paginated = false,
  pageSize = 10,
  emptyMessage = "No results.",
}: SimpleDataTableProps<TData>) {
  const [searchQuery, setSearchQuery] = React.useState("");
  const [currentPage, setCurrentPage] = React.useState(0);
  const [sortColumn, setSortColumn] = React.useState<keyof TData | null>(null);
  const [sortDirection, setSortDirection] = React.useState<"asc" | "desc">("asc");

  const handleSearch = (query: string) => {
    setSearchQuery(query);
    setCurrentPage(0);
    if (onSearch) {
      onSearch(query);
    }
  };

  const handleSort = (column: keyof TData) => {
    if (sortColumn === column) {
      setSortDirection(sortDirection === "asc" ? "desc" : "asc");
    } else {
      setSortColumn(column);
      setSortDirection("asc");
    }
  };

  const filteredData = React.useMemo(() => {
    if (!searchQuery || onSearch) return data;

    return data.filter((row) =>
      Object.values(row).some((value) =>
        String(value).toLowerCase().includes(searchQuery.toLowerCase())
      )
    );
  }, [data, searchQuery, onSearch]);

  const sortedData = React.useMemo(() => {
    if (!sortColumn) return filteredData;

    return [...filteredData].sort((a, b) => {
      const aVal = a[sortColumn];
      const bVal = b[sortColumn];

      if (aVal === bVal) return 0;
      if (aVal === null || aVal === undefined) return 1;
      if (bVal === null || bVal === undefined) return -1;

      const comparison = String(aVal).localeCompare(String(bVal));
      return sortDirection === "asc" ? comparison : -comparison;
    });
  }, [filteredData, sortColumn, sortDirection]);

  const paginatedData = React.useMemo(() => {
    if (!paginated) return sortedData;
    const start = currentPage * pageSize;
    return sortedData.slice(start, start + pageSize);
  }, [sortedData, paginated, currentPage, pageSize]);

  const totalPages = Math.ceil(sortedData.length / pageSize);

  return (
    <div className="space-y-4">
      {searchable && (
        <div className="flex items-center">
          <Input
            placeholder={searchPlaceholder}
            value={searchQuery}
            onChange={(e) => handleSearch(e.target.value)}
            className="max-w-sm"
          />
        </div>
      )}
      <div className="rounded-md border">
        <Table>
          <TableHeader>
            <TableRow>
              {columns.map((column, index) => (
                <TableHead key={index}>
                  {column.sortable && column.accessorKey ? (
                    <Button
                      variant="ghost"
                      onClick={() => handleSort(column.accessorKey as keyof TData)}
                      className="-ml-4"
                    >
                      {column.header}
                      <ArrowUpDown className="ml-2 h-4 w-4" />
                    </Button>
                  ) : (
                    column.header
                  )}
                </TableHead>
              ))}
            </TableRow>
          </TableHeader>
          <TableBody>
            {paginatedData.length ? (
              paginatedData.map((row, rowIndex) => (
                <TableRow key={rowIndex}>
                  {columns.map((column, colIndex) => (
                    <TableCell key={colIndex}>
                      {column.cell
                        ? column.cell(row)
                        : column.accessorKey
                        ? String(row[column.accessorKey] ?? "")
                        : ""}
                    </TableCell>
                  ))}
                </TableRow>
              ))
            ) : (
              <TableRow>
                <TableCell colSpan={columns.length} className="h-24 text-center">
                  {emptyMessage}
                </TableCell>
              </TableRow>
            )}
          </TableBody>
        </Table>
      </div>
      {paginated && sortedData.length > 0 && (
        <div className="flex items-center justify-end space-x-2">
          <Button
            variant="outline"
            size="sm"
            onClick={() => setCurrentPage((prev) => Math.max(0, prev - 1))}
            disabled={currentPage === 0}
          >
            Previous
          </Button>
          <div className="text-sm text-muted-foreground">
            Page {currentPage + 1} of {totalPages}
          </div>
          <Button
            variant="outline"
            size="sm"
            onClick={() => setCurrentPage((prev) => Math.min(totalPages - 1, prev + 1))}
            disabled={currentPage >= totalPages - 1}
          >
            Next
          </Button>
        </div>
      )}
    </div>
  );
}
</file>

<file path="components/frontend/src/components/skeletons.tsx">
import { Skeleton } from "@/components/ui/skeleton";
import { Card, CardContent, CardHeader } from "@/components/ui/card";

/**
 * Skeleton for a list of items
 */
export function ListSkeleton({ items = 5 }: { items?: number }) {
  return (
    <div className="space-y-3">
      {Array.from({ length: items }).map((_, i) => (
        <div key={i} className="flex items-center space-x-4 p-4 border rounded-lg">
          <Skeleton className="h-12 w-12 rounded-full" />
          <div className="space-y-2 flex-1">
            <Skeleton className="h-4 w-[250px]" />
            <Skeleton className="h-4 w-[200px]" />
          </div>
        </div>
      ))}
    </div>
  );
}

/**
 * Skeleton for a table
 */
export function TableSkeleton({ rows = 5, columns = 4 }: { rows?: number; columns?: number }) {
  return (
    <div className="rounded-md border">
      <div className="border-b p-4">
        <div className="flex space-x-4">
          {Array.from({ length: columns }).map((_, i) => (
            <Skeleton key={i} className="h-4 w-[100px]" />
          ))}
        </div>
      </div>
      {Array.from({ length: rows }).map((_, i) => (
        <div key={i} className="border-b p-4 last:border-0">
          <div className="flex space-x-4">
            {Array.from({ length: columns }).map((_, j) => (
              <Skeleton key={j} className="h-4 w-[100px]" />
            ))}
          </div>
        </div>
      ))}
    </div>
  );
}

/**
 * Skeleton for a card with header and content
 */
export function CardSkeleton() {
  return (
    <Card>
      <CardHeader>
        <Skeleton className="h-6 w-[200px]" />
        <Skeleton className="h-4 w-[300px]" />
      </CardHeader>
      <CardContent className="space-y-2">
        <Skeleton className="h-4 w-full" />
        <Skeleton className="h-4 w-full" />
        <Skeleton className="h-4 w-[250px]" />
      </CardContent>
    </Card>
  );
}

/**
 * Skeleton for a form
 */
export function FormSkeleton({ fields = 4 }: { fields?: number }) {
  return (
    <div className="space-y-6">
      {Array.from({ length: fields }).map((_, i) => (
        <div key={i} className="space-y-2">
          <Skeleton className="h-4 w-[100px]" />
          <Skeleton className="h-10 w-full" />
        </div>
      ))}
      <Skeleton className="h-10 w-[120px]" />
    </div>
  );
}

/**
 * Skeleton for a detail page with title and sections
 */
export function DetailPageSkeleton() {
  return (
    <div className="space-y-6">
      <div className="space-y-2">
        <Skeleton className="h-8 w-[300px]" />
        <Skeleton className="h-4 w-[200px]" />
      </div>
      <div className="grid gap-6 md:grid-cols-2">
        <CardSkeleton />
        <CardSkeleton />
      </div>
      <CardSkeleton />
    </div>
  );
}

/**
 * Skeleton for a grid of cards
 */
export function CardGridSkeleton({ items = 6 }: { items?: number }) {
  return (
    <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
      {Array.from({ length: items }).map((_, i) => (
        <CardSkeleton key={i} />
      ))}
    </div>
  );
}
</file>

<file path="components/frontend/src/components/status-badge.tsx">
/**
 * Status Badge Component
 * Consistent badge styling for different status types
 */

import * as React from 'react';
import { Badge } from '@/components/ui/badge';
import { cn } from '@/lib/utils';
import {
  CheckCircle2,
  XCircle,
  AlertCircle,
  Clock,
  Loader2,
  Square,
} from 'lucide-react';

export type StatusVariant =
  | 'success'
  | 'error'
  | 'warning'
  | 'info'
  | 'pending'
  | 'running'
  | 'stopped'
  | 'default';

export type StatusBadgeProps = {
  status: StatusVariant | string;
  label?: string;
  showIcon?: boolean;
  className?: string;
  pulse?: boolean;
};

const STATUS_CONFIG: Record<
  StatusVariant,
  {
    color: string;
    icon: React.ComponentType<{ className?: string }>;
    label: string;
  }
> = {
  success: {
    color: 'bg-green-100 text-green-800 border-green-200',
    icon: CheckCircle2,
    label: 'Success',
  },
  error: {
    color: 'bg-red-100 text-red-800 border-red-200',
    icon: XCircle,
    label: 'Error',
  },
  warning: {
    color: 'bg-yellow-100 text-yellow-800 border-yellow-200',
    icon: AlertCircle,
    label: 'Warning',
  },
  info: {
    color: 'bg-blue-100 text-blue-800 border-blue-200',
    icon: AlertCircle,
    label: 'Info',
  },
  pending: {
    color: 'bg-gray-100 text-gray-800 border-gray-200',
    icon: Clock,
    label: 'Pending',
  },
  running: {
    color: 'bg-blue-100 text-blue-800 border-blue-200',
    icon: Loader2,
    label: 'Running',
  },
  stopped: {
    color: 'bg-gray-100 text-gray-800 border-gray-200',
    icon: Square,
    label: 'Stopped',
  },
  default: {
    color: 'bg-gray-100 text-gray-800 border-gray-200',
    icon: AlertCircle,
    label: 'Unknown',
  },
};

export function StatusBadge({
  status,
  label,
  showIcon = true,
  className,
  pulse = false,
}: StatusBadgeProps) {
  const normalizedStatus = (status.toLowerCase() as StatusVariant) || 'default';
  const config = STATUS_CONFIG[normalizedStatus] || STATUS_CONFIG.default;
  const Icon = config.icon;
  const displayLabel = label || config.label;

  return (
    <Badge
      variant="outline"
      className={cn('flex items-center gap-1.5 font-medium', config.color, className)}
    >
      {showIcon && (
        <Icon
          className={cn(
            'h-3 w-3',
            pulse && 'animate-pulse',
            normalizedStatus === 'running' && 'animate-spin'
          )}
        />
      )}
      {displayLabel}
    </Badge>
  );
}

/**
 * Session phase badge with appropriate styling
 */
export function SessionPhaseBadge({ phase }: { phase: string }) {
  const statusMap: Record<string, StatusVariant> = {
    pending: 'pending',
    creating: 'pending',
    running: 'running',
    completed: 'success',
    failed: 'error',
    stopped: 'stopped',
    error: 'error',
  };

  const status = statusMap[phase.toLowerCase()] || 'default';

  return <StatusBadge status={status} label={phase} pulse={status === 'running'} />;
}

/**
 * Project status badge
 */
export function ProjectStatusBadge({ status }: { status: string }) {
  const statusMap: Record<string, StatusVariant> = {
    active: 'success',
    archived: 'warning',
    pending: 'pending',
    error: 'error',
    terminating: 'warning',
  };

  const variant = statusMap[status.toLowerCase()] || 'default';

  return <StatusBadge status={variant} label={status} />;
}

/**
 * RFE workflow phase badge
 */
export function RFEPhaseBadge({ phase }: { phase: string }) {
  const statusMap: Record<string, StatusVariant> = {
    pre: 'pending',
    ideate: 'info',
    specify: 'info',
    plan: 'info',
    tasks: 'info',
    implement: 'running',
    review: 'warning',
    completed: 'success',
  };

  const status = statusMap[phase.toLowerCase()] || 'default';

  return <StatusBadge status={status} label={phase} pulse={status === 'running'} />;
}
</file>

<file path="components/frontend/src/components/user-bubble.tsx">
"use client";

import { Button } from "@/components/ui/button";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { useCurrentUser } from "@/services/queries";

export function UserBubble() {
  const { data: me, isLoading } = useCurrentUser();

  const initials = (me?.displayName || me?.username || me?.email || "?")
    .split(/[\s@._-]+/)
    .filter(Boolean)
    .slice(0, 2)
    .map((s) => s[0]?.toUpperCase())
    .join("");

  if (isLoading || !me) return <div className="w-8 h-8 rounded-full bg-muted animate-pulse" />;

  if (!me.authenticated) {
    return (
      <Button variant="ghost" size="sm">Sign in</Button>
    );
  }

  return (
    <Button variant="ghost" size="sm" className="m-2 p-1 pr-2 cursor-pointer" asChild>
      <div className="flex items-center gap-2">
        <Avatar>
          <AvatarImage alt={me.displayName || initials} />
          <AvatarFallback>{initials || "?"}</AvatarFallback>
        </Avatar>
        <span className="hidden sm:block text-sm text-muted-foreground">{me.displayName}</span>
      </div>
    </Button>
  );
}
</file>

<file path="components/frontend/src/hooks/index.ts">
/**
 * Custom hooks index
 * Re-exports all custom hooks
 */

export * from './use-clipboard';
export * from './use-debounce';
export * from './use-local-storage';
</file>

<file path="components/frontend/src/hooks/use-async-action.ts">
import { useState, useCallback } from 'react';

type AsyncActionState = {
  isLoading: boolean;
  error: Error | null;
};

type UseAsyncActionReturn<TArgs extends unknown[], TResult> = {
  execute: (...args: TArgs) => Promise<TResult | undefined>;
  isLoading: boolean;
  error: Error | null;
  reset: () => void;
};

export function useAsyncAction<TArgs extends unknown[], TResult>(
  action: (...args: TArgs) => Promise<TResult>
): UseAsyncActionReturn<TArgs, TResult> {
  const [state, setState] = useState<AsyncActionState>({
    isLoading: false,
    error: null,
  });

  const execute = useCallback(
    async (...args: TArgs): Promise<TResult | undefined> => {
      setState({ isLoading: true, error: null });
      try {
        const result = await action(...args);
        setState({ isLoading: false, error: null });
        return result;
      } catch (err) {
        const error = err instanceof Error ? err : new Error(String(err));
        setState({ isLoading: false, error });
        return undefined;
      }
    },
    [action]
  );

  const reset = useCallback(() => {
    setState({ isLoading: false, error: null });
  }, []);

  return {
    execute,
    isLoading: state.isLoading,
    error: state.error,
    reset,
  };
}
</file>

<file path="components/frontend/src/hooks/use-clipboard.ts">
/**
 * useClipboard hook
 * Provides copy to clipboard functionality with success state
 */

import { useState, useCallback } from 'react';

type UseClipboardReturn = {
  copy: (text: string) => Promise<void>;
  copied: boolean;
  error: Error | null;
};

export function useClipboard(resetDelay: number = 2000): UseClipboardReturn {
  const [copied, setCopied] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const copy = useCallback(
    async (text: string) => {
      try {
        await navigator.clipboard.writeText(text);
        setCopied(true);
        setError(null);

        // Reset copied state after delay
        setTimeout(() => {
          setCopied(false);
        }, resetDelay);
      } catch (err) {
        const error = err instanceof Error ? err : new Error('Failed to copy');
        setError(error);
        setCopied(false);
      }
    },
    [resetDelay]
  );

  return { copy, copied, error };
}
</file>

<file path="components/frontend/src/hooks/use-debounce.ts">
/**
 * useDebounce hook
 * Debounces a value by a specified delay
 */

import { useEffect, useState } from 'react';

export function useDebounce<T>(value: T, delay: number = 500): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}
</file>

<file path="components/frontend/src/hooks/use-local-storage.ts">
/**
 * useLocalStorage hook
 * Sync state with localStorage with type safety
 */

import { useState, useEffect, useCallback } from 'react';

type UseLocalStorageReturn<T> = [
  T,
  (value: T | ((val: T) => T)) => void,
  () => void
];

export function useLocalStorage<T>(
  key: string,
  initialValue: T
): UseLocalStorageReturn<T> {
  // Get from localStorage or use initial value
  const readValue = useCallback((): T => {
    if (typeof window === 'undefined') {
      return initialValue;
    }

    try {
      const item = window.localStorage.getItem(key);
      return item ? (JSON.parse(item) as T) : initialValue;
    } catch (error) {
      console.warn(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  }, [initialValue, key]);

  const [storedValue, setStoredValue] = useState<T>(readValue);

  // Set value in state and localStorage
  const setValue = useCallback(
    (value: T | ((val: T) => T)) => {
      try {
        const valueToStore =
          value instanceof Function ? value(storedValue) : value;

        setStoredValue(valueToStore);

        if (typeof window !== 'undefined') {
          window.localStorage.setItem(key, JSON.stringify(valueToStore));
        }
      } catch (error) {
        console.warn(`Error setting localStorage key "${key}":`, error);
      }
    },
    [key, storedValue]
  );

  // Remove value from localStorage
  const removeValue = useCallback(() => {
    try {
      if (typeof window !== 'undefined') {
        window.localStorage.removeItem(key);
        setStoredValue(initialValue);
      }
    } catch (error) {
      console.warn(`Error removing localStorage key "${key}":`, error);
    }
  }, [key, initialValue]);

  // Listen for changes in other tabs/windows
  useEffect(() => {
    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === key && e.newValue !== null) {
        try {
          setStoredValue(JSON.parse(e.newValue) as T);
        } catch (error) {
          console.warn(`Error parsing storage event for key "${key}":`, error);
        }
      }
    };

    window.addEventListener('storage', handleStorageChange);
    return () => window.removeEventListener('storage', handleStorageChange);
  }, [key]);

  return [storedValue, setValue, removeValue];
}
</file>

<file path="components/frontend/src/hooks/use-toast.tsx">
"use client"

import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 3
const TOAST_REMOVE_DELAY = 5000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type Action =
  | {
      type: "ADD_TOAST"
      toast: ToasterToast
    }
  | {
      type: "UPDATE_TOAST"
      toast: Partial<ToasterToast>
    }
  | {
      type: "DISMISS_TOAST"
      toastId?: ToasterToast["id"]
    }
  | {
      type: "REMOVE_TOAST"
      toastId?: ToasterToast["id"]
    }

type State = {
  toasts: ToasterToast[]
};

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

// Helper functions for common toast patterns
const successToast = (message: string) => {
  return toast({
    variant: "success",
    title: "Success",
    description: message,
  })
}

const errorToast = (message: string) => {
  return toast({
    variant: "destructive",
    title: "Error",
    description: message,
  })
}

export { useToast, toast, successToast, errorToast }
</file>

<file path="components/frontend/src/lib/config.ts">
// API configuration for frontend
const BACKEND_URL = process.env.BACKEND_URL || 'http://localhost:8080/api'

/**
 * Get the API base URL for frontend requests
 */
export function getApiUrl(): string {
  // Frontend always calls its own API routes (e.g., /api/agentic-sessions)
  // These routes proxy to the internal backend service
  if (typeof window !== 'undefined') {
    // Client-side: use relative URLs to hit our Next.js API routes
    return '/api'
  }
  
  // Server-side: directly call backend
  return BACKEND_URL
}
export { BACKEND_URL }
</file>

<file path="components/frontend/src/lib/query-client.ts">
/**
 * React Query client configuration
 */

import { QueryClient, DefaultOptions } from '@tanstack/react-query';

const queryConfig: DefaultOptions = {
  queries: {
    // Stale time: 5 minutes - data is considered fresh for 5 minutes
    staleTime: 5 * 60 * 1000,

    // Cache time: 10 minutes - unused data is garbage collected after 10 minutes
    gcTime: 10 * 60 * 1000,

    // Retry failed requests once
    retry: 1,

    // Retry delay with exponential backoff
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),

    // Refetch on window focus in production
    refetchOnWindowFocus: process.env.NODE_ENV === 'production',

    // Don't refetch on mount if data is fresh
    refetchOnMount: false,
  },
  mutations: {
    // Retry mutations once
    retry: 1,
  },
};

/**
 * Creates a new QueryClient instance
 * Use this in server components or for testing
 */
export function makeQueryClient() {
  return new QueryClient({
    defaultOptions: queryConfig,
  });
}

/**
 * Browser query client singleton
 * Ensures we only create one client instance in the browser
 */
let browserQueryClient: QueryClient | undefined = undefined;

export function getQueryClient() {
  if (typeof window === 'undefined') {
    // Server: always create a new query client
    return makeQueryClient();
  } else {
    // Browser: reuse the same query client
    if (!browserQueryClient) {
      browserQueryClient = makeQueryClient();
    }
    return browserQueryClient;
  }
}
</file>

<file path="components/frontend/src/services/api/auth.ts">
/**
 * Authentication API service
 */

import { apiClient } from './client';

export type UserProfile = {
  authenticated: boolean;
  userId?: string;
  email?: string;
  username?: string;
  displayName?: string;
};

/**
 * Get current user profile
 */
export async function getCurrentUser(): Promise<UserProfile> {
  try {
    return await apiClient.get<UserProfile>('/me');
  } catch {
    return { authenticated: false };
  }
}
</file>

<file path="components/frontend/src/services/api/client.ts">
/**
 * Base API client with error handling
 * Provides typed fetch wrapper with automatic error parsing
 */

import { ApiClientError, isApiError, type ApiResult } from '@/types/api';

type RequestConfig = RequestInit & {
  params?: Record<string, string | number | boolean>;
};

/**
 * Base URL for API requests
 * This client is only used client-side to call Next.js API routes
 */
export function getApiBaseUrl(): string {
  // Client-side only: use relative path (Next.js will proxy to backend)
  // or use NEXT_PUBLIC_API_URL if configured
  return process.env.NEXT_PUBLIC_API_URL || '/api';
}

/**
 * Build URL with query parameters
 * Note: This is only used client-side to call Next.js API routes
 */
function buildUrl(path: string, params?: Record<string, string | number | boolean>): string {
  const baseUrl = getApiBaseUrl();
  
  // Normalize paths for concatenation
  const normalizedBase = baseUrl.endsWith('/') ? baseUrl.slice(0, -1) : baseUrl;
  const normalizedPath = path.startsWith('/') ? path : `/${path}`;
  
  // Build the full path
  let fullUrl = `${normalizedBase}${normalizedPath}`;
  
  // Add query parameters if provided
  if (params) {
    const searchParams = new URLSearchParams();
    Object.entries(params).forEach(([key, value]) => {
      searchParams.append(key, String(value));
    });
    const queryString = searchParams.toString();
    if (queryString) {
      fullUrl += `?${queryString}`;
    }
  }

  return fullUrl;
}

/**
 * Parse API response
 * Handles both success and error responses
 */
async function parseResponse<T>(response: Response): Promise<T> {
  const contentType = response.headers.get('content-type');
  const isJson = contentType?.includes('application/json');

  // Parse JSON response
  const data: ApiResult<T> = isJson ? await response.json() : await response.text();

  // Handle error responses
  if (!response.ok) {
    // Only check isApiError if data is an object (not a string/HTML response)
    if (typeof data === 'object' && data !== null && isApiError(data)) {
      throw new ApiClientError(data.error, data.code, data.details);
    }
    throw new ApiClientError(
      `HTTP ${response.status}: ${response.statusText}`,
      String(response.status)
    );
  }

  // Handle success responses
  if (isJson && typeof data === 'object' && data !== null && 'data' in data) {
    return (data as { data: T }).data;
  }

  return data as T;
}

/**
 * Make an API request with automatic error handling
 */
async function request<T>(
  path: string,
  config: RequestConfig = {}
): Promise<T> {
  const { params, ...fetchConfig } = config;
  const url = buildUrl(path, params);

  const defaultHeaders: HeadersInit = {
    'Content-Type': 'application/json',
  };

  // Merge headers
  const headers = {
    ...defaultHeaders,
    ...fetchConfig.headers,
  };

  try {
    const response = await fetch(url, {
      ...fetchConfig,
      headers,
    });

    return await parseResponse<T>(response);
  } catch (error) {
    // Re-throw ApiClientError as-is
    if (error instanceof ApiClientError) {
      throw error;
    }

    // Wrap other errors
    throw new ApiClientError(
      error instanceof Error ? error.message : 'Unknown error occurred'
    );
  }
}

/**
 * API client methods
 */
export const apiClient = {
  /**
   * GET request
   */
  get: <T>(path: string, config?: RequestConfig): Promise<T> => {
    return request<T>(path, { ...config, method: 'GET' });
  },

  /**
   * POST request
   */
  post: <T, D = unknown>(path: string, data?: D, config?: RequestConfig): Promise<T> => {
    return request<T>(path, {
      ...config,
      method: 'POST',
      body: data ? JSON.stringify(data) : undefined,
    });
  },

  /**
   * PUT request
   */
  put: <T, D = unknown>(path: string, data?: D, config?: RequestConfig): Promise<T> => {
    return request<T>(path, {
      ...config,
      method: 'PUT',
      body: data ? JSON.stringify(data) : undefined,
    });
  },

  /**
   * PATCH request
   */
  patch: <T, D = unknown>(path: string, data?: D, config?: RequestConfig): Promise<T> => {
    return request<T>(path, {
      ...config,
      method: 'PATCH',
      body: data ? JSON.stringify(data) : undefined,
    });
  },

  /**
   * DELETE request
   */
  delete: <T>(path: string, config?: RequestConfig): Promise<T> => {
    return request<T>(path, { ...config, method: 'DELETE' });
  },

  /**
   * GET request that returns raw Response (for blob/text content)
   */
  getRaw: async (path: string, config?: RequestConfig): Promise<Response> => {
    const { params, ...fetchConfig } = config || {};
    const url = buildUrl(path, params);
    const headers = {
      ...fetchConfig.headers,
    };
    return fetch(url, {
      ...fetchConfig,
      method: 'GET',
      headers,
    });
  },

  /**
   * PUT request with raw text body
   */
  putText: async (path: string, content: string, config?: RequestConfig): Promise<void> => {
    const url = buildUrl(path, config?.params);
    const response = await fetch(url, {
      ...config,
      method: 'PUT',
      headers: {
        'Content-Type': 'text/plain; charset=utf-8',
        ...config?.headers,
      },
      body: content,
    });
    
    if (!response.ok) {
      const errorText = await response.text().catch(() => 'Unknown error');
      throw new ApiClientError(errorText || `HTTP ${response.status}`);
    }
  },
};
</file>

<file path="components/frontend/src/services/api/github.ts">
/**
 * GitHub Integration API service
 * Handles all GitHub-related API calls
 */

import { apiClient } from './client';
import type {
  GitHubStatus,
  GitHubFork,
  ListForksResponse,
  CreateForkRequest,
  CreateForkResponse,
  GetPRDiffResponse,
  PRDiff,
  CreatePRRequest,
  CreatePRResponse,
  GitHubConnectRequest,
  GitHubConnectResponse,
  GitHubDisconnectResponse,
} from '@/types/api';

/**
 * Get GitHub connection status
 */
export async function getGitHubStatus(): Promise<GitHubStatus> {
  return apiClient.get<GitHubStatus>('/auth/github/status');
}

/**
 * Connect GitHub account via GitHub App installation
 */
export async function connectGitHub(data: GitHubConnectRequest): Promise<string> {
  const response = await apiClient.post<GitHubConnectResponse, GitHubConnectRequest>(
    '/auth/github/install',
    data
  );
  return response.username;
}

/**
 * Disconnect GitHub account
 */
export async function disconnectGitHub(): Promise<string> {
  const response = await apiClient.post<GitHubDisconnectResponse>(
    '/auth/github/disconnect'
  );
  return response.message;
}

/**
 * List user's GitHub forks
 */
export async function listGitHubForks(
  projectName?: string,
  upstreamRepo?: string
): Promise<GitHubFork[]> {
  if (!projectName) {
    throw new Error('projectName is required for listGitHubForks');
  }
  if (!upstreamRepo) {
    throw new Error('upstreamRepo is required for listGitHubForks');
  }
  const response = await apiClient.get<ListForksResponse>(
    `/projects/${projectName}/users/forks?upstreamRepo=${encodeURIComponent(upstreamRepo)}`
  );
  return response.forks;
}

/**
 * Create a GitHub fork
 */
export async function createGitHubFork(
  data: CreateForkRequest,
  projectName?: string
): Promise<GitHubFork> {
  if (!projectName) {
    throw new Error('projectName is required for createGitHubFork');
  }
  const response = await apiClient.post<CreateForkResponse, CreateForkRequest>(
    `/projects/${projectName}/users/forks`,
    data
  );
  return response.fork;
}

/**
 * Get PR diff
 */
export async function getPRDiff(
  owner: string,
  repo: string,
  prNumber: number,
  projectName?: string
): Promise<PRDiff> {
  const path = projectName
    ? `/projects/${projectName}/github/pr/${owner}/${repo}/${prNumber}/diff`
    : `/github/pr/${owner}/${repo}/${prNumber}/diff`;
  const response = await apiClient.get<GetPRDiffResponse>(path);
  return response.diff;
}

/**
 * Create a pull request
 */
export async function createPullRequest(
  data: CreatePRRequest,
  projectName?: string
): Promise<{ url: string; number: number }> {
  const path = projectName
    ? `/projects/${projectName}/github/pr`
    : '/github/pr';
  return apiClient.post<CreatePRResponse, CreatePRRequest>(path, data);
}
</file>

<file path="components/frontend/src/services/api/keys.ts">
/**
 * API service for project access keys
 */

import { apiClient } from './client';

// Types
export type ProjectKey = {
  id: string;
  name: string;
  description?: string;
  createdAt?: string;
  lastUsedAt?: string;
  role?: 'view' | 'edit' | 'admin';
};

export type CreateKeyRequest = {
  name: string;
  description?: string;
  role?: 'view' | 'edit' | 'admin';
};

export type CreateKeyResponse = {
  id: string;
  name: string;
  key: string;
  description?: string;
  role?: 'view' | 'edit' | 'admin';
};

export type ListKeysResponse = {
  items: ProjectKey[];
};

/**
 * List all access keys for a project
 */
export async function listKeys(projectName: string): Promise<ProjectKey[]> {
  const response = await apiClient.get<ListKeysResponse>(`/projects/${projectName}/keys`);
  return response.items || [];
}

/**
 * Create a new access key for a project
 */
export async function createKey(
  projectName: string,
  data: CreateKeyRequest
): Promise<CreateKeyResponse> {
  return apiClient.post<CreateKeyResponse, CreateKeyRequest>(`/projects/${projectName}/keys`, data);
}

/**
 * Delete an access key
 */
export async function deleteKey(projectName: string, keyId: string): Promise<void> {
  await apiClient.delete(`/projects/${projectName}/keys/${keyId}`);
}
</file>

<file path="components/frontend/src/services/api/projects.ts">
/**
 * Projects API service
 * Handles all project-related API calls
 */

import { apiClient } from './client';
import type {
  Project,
  CreateProjectRequest,
  UpdateProjectRequest,
  ListProjectsResponse,
  DeleteProjectResponse,
  PermissionAssignment,
} from '@/types/api';

/**
 * List all projects
 */
export async function listProjects(): Promise<Project[]> {
  const response = await apiClient.get<ListProjectsResponse>('/projects');
  return response.items;
}

/**
 * Get a single project by name
 */
export async function getProject(name: string): Promise<Project> {
  return apiClient.get<Project>(`/projects/${name}`);
}

/**
 * Create a new project
 */
export async function createProject(data: CreateProjectRequest): Promise<Project> {
  return apiClient.post<Project, CreateProjectRequest>(
    '/projects',
    data
  );
}

/**
 * Update an existing project
 */
export async function updateProject(
  name: string,
  data: UpdateProjectRequest
): Promise<Project> {
  return apiClient.put<Project, UpdateProjectRequest>(
    `/projects/${name}`,
    data
  );
}

/**
 * Delete a project
 */
export async function deleteProject(name: string): Promise<string> {
  const response = await apiClient.delete<DeleteProjectResponse>(`/projects/${name}`);
  return response.message;
}

/**
 * Get project permissions
 */
export async function getProjectPermissions(
  projectName: string
): Promise<PermissionAssignment[]> {
  const response = await apiClient.get<{ items: PermissionAssignment[] }>(
    `/projects/${projectName}/permissions`
  );
  return response.items;
}

/**
 * Add permission to project
 */
export async function addProjectPermission(
  projectName: string,
  permission: PermissionAssignment
): Promise<PermissionAssignment> {
  return apiClient.post<PermissionAssignment, PermissionAssignment>(
    `/projects/${projectName}/permissions`,
    permission
  );
}

/**
 * Remove permission from project
 */
export async function removeProjectPermission(
  projectName: string,
  subjectType: string,
  subjectName: string
): Promise<void> {
  await apiClient.delete(
    `/projects/${projectName}/permissions/${subjectType}/${subjectName}`
  );
}
</file>

<file path="components/frontend/src/services/api/version.ts">
/**
 * Version API service
 * Handles version-related API calls
 */

import { apiClient } from './client';

type VersionResponse = {
  version: string;
};

/**
 * Get application version
 */
export async function getVersion(): Promise<string> {
  const response = await apiClient.get<VersionResponse>('/version');
  return response.version;
}
</file>

<file path="components/frontend/src/services/queries/use-auth.ts">
/**
 * React Query hooks for authentication
 */

import { useQuery } from '@tanstack/react-query';
import * as authApi from '../api/auth';

/**
 * Query keys for auth
 */
export const authKeys = {
  all: ['auth'] as const,
  currentUser: () => [...authKeys.all, 'currentUser'] as const,
};

/**
 * Hook to fetch current user profile
 */
export function useCurrentUser() {
  return useQuery({
    queryKey: authKeys.currentUser(),
    queryFn: authApi.getCurrentUser,
    staleTime: 5 * 60 * 1000, // 5 minutes - user info doesn't change often
  });
}
</file>

<file path="components/frontend/src/services/queries/use-cluster.ts">
/**
 * React Query hooks for cluster information
 */

import { useQuery } from '@tanstack/react-query';
import { getClusterInfo } from '@/services/api/cluster';

/**
 * Hook to get cluster information (OpenShift vs Kubernetes)
 * Detects cluster type by calling /api/cluster-info endpoint
 */
export function useClusterInfo() {
  return useQuery({
    queryKey: ['cluster-info'],
    queryFn: getClusterInfo,
    staleTime: Infinity, // Cluster type doesn't change, cache forever
    retry: 3, // Retry a few times on failure
  });
}
</file>

<file path="components/frontend/src/services/queries/use-github.ts">
/**
 * React Query hooks for GitHub integration
 */

import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import * as githubApi from '../api/github';
import type {
  CreateForkRequest,
  CreatePRRequest,
  GitHubConnectRequest,
} from '@/types/api';

/**
 * Query keys for GitHub
 */
export const githubKeys = {
  all: ['github'] as const,
  status: () => [...githubKeys.all, 'status'] as const,
  forks: () => [...githubKeys.all, 'forks'] as const,
  forksForProject: (projectName: string, upstreamRepo?: string) =>
    [...githubKeys.forks(), projectName, upstreamRepo] as const,
  diff: (owner: string, repo: string, prNumber: number) =>
    [...githubKeys.all, 'diff', owner, repo, prNumber] as const,
};

/**
 * Hook to fetch GitHub connection status
 */
export function useGitHubStatus() {
  return useQuery({
    queryKey: githubKeys.status(),
    queryFn: githubApi.getGitHubStatus,
    // Check status less frequently
    staleTime: 60 * 1000, // 1 minute
  });
}

/**
 * Hook to fetch GitHub forks
 */
export function useGitHubForks(projectName?: string, upstreamRepo?: string) {
  return useQuery({
    queryKey: githubKeys.forksForProject(projectName || '', upstreamRepo),
    queryFn: () => githubApi.listGitHubForks(projectName, upstreamRepo),
    // Only fetch if both projectName and upstreamRepo are provided
    enabled: !!projectName && !!upstreamRepo,
    // Forks don't change often
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
}

/**
 * Hook to fetch PR diff
 */
export function usePRDiff(
  owner: string,
  repo: string,
  prNumber: number,
  projectName?: string
) {
  return useQuery({
    queryKey: githubKeys.diff(owner, repo, prNumber),
    queryFn: () => githubApi.getPRDiff(owner, repo, prNumber, projectName),
    enabled: !!owner && !!repo && !!prNumber,
    // Diffs are relatively static
    staleTime: 60 * 1000, // 1 minute
  });
}

/**
 * Hook to connect GitHub
 */
export function useConnectGitHub() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: GitHubConnectRequest) => githubApi.connectGitHub(data),
    onSuccess: () => {
      // Invalidate status to show connected state
      queryClient.invalidateQueries({ queryKey: githubKeys.status() });
    },
  });
}

/**
 * Hook to disconnect GitHub
 */
export function useDisconnectGitHub() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: githubApi.disconnectGitHub,
    onSuccess: () => {
      // Invalidate status to show disconnected state
      queryClient.invalidateQueries({ queryKey: githubKeys.status() });
      // Clear forks cache
      queryClient.invalidateQueries({ queryKey: githubKeys.forks() });
    },
  });
}

/**
 * Hook to create a GitHub fork
 */
export function useCreateGitHubFork() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      data,
      projectName,
    }: {
      data: CreateForkRequest;
      projectName?: string;
    }) => githubApi.createGitHubFork(data, projectName),
    onSuccess: (_fork, { projectName }) => {
      // Invalidate all forks queries for this project
      if (projectName) {
        queryClient.invalidateQueries({
          queryKey: githubKeys.forksForProject(projectName),
        });
      } else {
        queryClient.invalidateQueries({ queryKey: githubKeys.forks() });
      }
    },
  });
}

/**
 * Hook to create a pull request
 */
export function useCreatePullRequest() {
  return useMutation({
    mutationFn: ({
      data,
      projectName,
    }: {
      data: CreatePRRequest;
      projectName?: string;
    }) => githubApi.createPullRequest(data, projectName),
  });
}
</file>

<file path="components/frontend/src/services/queries/use-keys.ts">
/**
 * React Query hooks for project access keys
 */

import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import * as keysApi from '../api/keys';

// Query key factory
export const keysKeys = {
  all: ['keys'] as const,
  lists: () => [...keysKeys.all, 'list'] as const,
  list: (projectName: string) => [...keysKeys.lists(), projectName] as const,
};

/**
 * Hook to list all access keys for a project
 */
export function useKeys(projectName: string) {
  return useQuery({
    queryKey: keysKeys.list(projectName),
    queryFn: () => keysApi.listKeys(projectName),
    staleTime: 5 * 60 * 1000, // 5 minutes
    enabled: !!projectName,
  });
}

/**
 * Hook to create a new access key
 */
export function useCreateKey() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ projectName, data }: { projectName: string; data: keysApi.CreateKeyRequest }) =>
      keysApi.createKey(projectName, data),
    onSuccess: (_data, variables) => {
      // Invalidate keys list to refetch
      queryClient.invalidateQueries({ queryKey: keysKeys.list(variables.projectName) });
    },
  });
}

/**
 * Hook to delete an access key
 */
export function useDeleteKey() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ projectName, keyId }: { projectName: string; keyId: string }) =>
      keysApi.deleteKey(projectName, keyId),
    onSuccess: (_data, variables) => {
      // Invalidate keys list to refetch
      queryClient.invalidateQueries({ queryKey: keysKeys.list(variables.projectName) });
    },
  });
}
</file>

<file path="components/frontend/src/services/queries/use-projects.ts">
/**
 * React Query hooks for projects
 */

import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import * as projectsApi from '../api/projects';
import type {
  Project,
  CreateProjectRequest,
  UpdateProjectRequest,
  PermissionAssignment,
} from '@/types/api';

/**
 * Query keys for projects
 */
export const projectKeys = {
  all: ['projects'] as const,
  lists: () => [...projectKeys.all, 'list'] as const,
  list: () => [...projectKeys.lists()] as const,
  details: () => [...projectKeys.all, 'detail'] as const,
  detail: (name: string) => [...projectKeys.details(), name] as const,
  permissions: (name: string) => [...projectKeys.detail(name), 'permissions'] as const,
};

/**
 * Hook to fetch all projects
 */
export function useProjects() {
  return useQuery({
    queryKey: projectKeys.list(),
    queryFn: projectsApi.listProjects,
  });
}

/**
 * Hook to fetch a single project
 */
export function useProject(name: string) {
  return useQuery({
    queryKey: projectKeys.detail(name),
    queryFn: () => projectsApi.getProject(name),
    enabled: !!name,
  });
}

/**
 * Hook to create a project
 */
export function useCreateProject() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: CreateProjectRequest) => projectsApi.createProject(data),
    onSuccess: () => {
      // Invalidate projects list to refetch
      queryClient.invalidateQueries({ queryKey: projectKeys.lists() });
    },
  });
}

/**
 * Hook to update a project
 */
export function useUpdateProject() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      name,
      data,
    }: {
      name: string;
      data: UpdateProjectRequest;
    }) => projectsApi.updateProject(name, data),
    onSuccess: (project: Project) => {
      // Update cached project details
      queryClient.setQueryData(projectKeys.detail(project.name), project);
      // Invalidate lists to reflect changes
      queryClient.invalidateQueries({ queryKey: projectKeys.lists() });
    },
  });
}

/**
 * Hook to delete a project
 */
export function useDeleteProject() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (name: string) => projectsApi.deleteProject(name),
    onSuccess: (_data, name) => {
      // Remove from cache
      queryClient.removeQueries({ queryKey: projectKeys.detail(name) });
      // Invalidate lists
      queryClient.invalidateQueries({ queryKey: projectKeys.lists() });
    },
  });
}

/**
 * Hook to fetch project permissions
 */
export function useProjectPermissions(projectName: string) {
  return useQuery({
    queryKey: projectKeys.permissions(projectName),
    queryFn: () => projectsApi.getProjectPermissions(projectName),
    enabled: !!projectName,
  });
}

/**
 * Hook to add project permission
 */
export function useAddProjectPermission() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      projectName,
      permission,
    }: {
      projectName: string;
      permission: PermissionAssignment;
    }) => projectsApi.addProjectPermission(projectName, permission),
    onSuccess: (_data, { projectName }) => {
      // Invalidate permissions to refetch
      queryClient.invalidateQueries({
        queryKey: projectKeys.permissions(projectName),
      });
    },
  });
}

/**
 * Hook to remove project permission
 */
export function useRemoveProjectPermission() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      projectName,
      subjectType,
      subjectName,
    }: {
      projectName: string;
      subjectType: string;
      subjectName: string;
    }) =>
      projectsApi.removeProjectPermission(projectName, subjectType, subjectName),
    onSuccess: (_data, { projectName }) => {
      // Invalidate permissions to refetch
      queryClient.invalidateQueries({
        queryKey: projectKeys.permissions(projectName),
      });
    },
  });
}
</file>

<file path="components/frontend/src/services/queries/use-version.ts">
/**
 * React Query hooks for version
 */

import { useQuery } from '@tanstack/react-query';
import * as versionApi from '../api/version';

/**
 * Query keys for version
 */
export const versionKeys = {
  all: ['version'] as const,
  current: () => [...versionKeys.all, 'current'] as const,
};

/**
 * Hook to fetch application version
 */
export function useVersion() {
  return useQuery({
    queryKey: versionKeys.current(),
    queryFn: versionApi.getVersion,
    staleTime: 5 * 60 * 1000, // Cache version for 5 minutes
    retry: false, // Don't retry on failure
  });
}
</file>

<file path="components/frontend/src/services/queries/use-workflows.ts">
import { useQuery } from "@tanstack/react-query";
import * as workflowsApi from "@/services/api/workflows";

export const workflowKeys = {
  all: ["workflows"] as const,
  ootb: (projectName?: string) => [...workflowKeys.all, "ootb", projectName] as const,
  metadata: (projectName: string, sessionName: string) =>
    [...workflowKeys.all, "metadata", projectName, sessionName] as const,
};

export function useOOTBWorkflows(projectName?: string) {
  return useQuery({
    queryKey: workflowKeys.ootb(projectName),
    queryFn: () => workflowsApi.listOOTBWorkflows(projectName),
    enabled: !!projectName, // Only fetch when projectName is available
    staleTime: 5 * 60 * 1000, // 5 minutes - workflows don't change often
  });
}

export function useWorkflowMetadata(
  projectName: string,
  sessionName: string,
  enabled: boolean
) {
  return useQuery({
    queryKey: workflowKeys.metadata(projectName, sessionName),
    queryFn: () => workflowsApi.getWorkflowMetadata(projectName, sessionName),
    enabled: enabled && !!projectName && !!sessionName,
    staleTime: 60 * 1000, // 1 minute
  });
}
</file>

<file path="components/frontend/src/types/api/auth.ts">
/**
 * Authentication and authorization API types
 */

export type User = {
  username: string;
  email?: string;
  displayName?: string;
  groups?: string[];
  roles?: string[];
};

export type AuthStatus = {
  authenticated: boolean;
  user?: User;
};

export type LoginRequest = {
  username: string;
  password: string;
};

export type LoginResponse = {
  token: string;
  user: User;
};

export type LogoutResponse = {
  message: string;
};

export type RefreshTokenResponse = {
  token: string;
};
</file>

<file path="components/frontend/src/types/api/common.ts">
/**
 * Common API types and utilities
 */

export type ApiResponse<T> = {
  data: T;
  error?: never;
};

export type ApiError = {
  error: string;
  code?: string;
  details?: Record<string, unknown>;
};

export type ApiResult<T> = ApiResponse<T> | ApiError;

export function isApiError<T>(result: ApiResult<T>): result is ApiError {
  return 'error' in result && result.error !== undefined;
}

export function isApiSuccess<T>(result: ApiResult<T>): result is ApiResponse<T> {
  return 'data' in result && !('error' in result);
}

export class ApiClientError extends Error {
  constructor(
    message: string,
    public code?: string,
    public details?: Record<string, unknown>
  ) {
    super(message);
    this.name = 'ApiClientError';
  }
}
</file>

<file path="components/frontend/src/types/components/forms.ts">
/**
 * Component-specific types for forms
 */

export type FormFieldError = {
  message: string;
};

export type FormErrors<T> = {
  [K in keyof T]?: string[];
};

export type ActionState = {
  error?: string;
  errors?: Record<string, string[]>;
};

export type FormState<T = unknown> = {
  success: boolean;
  message?: string;
  errors?: FormErrors<T>;
  data?: T;
};
</file>

<file path="components/frontend/src/types/components/index.ts">
/**
 * Component types index
 */

export * from './forms';
</file>

<file path="components/frontend/src/types/index.ts">
// Core types for RFE Workflows and GitHub integration

export interface Project {
  name: string;
  displayName: string;
  description?: string;
  labels: Record<string, string>;
  annotations: Record<string, string>;
  creationTimestamp: string;
  status: string;
}

export interface Workspace {
  id: string;
  workspaceSlug: string;
  upstreamRepoUrl: string;
  canonicalBranch: string;
  specifyFeatureSlug: string;
  s3Bucket: string;
  s3Prefix: string;
  createdByUserId: string;
  createdAt: string;
  project: string;
}

export interface Session {
  id: string;
  workspaceId: string;
  userId: string;
  inputRepoUrl: string;
  inputBranch: string;
  outputRepoUrl: string;
  outputBranch: string;
  status: 'queued' | 'running' | 'succeeded' | 'failed';
  flags: string[];
  prLinks: PRLink[];
  runnerType: 'claude' | 'openai' | 'localexec';
  startedAt: string;
  finishedAt?: string;
  project: string;
}

export interface PRLink {
  repoUrl: string;
  branch: string;
  targetBranch: string;
  url: string;
  status: 'open' | 'merged' | 'closed';
}

export interface GitHubFork {
  name: string;
  fullName: string;
  url: string;
  owner: {
    login: string;
    avatar_url: string;
  };
  private: boolean;
  default_branch: string;
}

export interface RepoTree {
  path?: string;
  entries: RepoEntry[];
}

export interface RepoEntry {
  name: string;
  type: 'blob' | 'tree';
  size?: number;
  sha?: string;
}

export interface RepoBlob {
  content: string;
  encoding: string;
  size: number;
}

export interface GitHubInstallation {
  installationId: number;
  githubUserId: string;
  login: string;
  avatarUrl?: string;
}

export interface SessionMessage {
  seq: number;
  type: string;
  timestamp: string;
  payload: Record<string, unknown>;
  partial?: {
    id: string;
    index: number;
    total: number;
    data: string;
  };
}

export interface UserAccess {
  user: string;
  project: string;
  access: 'view' | 'edit' | 'admin' | 'none';
  allowed: boolean;
}

export interface APIError {
  error: string;
  code?: string;
  details?: Record<string, unknown>;
}
</file>

<file path="components/frontend/src/types/project.ts">
// Project types for the Ambient Agentic Runner frontend
// Based on the OpenAPI contract specifications from backend tests

export interface ObjectMeta {
  name: string;
  namespace?: string;
  labels?: Record<string, string>;
  annotations?: Record<string, string>;
  creationTimestamp?: string;
  resourceVersion?: string;
  uid?: string;
}

export interface BotAccount {
  name: string;
  description?: string;
}

export type PermissionRole = "view" | "edit" | "admin";

export type SubjectType = "user" | "group";

export type PermissionAssignment = {
  subjectType: SubjectType;
  subjectName: string;
  role: PermissionRole;
  permissions?: string[];
  memberCount?: number;
  grantedAt?: string;
  grantedBy?: string;
};

export interface Model {
  name: string;
  displayName: string;
  costPerToken: number;
  maxTokens: number;
  default?: boolean;
}

export interface ResourceLimits {
  cpu: string;
  memory: string;
  storage: string;
  maxDurationMinutes: number;
}

export interface Integration {
  type: string;
  enabled: boolean;
}

export interface AvailableResources {
  models: Model[];
  resourceLimits: ResourceLimits;
  priorityClasses: string[];
  integrations: Integration[];
}

export interface ProjectDefaults {
  model: string;
  temperature: number;
  maxTokens: number;
  timeout: number;
  priorityClass: string;
}

export interface ProjectConstraints {
  maxConcurrentSessions: number;
  maxSessionsPerUser: number;
  maxCostPerSession: number;
  maxCostPerUserPerDay: number;
  allowSessionCloning: boolean;
  allowBotAccounts: boolean;
}

export interface AmbientProjectSpec {
  displayName: string;
  description?: string;
  bots?: BotAccount[];
  groupAccess?: PermissionAssignment[];
  availableResources: AvailableResources;
  defaults: ProjectDefaults;
  constraints: ProjectConstraints;
}

export interface CurrentUsage {
  activeSessions: number;
  totalCostToday: number;
}

export interface ProjectCondition {
  type: string;
  status: string;
  reason?: string;
  message?: string;
  lastTransitionTime?: string;
}

export interface AmbientProjectStatus {
  phase?: string;
  botsCreated?: number;
  groupBindingsCreated?: number;
  lastReconciled?: string;
  currentUsage?: CurrentUsage;
  conditions?: ProjectCondition[];
}


// Flat DTO used by frontend UIs when backend formats Project responses
export type Project = {
  name: string;
  displayName?: string; // Empty on vanilla k8s, set on OpenShift
  description?: string; // Empty on vanilla k8s, set on OpenShift
  labels?: Record<string, string>;
  annotations?: Record<string, string>;
  creationTimestamp?: string;
  status?: string; // e.g., "Active" | "Pending" | "Error"
  isOpenShift?: boolean; // Indicates if cluster is OpenShift (affects available features)
};


export interface CreateProjectRequest {
  name: string;
  displayName?: string; // Optional: only used on OpenShift
  description?: string; // Optional: only used on OpenShift
}

export type ProjectPhase = "Pending" | "Active" | "Error" | "Terminating";
</file>

<file path="components/frontend/src/utils/session-helpers.ts">
import type { AgenticSessionPhase } from "@/types/agentic-session";

/**
 * Get the color classes for a session phase badge
 */
export const getPhaseColor = (phase: AgenticSessionPhase): string => {
  switch (phase) {
    case "Pending":
      return "bg-yellow-100 text-yellow-800";
    case "Creating":
    case "Running":
      return "bg-blue-100 text-blue-800";
    case "Completed":
      return "bg-green-100 text-green-800";
    case "Failed":
    case "Error":
      return "bg-red-100 text-red-800";
    case "Stopped":
      return "bg-gray-100 text-gray-800";
    default:
      return "bg-gray-100 text-gray-800";
  }
};
</file>

<file path="components/frontend/COMPONENT_PATTERNS.md">
# Component Patterns & Architecture Guide

This guide documents the component patterns and architectural decisions made during the frontend modernization.

## File Organization

```
src/
 app/                    # Next.js 15 App Router
    projects/
       page.tsx       # Route component
       loading.tsx    # Loading state
       error.tsx      # Error boundary
       [name]/        # Dynamic routes
 components/            # Reusable components
    ui/               # Shadcn base components
    layouts/          # Layout components
    *.tsx             # Custom components
 services/             # API layer
    api/             # HTTP clients
    queries/         # React Query hooks
 hooks/               # Custom hooks
 types/               # TypeScript types
 lib/                 # Utilities
```

## Naming Conventions

- **Files**: kebab-case (e.g., `empty-state.tsx`)
- **Components**: PascalCase (e.g., `EmptyState`)
- **Hooks**: camelCase with `use` prefix (e.g., `useAsyncAction`)
- **Types**: PascalCase (e.g., `ProjectSummary`)

## Component Patterns

### 1. Type Over Interface

**Guideline**: Always use `type` instead of `interface`

```typescript
//  Good
type ButtonProps = {
  label: string;
  onClick: () => void;
};

//  Bad
interface ButtonProps {
  label: string;
  onClick: () => void;
}
```

### 2. Component Props

**Pattern**: Destructure props with typed parameters

```typescript
type EmptyStateProps = {
  icon?: React.ComponentType<{ className?: string }>;
  title: string;
  description?: string;
  action?: React.ReactNode;
};

export function EmptyState({
  icon: Icon,
  title,
  description,
  action
}: EmptyStateProps) {
  // Implementation
}
```

### 3. Children Props

**Pattern**: Use `React.ReactNode` for children

```typescript
type PageContainerProps = {
  children: React.ReactNode;
  maxWidth?: 'sm' | 'md' | 'lg';
};
```

### 4. Loading States

**Pattern**: Use skeleton components, not spinners

```typescript
//  Good - loading.tsx
import { TableSkeleton } from '@/components/skeletons';

export default function SessionsLoading() {
  return <TableSkeleton rows={10} columns={5} />;
}

//  Bad - inline spinner
if (loading) return <Spinner />;
```

### 5. Error Handling

**Pattern**: Use error boundaries, not inline error states

```typescript
//  Good - error.tsx
'use client';

export default function SessionsError({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Failed to load sessions</CardTitle>
        <CardDescription>{error.message}</CardDescription>
      </CardHeader>
      <CardContent>
        <Button onClick={reset}>Try again</Button>
      </CardContent>
    </Card>
  );
}
```

### 6. Empty States

**Pattern**: Use EmptyState component consistently

```typescript
{sessions.length === 0 ? (
  <EmptyState
    icon={Inbox}
    title="No sessions yet"
    description="Create your first session to get started"
    action={
      <Button onClick={handleCreate}>
        <Plus className="w-4 h-4 mr-2" />
        New Session
      </Button>
    }
  />
) : (
  // Render list
)}
```

## React Query Patterns

### 1. Query Hooks

**Pattern**: Create typed query hooks in `services/queries/`

```typescript
export function useProjects() {
  return useQuery({
    queryKey: ['projects'],
    queryFn: () => projectsApi.listProjects(),
    staleTime: 30000, // 30 seconds
  });
}
```

### 2. Mutation Hooks

**Pattern**: Include optimistic updates and cache invalidation

```typescript
export function useDeleteProject() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (name: string) => projectsApi.deleteProject(name),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['projects'] });
    },
  });
}
```

### 3. Page Usage

**Pattern**: Destructure query results

```typescript
export default function ProjectsPage() {
  const { data: projects, isLoading, error } = useProjects();
  const deleteMutation = useDeleteProject();

  // Use loading.tsx for isLoading
  // Use error.tsx for error
  // Render data
}
```

## Layout Patterns

### 1. Page Structure

```typescript
<PageContainer maxWidth="xl">
  <PageHeader
    title="Projects"
    description="Manage your projects"
    actions={<Button>New Project</Button>}
  />

  <PageSection title="Active Projects">
    {/* Content */}
  </PageSection>
</PageContainer>
```

### 2. Sidebar Layout

```typescript
<SidebarLayout
  sidebar={<ProjectNav />}
  sidebarWidth="16rem"
>
  {children}
</SidebarLayout>
```

## Form Patterns

### 1. Form Fields

**Pattern**: Use FormFieldWrapper for consistency

```typescript
<FormFieldsGrid>
  <FormFieldWrapper
    label="Project Name"
    description="Unique identifier"
    error={errors.name}
  >
    <Input {...register('name')} />
  </FormFieldWrapper>
</FormFieldsGrid>
```

### 2. Submit Buttons

**Pattern**: Use LoadingButton for mutations

```typescript
<LoadingButton
  type="submit"
  loading={mutation.isPending}
  disabled={!isValid}
>
  Create Project
</LoadingButton>
```

## Custom Hooks

### 1. Async Actions

```typescript
const { execute, isLoading, error } = useAsyncAction(
  async (data) => {
    return await api.createProject(data);
  }
);

await execute(formData);
```

### 2. Local Storage

```typescript
const [theme, setTheme] = useLocalStorage('theme', 'light');
```

### 3. Clipboard

```typescript
const { copy, copied } = useClipboard();

<Button onClick={() => copy(text)}>
  {copied ? 'Copied!' : 'Copy'}
</Button>
```

## TypeScript Patterns

### 1. No Any Types

```typescript
//  Good
type MessageHandler = (msg: SessionMessage) => void;

//  Bad
type MessageHandler = (msg: any) => void;
```

### 2. Optional Chaining

```typescript
//  Good
const name = project?.displayName ?? project.name;

//  Bad
const name = project ? project.displayName || project.name : '';
```

### 3. Type Guards

```typescript
function isErrorResponse(data: unknown): data is ErrorResponse {
  return typeof data === 'object' &&
         data !== null &&
         'error' in data;
}
```

## Performance Patterns

### 1. Code Splitting

**Pattern**: Use dynamic imports for heavy components

```typescript
const HeavyComponent = dynamic(() => import('./HeavyComponent'), {
  loading: () => <Skeleton />,
});
```

### 2. React Query Caching

**Pattern**: Set appropriate staleTime

```typescript
// Fast-changing data
staleTime: 0

// Slow-changing data
staleTime: 300000 // 5 minutes

// Static data
staleTime: Infinity
```

## Accessibility Patterns

### 1. ARIA Labels

```typescript
<Button aria-label="Delete project">
  <Trash className="w-4 h-4" />
</Button>
```

### 2. Keyboard Navigation

```typescript
<div
  role="button"
  tabIndex={0}
  onKeyDown={(e) => e.key === 'Enter' && handleClick()}
>
  {content}
</div>
```

## Error Message Patterns

```typescript
//  User-friendly
"Failed to load projects. Please try again."

//  Technical
"Error: ECONNREFUSED 127.0.0.1:3000"
```

## Summary

Key patterns:
- Use `type` over `interface`
- Skeleton components for loading
- Error boundaries for errors
- EmptyState for empty lists
- React Query for data fetching
- TypeScript strict mode
- No `any` types
- Proper error messages
</file>

<file path="components/frontend/DESIGN_GUIDELINES.md">
# Frontend Design Guidelines

## Table of Contents
1. [Component Architecture](#component-architecture)
2. [TypeScript & Type Safety](#typescript--type-safety)
3. [API Layer & Data Fetching](#api-layer--data-fetching)
4. [Next.js App Router Patterns](#nextjs-app-router-patterns)
5. [File Organization](#file-organization)
6. [UX Standards](#ux-standards)
7. [Component Composition](#component-composition)
8. [State Management](#state-management)

---

## Component Architecture

### Always Use Shadcn Components as Foundation

**Rule:** All UI components MUST be built on top of Shadcn components when possible.

**Why:** Shadcn provides:
- Accessible, WAI-ARIA compliant components
- Consistent design system
- Pre-built Radix UI primitives
- Full customization control

**Examples:**

```tsx
//  GOOD: Extend Shadcn components
import { Button } from '@/components/ui/button';
import { Alert, AlertDescription } from '@/components/ui/alert';

type SuccessAlertProps = {
  message: string;
  onDismiss?: () => void;
};

export const SuccessAlert = ({ message, onDismiss }: SuccessAlertProps) => {
  return (
    <Alert variant="default" className="border-green-500 bg-green-50">
      <AlertDescription>{message}</AlertDescription>
      {onDismiss && (
        <Button variant="ghost" size="sm" onClick={onDismiss}>
          Dismiss
        </Button>
      )}
    </Alert>
  );
};

//  BAD: Creating custom components from scratch
export const SuccessAlert = ({ message }: { message: string }) => {
  return (
    <div className="border rounded p-4 bg-green-50">
      <p>{message}</p>
    </div>
  );
};
```

### Component Variants & Customization

Derive customizations using the component's variant props or composition:

```tsx
//  GOOD: Use variants
<Button variant="destructive">Delete</Button>
<Button variant="outline">Cancel</Button>
<Button variant="ghost">Close</Button>

//  GOOD: Compose new variants
import { buttonVariants } from '@/components/ui/button';

const successButton = buttonVariants({
  variant: 'default',
  className: 'bg-green-600 hover:bg-green-700'
});
```

---

## TypeScript & Type Safety

### No `any` Types - Ever

**Rule:** The use of `any` is STRICTLY FORBIDDEN. Use proper types, `unknown`, or generic constraints.

```tsx
//  BAD
const handleData = (data: any) => {
  console.log(data.name);
};

//  GOOD: Use proper types
type UserData = {
  name: string;
  email: string;
};

const handleData = (data: UserData) => {
  console.log(data.name);
};

//  GOOD: Use unknown for truly unknown data
const handleData = (data: unknown) => {
  if (isUserData(data)) {
    console.log(data.name);
  }
};

const isUserData = (data: unknown): data is UserData => {
  return (
    typeof data === 'object' &&
    data !== null &&
    'name' in data &&
    'email' in data
  );
};
```

### Define Shared Types

**Rule:** Create shared type definitions that match backend Go structs.

**Structure:**
```
src/types/
 api/              # API request/response types
    projects.ts
    sessions.ts
    rfe.ts
    common.ts
 models/           # Domain models
    project.ts
    session.ts
    user.ts
 components/       # Component-specific types
    forms.ts
 index.ts          # Public exports
```

**Example:**

```tsx
// src/types/api/projects.ts
export type ProjectStatus = 'active' | 'archived' | 'pending';

export type Project = {
  name: string;
  displayName: string;
  description?: string;
  labels: Record<string, string>;
  annotations: Record<string, string>;
  creationTimestamp: string;
  status: ProjectStatus;
};

export type CreateProjectRequest = {
  name: string;
  displayName: string;
  description?: string;
  labels?: Record<string, string>;
};

export type CreateProjectResponse = {
  project: Project;
};

// src/types/api/common.ts
export type ApiResponse<T> = {
  data: T;
  error?: never;
};

export type ApiError = {
  error: string;
  code?: string;
  details?: Record<string, unknown>;
};

export type ApiResult<T> = ApiResponse<T> | ApiError;
```

### Use `type` over `interface`

**Rule:** Prefer `type` declarations over `interface` (per user preference).

```tsx
//  GOOD
type ButtonProps = {
  variant?: 'primary' | 'secondary';
  size?: 'sm' | 'md' | 'lg';
  disabled?: boolean;
  onClick?: () => void;
};

//  AVOID
interface ButtonProps {
  variant?: 'primary' | 'secondary';
  // ...
}
```

---

## API Layer & Data Fetching

### Data Fetching Strategy

Our application uses a hybrid approach leveraging Next.js capabilities:

1. **Server Components (SSR/SSG)**: Use Next.js `fetch` API for initial data loading
2. **Client Components**: Use TanStack React Query for dynamic/interactive data
3. **Mutations**: Use Next.js Server Actions for POST/PUT/DELETE operations

### Next.js Fetch API (Server Components)

**Rule:** Use Next.js extended `fetch` API in Server Components for initial page data.

**Why:** Next.js `fetch` provides:
- Automatic request deduplication
- Built-in caching strategies
- Server-side rendering benefits
- No client-side JavaScript needed for initial load

**Caching Strategies:**

```tsx
// Force cache (default) - Cache indefinitely until revalidated
fetch(url, { cache: 'force-cache' });

// No store - Fresh data on every request
fetch(url, { cache: 'no-store' });

// Revalidate - Cache with time-based revalidation
fetch(url, { next: { revalidate: 3600 } }); // Revalidate every hour

// Tag-based revalidation - Cache with on-demand revalidation
fetch(url, { next: { tags: ['projects'] } });
```

**Example Server Component:**

```tsx
// app/projects/page.tsx (Server Component)
import type { Project } from '@/types/api/projects';
import { ProjectsList } from './components/projects-list';

async function getProjects(): Promise<Project[]> {
  const res = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/api/projects`, {
    next: { revalidate: 60, tags: ['projects'] }, // Revalidate every 60 seconds
  });

  if (!res.ok) {
    throw new Error('Failed to fetch projects');
  }

  const data = await res.json();
  return data.projects;
}

export default async function ProjectsPage() {
  const projects = await getProjects();

  return (
    <div>
      <h1>Projects</h1>
      <ProjectsList initialProjects={projects} />
    </div>
  );
}
```

**Error Handling:**

```tsx
// app/projects/page.tsx
import { notFound } from 'next/navigation';
import type { Project } from '@/types/api/projects';

async function getProject(name: string): Promise<Project | null> {
  const res = await fetch(
    `${process.env.NEXT_PUBLIC_API_URL}/api/projects/${name}`,
    {
      next: { revalidate: 60, tags: ['projects', `project-${name}`] },
    }
  );

  if (res.status === 404) {
    return null;
  }

  if (!res.ok) {
    throw new Error('Failed to fetch project');
  }

  const data = await res.json();
  return data.project;
}

export default async function ProjectPage({ params }: { params: { name: string } }) {
  const project = await getProject(params.name);

  if (!project) {
    notFound(); // Renders not-found.tsx
  }

  return (
    <div>
      <h1>{project.displayName}</h1>
      {/* ... */}
    </div>
  );
}
```

**Parallel Data Fetching:**

```tsx
// app/projects/[name]/page.tsx
async function getProject(name: string) {
  const res = await fetch(`/api/projects/${name}`, {
    next: { tags: [`project-${name}`] },
  });
  if (!res.ok) throw new Error('Failed to fetch project');
  return res.json();
}

async function getSessions(projectName: string) {
  const res = await fetch(`/api/projects/${projectName}/sessions`, {
    next: { tags: [`project-${projectName}-sessions`] },
  });
  if (!res.ok) throw new Error('Failed to fetch sessions');
  return res.json();
}

async function getRfeWorkflows(projectName: string) {
  const res = await fetch(`/api/projects/${projectName}/rfe-workflows`, {
    next: { tags: [`project-${projectName}-rfe`] },
  });
  if (!res.ok) throw new Error('Failed to fetch RFE workflows');
  return res.json();
}

export default async function ProjectDashboard({ params }: { params: { name: string } }) {
  // Fetch all data in parallel
  const [projectData, sessionsData, rfeData] = await Promise.all([
    getProject(params.name),
    getSessions(params.name),
    getRfeWorkflows(params.name),
  ]);

  return (
    <div>
      <h1>{projectData.project.displayName}</h1>
      <SessionsList sessions={sessionsData.sessions} />
      <RfeList workflows={rfeData.workflows} />
    </div>
  );
}
```

### React Query for Mutations

**Rule:** Use React Query mutations for ALL data mutations (POST, PUT, DELETE operations).

**Why:** React Query provides:
- Automatic error handling and retry logic
- Optimistic updates
- Automatic cache invalidation
- TypeScript type safety
- Built-in loading and error states
- Better client-side state management

See the API Service Layer section above for implementation examples.

### Use TanStack React Query (Client Components)

**Rule:** Use React Query for dynamic, client-side data fetching in Client Components.

**When to use React Query:**
- Real-time data that needs frequent updates
- User-specific data
- Data that changes based on user interaction
- Polling or WebSocket fallback
- Optimistic updates
- Complex client-side caching needs

**Setup:**

```tsx
// src/lib/query-client.ts
import { QueryClient } from '@tanstack/react-query';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5 minutes
      refetchOnWindowFocus: false,
      retry: 1,
    },
  },
});

// src/app/layout.tsx
import { QueryClientProvider } from '@tanstack/react-query';
import { queryClient } from '@/lib/query-client';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html>
      <body>
        <QueryClientProvider client={queryClient}>
          {children}
        </QueryClientProvider>
      </body>
    </html>
  );
}
```

### API Service Layer

**Rule:** Create a separate, reusable API service layer.

**Structure:**
```
src/services/
 api/
    client.ts          # Base API client
    projects.ts        # Project endpoints
    sessions.ts        # Session endpoints
    rfe.ts            # RFE endpoints
    auth.ts           # Auth endpoints
 queries/
    use-projects.ts    # Project queries & mutations
    use-sessions.ts    # Session queries & mutations
    use-rfe.ts        # RFE queries & mutations
 index.ts
```

**Example:**

```tsx
// src/services/api/client.ts
import type { ApiError } from '@/types/api/common';

export class ApiClient {
  private baseUrl = '/api';

  async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const url = `${this.baseUrl}${endpoint}`;
    
    const response = await fetch(url, {
      headers: {
        'Content-Type': 'application/json',
        ...options.headers,
      },
      ...options,
    });

    if (!response.ok) {
      const error: ApiError = await response.json().catch(() => ({
        error: `HTTP ${response.status}: ${response.statusText}`,
      }));
      throw new ApiError(error.error, error.code);
    }

    return response.json();
  }

  get<T>(endpoint: string, options?: RequestInit): Promise<T> {
    return this.request<T>(endpoint, { ...options, method: 'GET' });
  }

  post<T>(endpoint: string, data?: unknown, options?: RequestInit): Promise<T> {
    return this.request<T>(endpoint, {
      ...options,
      method: 'POST',
      body: JSON.stringify(data),
    });
  }

  put<T>(endpoint: string, data?: unknown, options?: RequestInit): Promise<T> {
    return this.request<T>(endpoint, {
      ...options,
      method: 'PUT',
      body: JSON.stringify(data),
    });
  }

  delete<T>(endpoint: string, options?: RequestInit): Promise<T> {
    return this.request<T>(endpoint, { ...options, method: 'DELETE' });
  }
}

export class ApiError extends Error {
  constructor(message: string, public code?: string) {
    super(message);
    this.name = 'ApiError';
  }
}

export const apiClient = new ApiClient();

// src/services/api/projects.ts
import { apiClient } from './client';
import type { Project, CreateProjectRequest, CreateProjectResponse } from '@/types/api/projects';

export const projectsApi = {
  list: () => apiClient.get<{ projects: Project[] }>('/projects'),
  
  get: (name: string) => 
    apiClient.get<{ project: Project }>(`/projects/${name}`),
  
  create: (data: CreateProjectRequest) => 
    apiClient.post<CreateProjectResponse>('/projects', data),
  
  delete: (name: string) => 
    apiClient.delete(`/projects/${name}`),
};

// src/services/queries/use-projects.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { projectsApi } from '@/services/api/projects';
import type { CreateProjectRequest } from '@/types/api/projects';

const projectKeys = {
  all: ['projects'] as const,
  lists: () => [...projectKeys.all, 'list'] as const,
  list: (filters?: string) => [...projectKeys.lists(), filters] as const,
  details: () => [...projectKeys.all, 'detail'] as const,
  detail: (name: string) => [...projectKeys.details(), name] as const,
};

export const useProjects = () => {
  return useQuery({
    queryKey: projectKeys.lists(),
    queryFn: () => projectsApi.list(),
    select: (data) => data.projects,
  });
};

export const useProject = (name: string) => {
  return useQuery({
    queryKey: projectKeys.detail(name),
    queryFn: () => projectsApi.get(name),
    select: (data) => data.project,
    enabled: !!name,
  });
};

export const useCreateProject = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (data: CreateProjectRequest) => projectsApi.create(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: projectKeys.lists() });
    },
  });
};

export const useDeleteProject = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (name: string) => projectsApi.delete(name),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: projectKeys.lists() });
    },
  });
};

// Usage in components
'use client';

import { useProjects, useCreateProject } from '@/services/queries/use-projects';
import { Button } from '@/components/ui/button';

export const ProjectsList = () => {
  const { data: projects, isLoading, error } = useProjects();
  const createProject = useCreateProject();

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      {projects?.map((project) => (
        <div key={project.name}>{project.displayName}</div>
      ))}
      <Button
        onClick={() => createProject.mutate({ name: 'new-project', displayName: 'New Project' })}
        disabled={createProject.isPending}
      >
        {createProject.isPending ? 'Creating...' : 'Create Project'}
      </Button>
    </div>
  );
};
```

---

## Next.js App Router Patterns

### Use App Router Features

**Rule:** Leverage all Next.js App Router capabilities for better UX and code organization.

#### Required Files Per Route

Each route should have:
- `page.tsx` - Main page component
- `layout.tsx` - Shared layout (if needed)
- `loading.tsx` - Loading UI
- `error.tsx` - Error boundary
- `not-found.tsx` - 404 UI (for dynamic routes)

```
app/projects/[name]/
 layout.tsx          # Shared layout with sidebar
 page.tsx            # Project dashboard
 loading.tsx         # Loading skeleton
 error.tsx           # Error boundary
 not-found.tsx       # Project not found
 components/         # Page-specific components
    project-header.tsx
    stats-card.tsx
    activity-feed.tsx
 lib/               # Page-specific utilities
    utils.ts
    constants.ts
 hooks/             # Page-specific hooks
     use-project-data.ts
```

**Examples:**

```tsx
// app/projects/[name]/loading.tsx
import { Skeleton } from '@/components/ui/skeleton';

export default function Loading() {
  return (
    <div className="space-y-4">
      <Skeleton className="h-12 w-full" />
      <Skeleton className="h-64 w-full" />
    </div>
  );
}

// app/projects/[name]/error.tsx
'use client';

import { useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Alert, AlertDescription } from '@/components/ui/alert';

type ErrorProps = {
  error: Error & { digest?: string };
  reset: () => void;
};

export default function Error({ error, reset }: ErrorProps) {
  useEffect(() => {
    console.error('Project error:', error);
  }, [error]);

  return (
    <div className="flex items-center justify-center min-h-screen">
      <Alert variant="destructive" className="max-w-md">
        <AlertDescription>
          <h2 className="font-semibold mb-2">Something went wrong</h2>
          <p className="text-sm mb-4">{error.message}</p>
          <Button onClick={reset}>Try again</Button>
        </AlertDescription>
      </Alert>
    </div>
  );
}

// app/projects/[name]/not-found.tsx
import Link from 'next/link';
import { Button } from '@/components/ui/button';
import { EmptyState } from '@/components/empty-state';

export default function NotFound() {
  return (
    <EmptyState
      icon="folder-x"
      title="Project not found"
      description="The project you're looking for doesn't exist or you don't have access to it."
      action={
        <Button asChild>
          <Link href="/projects">View all projects</Link>
        </Button>
      }
    />
  );
}
```

---

## File Organization

### Component Colocation

**Rule:** Single-use components should be colocated with their page. Reusable components go in `src/components`.

```
 GOOD Structure:
src/
 app/
    projects/
        [name]/
            sessions/
               [sessionName]/
                  page.tsx
                  loading.tsx
                  components/
                     session-header.tsx    # Only used here
                     message-list.tsx      # Only used here
                  hooks/
                      use-session-messages.ts
               page.tsx
 components/
    ui/                    # Shadcn components
    empty-state.tsx       # Reusable across app
    breadcrumbs.tsx       # Reusable across app
    loading-button.tsx    # Reusable across app
 hooks/
    use-toast.tsx         # Reusable hook
 lib/
     utils.ts              # Shared utilities
     constants.ts          # Shared constants

 BAD Structure:
src/
 components/
    session-header.tsx    # Only used in one page
    message-list.tsx      # Only used in one page
    stats-card.tsx        # Only used in one page
 app/
     projects/[name]/sessions/[sessionName]/page.tsx
```

### Extract Reusable Logic

**Rule:** Identify and extract reusable components and hooks.

```tsx
//  BAD: Repeated logic in multiple components
const ComponentA = () => {
  const [isLoading, setIsLoading] = useState(false);
  
  const handleSubmit = async () => {
    setIsLoading(true);
    try {
      await fetch('/api/data');
    } finally {
      setIsLoading(false);
    }
  };
  
  return <Button disabled={isLoading}>Submit</Button>;
};

//  GOOD: Extract into reusable hook
// src/hooks/use-async-action.ts
export const useAsyncAction = <T,>(
  action: () => Promise<T>
) => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const execute = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const result = await action();
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Unknown error');
      setError(error);
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  return { execute, isLoading, error };
};

// Usage
const ComponentA = () => {
  const { execute, isLoading } = useAsyncAction(() => fetch('/api/data'));
  return <Button disabled={isLoading} onClick={execute}>Submit</Button>;
};
```

---

## UX Standards

### Button States

**Rule:** ALL buttons MUST have consistent loading and disabled states.

```tsx
//  GOOD: Consistent button with loading state
import { Button } from '@/components/ui/button';
import { Loader2 } from 'lucide-react';

type LoadingButtonProps = React.ComponentProps<typeof Button> & {
  isLoading?: boolean;
  loadingText?: string;
};

export const LoadingButton = ({
  isLoading,
  loadingText,
  children,
  disabled,
  ...props
}: LoadingButtonProps) => {
  return (
    <Button disabled={disabled || isLoading} {...props}>
      {isLoading ? (
        <>
          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
          {loadingText || children}
        </>
      ) : (
        children
      )}
    </Button>
  );
};

// Usage
const MyForm = () => {
  const mutation = useCreateProject();
  
  return (
    <LoadingButton
      isLoading={mutation.isPending}
      loadingText="Creating..."
      onClick={() => mutation.mutate(data)}
    >
      Create Project
    </LoadingButton>
  );
};
```

### Empty States

**Rule:** ALL lists and data displays MUST have proper empty states.

```tsx
// src/components/empty-state.tsx
import { LucideIcon } from 'lucide-react';
import * as Icons from 'lucide-react';

type EmptyStateProps = {
  icon?: keyof typeof Icons;
  title: string;
  description: string;
  action?: React.ReactNode;
};

export const EmptyState = ({
  icon = 'inbox',
  title,
  description,
  action,
}: EmptyStateProps) => {
  const Icon = Icons[icon] as LucideIcon;

  return (
    <div className="flex flex-col items-center justify-center py-12 text-center">
      <div className="rounded-full bg-muted p-3 mb-4">
        <Icon className="h-6 w-6 text-muted-foreground" />
      </div>
      <h3 className="text-lg font-semibold mb-2">{title}</h3>
      <p className="text-sm text-muted-foreground mb-4 max-w-md">
        {description}
      </p>
      {action && <div>{action}</div>}
    </div>
  );
};

// Usage
const ProjectsList = () => {
  const { data: projects } = useProjects();

  if (!projects?.length) {
    return (
      <EmptyState
        icon="folder-open"
        title="No projects yet"
        description="Get started by creating your first project."
        action={
          <Button asChild>
            <Link href="/projects/new">Create Project</Link>
          </Button>
        }
      />
    );
  }

  return <div>{/* render projects */}</div>;
};
```

### Breadcrumbs

**Rule:** All nested pages MUST display breadcrumbs for navigation context.

```tsx
// src/components/breadcrumbs.tsx
import Link from 'next/link';
import { ChevronRight } from 'lucide-react';

type BreadcrumbItem = {
  label: string;
  href?: string;
};

type BreadcrumbsProps = {
  items: BreadcrumbItem[];
};

export const Breadcrumbs = ({ items }: BreadcrumbsProps) => {
  return (
    <nav aria-label="Breadcrumb" className="flex items-center space-x-2 text-sm text-muted-foreground">
      {items.map((item, index) => (
        <div key={index} className="flex items-center">
          {index > 0 && <ChevronRight className="h-4 w-4 mx-2" />}
          {item.href ? (
            <Link
              href={item.href}
              className="hover:text-foreground transition-colors"
            >
              {item.label}
            </Link>
          ) : (
            <span className="text-foreground font-medium">{item.label}</span>
          )}
        </div>
      ))}
    </nav>
  );
};

// Usage in page
const ProjectSessionPage = ({ params }: { params: { name: string; sessionName: string } }) => {
  return (
    <div>
      <Breadcrumbs
        items={[
          { label: 'Projects', href: '/projects' },
          { label: params.name, href: `/projects/${params.name}` },
          { label: 'Sessions', href: `/projects/${params.name}/sessions` },
          { label: params.sessionName },
        ]}
      />
      {/* rest of page */}
    </div>
  );
};
```

### Layout & Sidebar

**Rule:** Use consistent layouts with proper sidebar/content separation.

```tsx
// app/projects/[name]/layout.tsx
import { Sidebar } from './components/sidebar';
import { Breadcrumbs } from '@/components/breadcrumbs';

type LayoutProps = {
  children: React.ReactNode;
  params: { name: string };
};

export default function ProjectLayout({ children, params }: LayoutProps) {
  return (
    <div className="flex h-screen">
      <Sidebar projectName={params.name} />
      <div className="flex-1 flex flex-col">
        <header className="border-b p-4">
          <Breadcrumbs
            items={[
              { label: 'Projects', href: '/projects' },
              { label: params.name },
            ]}
          />
        </header>
        <main className="flex-1 overflow-auto p-6">
          {children}
        </main>
      </div>
    </div>
  );
}
```

---

## Component Composition

### Break Down Large Components

**Rule:** Components over 200 lines MUST be broken down into smaller sub-components.

```tsx
//  BAD: 600+ line component
export function SessionPage() {
  // 600 lines of mixed concerns
  return (
    <div>
      {/* header */}
      {/* tabs */}
      {/* messages */}
      {/* workspace */}
      {/* results */}
    </div>
  );
}

//  GOOD: Broken into focused components
// app/projects/[name]/sessions/[sessionName]/page.tsx
export default function SessionPage({ params }: PageProps) {
  return (
    <div className="space-y-6">
      <SessionHeader sessionName={params.sessionName} />
      <SessionTabs sessionName={params.sessionName} />
    </div>
  );
}

// app/projects/[name]/sessions/[sessionName]/components/session-header.tsx
export function SessionHeader({ sessionName }: { sessionName: string }) {
  // 50 lines
}

// app/projects/[name]/sessions/[sessionName]/components/session-tabs.tsx
export function SessionTabs({ sessionName }: { sessionName: string }) {
  // 80 lines
}
```

---

## State Management

### Server State vs Client State

**Rule:** Use React Query for server state, React state for UI-only state.

```tsx
//  GOOD: Clear separation
'use client';

import { useState } from 'react';
import { useProject } from '@/services/queries/use-projects';

export const ProjectPage = ({ params }: { params: { name: string } }) => {
  // Server state - managed by React Query
  const { data: project, isLoading } = useProject(params.name);
  
  // Client state - managed by React state
  const [selectedTab, setSelectedTab] = useState('overview');
  const [isDialogOpen, setIsDialogOpen] = useState(false);

  // ...
};
```

---

## Summary Checklist

### Component Architecture
- [ ] All components use Shadcn as foundation
- [ ] Component variants derived from Shadcn base components
- [ ] No components over 200 lines

### TypeScript & Type Safety
- [ ] Zero `any` types in codebase
- [ ] Proper TypeScript types throughout
- [ ] Use `type` over `interface`
- [ ] Shared types match backend Go structs
- [ ] Type guards for runtime validation

### Data Fetching & API
- [ ] React Query for all data fetching (queries and mutations)
- [ ] API service layer separated from components
- [ ] Proper error handling in all data fetching
- [ ] Automatic cache invalidation with React Query

### Next.js App Router
- [ ] All routes have loading.tsx
- [ ] All routes have error.tsx
- [ ] Dynamic routes have not-found.tsx
- [ ] React Query hooks for all data operations

### File Organization
- [ ] Single-use components colocated with pages
- [ ] Reusable components in src/components
- [ ] Custom hooks extracted where appropriate
- [ ] Page-specific utilities in colocated lib/ folders

### UX Standards
- [ ] All buttons have loading states
- [ ] All lists have empty states
- [ ] Breadcrumbs on all nested pages
- [ ] Consistent layout with sidebar
- [ ] Proper loading skeletons
- [ ] User-friendly error messages
- [ ] Success feedback (toasts/alerts)
</file>

<file path="components/frontend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="components/frontend/src/app/integrations/IntegrationsClient.tsx">
'use client'

import React from 'react'
import { GitHubConnectionCard } from '@/components/github-connection-card'
import { PageHeader } from '@/components/page-header'

type Props = { appSlug?: string }

export default function IntegrationsClient({ appSlug }: Props) {
  return (
    <div className="min-h-screen bg-[#f8fafc]">
      {/* Sticky header */}
      <div className="sticky top-0 z-20 bg-white border-b">
        <div className="container mx-auto px-6 py-6">
          <PageHeader
            title="Integrations"
            description="Connect Ambient Code Platform with your favorite tools and services"
          />
        </div>
      </div>

      <div className="container mx-auto p-0">
        {/* Content */}
        <div className="px-6 pt-6">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <GitHubConnectionCard appSlug={appSlug} showManageButton={true} />
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="components/frontend/src/app/projects/[name]/permissions/page.tsx">
'use client';

import { useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';

export default function PermissionsPage() {
  const params = useParams();
  const router = useRouter();
  const projectName = params?.name as string;

  // Redirect to main workspace page
  useEffect(() => {
    if (projectName) {
      router.replace(`/projects/${projectName}?section=sharing`);
    }
  }, [projectName, router]);

  return null;
}
</file>

<file path="components/frontend/src/app/projects/[name]/sessions/[sessionName]/components/accordions/workflows-accordion.tsx">
"use client";

import { useState } from "react";
import { Play, Loader2, Workflow, ChevronDown, ChevronRight, Info, AlertCircle } from "lucide-react";
import { AccordionItem, AccordionTrigger, AccordionContent } from "@/components/ui/accordion";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Select, SelectContent, SelectItem, SelectSeparator, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import type { WorkflowConfig } from "../../lib/types";

type WorkflowMetadata = {
  commands: Array<{ id: string; name: string; slashCommand: string; description?: string }>;
  agents: Array<{ id: string; name: string; description?: string }>;
};

type WorkflowsAccordionProps = {
  sessionPhase?: string;
  activeWorkflow: string | null;
  selectedWorkflow: string;
  pendingWorkflow: WorkflowConfig | null;
  workflowActivating: boolean;
  workflowMetadata?: WorkflowMetadata;
  ootbWorkflows: WorkflowConfig[];
  isExpanded: boolean;
  onWorkflowChange: (value: string) => void;
  onActivateWorkflow: () => void;
  onCommandClick: (slashCommand: string) => void;
  onResume?: () => void;
};

export function WorkflowsAccordion({
  sessionPhase,
  activeWorkflow,
  selectedWorkflow,
  pendingWorkflow,
  workflowActivating,
  workflowMetadata,
  ootbWorkflows,
  isExpanded,
  onWorkflowChange,
  onActivateWorkflow,
  onCommandClick,
  onResume,
}: WorkflowsAccordionProps) {
  const [showCommandsList, setShowCommandsList] = useState(false);
  const [showAgentsList, setShowAgentsList] = useState(false);
  const [commandsScrollTop, setCommandsScrollTop] = useState(false);
  const [commandsScrollBottom, setCommandsScrollBottom] = useState(true);
  const [agentsScrollTop, setAgentsScrollTop] = useState(false);
  const [agentsScrollBottom, setAgentsScrollBottom] = useState(true);

  const isSessionStopped = sessionPhase === 'Stopped' || sessionPhase === 'Error' || sessionPhase === 'Completed';

  return (
    <AccordionItem value="workflows" className="border rounded-lg px-3 bg-white">
      <AccordionTrigger className="text-base font-semibold hover:no-underline py-3">
        <div className="flex items-center gap-2">
          <Workflow className="h-4 w-4" />
          <span>Workflows</span>
          {activeWorkflow && !isExpanded && (
            <Badge variant="outline" className="bg-green-50 text-green-700 border-green-200">
              {ootbWorkflows.find(w => w.id === activeWorkflow)?.name || "Custom Workflow"}
            </Badge>
          )}
        </div>
      </AccordionTrigger>
      <AccordionContent className="pt-2 pb-3">
        {isSessionStopped ? (
          <div className="py-8 flex flex-col items-center justify-center space-y-4">
            <Play className="h-12 w-12 text-muted-foreground/50" />
            <div className="text-center space-y-1">
              <h3 className="font-medium text-sm">Session not running</h3>
              <p className="text-sm text-muted-foreground">
                You need to resume this session to use workflows.
              </p>
            </div>
            {onResume && sessionPhase === 'Stopped' && (
              <Button
                onClick={onResume}
                size="sm"
                className="hover:border-green-600 hover:bg-green-50 group"
                variant="outline"
              >
                <Play className="w-4 h-4 mr-2 fill-green-200 stroke-green-600 group-hover:fill-green-500 group-hover:stroke-green-700 transition-colors" />
                Resume Session
              </Button>
            )}
          </div>
        ) : (
          <div className="space-y-3">
            {/* Workflow selector - always visible except when activating */}
            {!workflowActivating && (
              <>
                <p className="text-sm text-muted-foreground">
                  Workflows provide agents with pre-defined context and structured steps to follow.
                </p>
                
                <div>
                  <Select value={selectedWorkflow} onValueChange={onWorkflowChange} disabled={workflowActivating}>
                    <SelectTrigger className="w-full h-auto py-8">
                      <SelectValue placeholder="Generic chat" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="none">
                        <div className="flex flex-col items-start gap-0.5 py-1">
                          <span>General chat</span>
                          <span className="text-xs text-muted-foreground font-normal">
                            A general chat session with no structured workflow.
                          </span>
                        </div>
                      </SelectItem>
                      {ootbWorkflows.map((workflow) => (
                        <SelectItem 
                          key={workflow.id} 
                          value={workflow.id}
                          disabled={!workflow.enabled}
                        >
                          <div className="flex flex-col items-start gap-0.5 py-1">
                            <span>{workflow.name}</span>
                            <span className="text-xs text-muted-foreground font-normal">
                              {workflow.description}
                            </span>
                          </div>
                        </SelectItem>
                      ))}
                      <SelectSeparator />
                      <SelectItem value="custom">
                        <div className="flex flex-col items-start gap-0.5 py-1">
                          <span>Custom workflow...</span>
                          <span className="text-xs text-muted-foreground font-normal">
                            Load a workflow from a custom Git repository
                          </span>
                        </div>
                      </SelectItem>
                    </SelectContent>
                  </Select>
                </div>
                
                {/* Show workflow preview and activate/switch button */}
                {pendingWorkflow && (
                  <Alert variant="info">
                    <AlertCircle />
                    <AlertTitle>
                      Reload required
                    </AlertTitle>
                    <AlertDescription>
                      <div className="space-y-2 mt-2">
                        <p className="text-sm">
                          Please reload this chat session to switch to the new workflow. Your chat history will be preserved.
                        </p>
                        <Button 
                          onClick={onActivateWorkflow}
                          className="w-full mt-3"
                          size="sm"
                        >
                          <Play className="mr-2 h-4 w-4" />
                          Load new workflow
                        </Button>
                      </div>
                    </AlertDescription>
                  </Alert>
                )}
              </>
            )}
            
            {/* Show active workflow info */}
            {activeWorkflow && !workflowActivating && (
              <>
                {/* Commands Section */}
                {workflowMetadata?.commands && workflowMetadata.commands.length > 0 && (
                  <div className="space-y-2">
                    <div>
                      <Button
                        variant="ghost"
                        size="sm"
                        className="w-full justify-between h-8 px-2"
                        onClick={() => setShowCommandsList(!showCommandsList)}
                      >
                        <span className="text-xs font-medium">
                          {showCommandsList ? 'Hide' : 'Show'} {workflowMetadata.commands.length} available command{workflowMetadata.commands.length !== 1 ? 's' : ''}
                        </span>
                        {showCommandsList ? (
                          <ChevronDown className="h-3 w-3" />
                        ) : (
                          <ChevronRight className="h-3 w-3" />
                        )}
                      </Button>

                      {showCommandsList && (
                        <div className="relative mt-2">
                          {commandsScrollTop && (
                            <div className="absolute top-0 left-0 right-0 h-8 bg-gradient-to-b from-white to-transparent pointer-events-none z-10" />
                          )}
                          <div 
                            className="max-h-[400px] overflow-y-auto space-y-2 pr-1"
                            onScroll={(e) => {
                              const target = e.currentTarget;
                              const isScrolledFromTop = target.scrollTop > 10;
                              const isScrolledToBottom = target.scrollHeight - target.scrollTop <= target.clientHeight + 10;
                              setCommandsScrollTop(isScrolledFromTop);
                              setCommandsScrollBottom(!isScrolledToBottom);
                            }}
                          >
                            {workflowMetadata.commands.map((cmd) => {
                              const commandTitle = cmd.name.includes('.') 
                                ? cmd.name.split('.').pop() 
                                : cmd.name;
                              
                              return (
                                <div
                                  key={cmd.id}
                                  className="p-3 rounded-md border bg-muted/30"
                                >
                                  <div className="flex items-center justify-between mb-1">
                                    <h3 className="text-sm font-bold capitalize">
                                      {commandTitle}
                                    </h3>
                                    <Button
                                      variant="outline"
                                      size="sm"
                                      className="flex-shrink-0 h-7 text-xs"
                                      onClick={() => onCommandClick(cmd.slashCommand)}
                                    >
                                      Run {cmd.slashCommand.replace(/^\/speckit\./, '/')}
                                    </Button>
                                  </div>
                                  {cmd.description && (
                                    <p className="text-xs text-muted-foreground">
                                      {cmd.description}
                                    </p>
                                  )}
                                </div>
                              );
                            })}
                          </div>
                          {commandsScrollBottom && (
                            <div className="absolute bottom-0 left-0 right-0 h-8 bg-gradient-to-t from-white to-transparent pointer-events-none z-10" />
                          )}
                        </div>
                      )}
                    </div>
                  </div>
                )}

                {workflowMetadata?.commands?.length === 0 && (
                  <p className="text-xs text-muted-foreground text-left py-2">
                    No commands found in this workflow
                  </p>
                )}

                {/* Agents Section */}
                {workflowMetadata?.agents && workflowMetadata.agents.length > 0 && (
                  <div className="space-y-2">
                    <div>
                      <Button
                        variant="ghost"
                        size="sm"
                        className="w-full justify-between h-8 px-2"
                        onClick={() => setShowAgentsList(!showAgentsList)}
                      >
                        <span className="text-xs font-medium">
                          {showAgentsList ? 'Hide' : 'Show'} {workflowMetadata.agents.length} available agent{workflowMetadata.agents.length !== 1 ? 's' : ''}
                        </span>
                        {showAgentsList ? (
                          <ChevronDown className="h-3 w-3" />
                        ) : (
                          <ChevronRight className="h-3 w-3" />
                        )}
                      </Button>

                      {showAgentsList && (
                        <div className="mt-2 pt-2 mx-3 space-y-2">
                          {/* Scrollable agents list */}
                          <div className="relative">
                            {agentsScrollTop && (
                              <div className="absolute top-0 left-0 right-0 h-8 bg-gradient-to-b from-white to-transparent pointer-events-none z-10" />
                            )}
                            <div
                              className="max-h-48 overflow-y-auto space-y-1 pr-1"
                              onScroll={(e) => {
                                const target = e.currentTarget;
                                const isScrolledFromTop = target.scrollTop > 10;
                                const isScrolledToBottom = target.scrollHeight - target.scrollTop <= target.clientHeight + 10;
                                setAgentsScrollTop(isScrolledFromTop);
                                setAgentsScrollBottom(!isScrolledToBottom);
                              }}
                            >
                              <div className="space-y-1 space-x-6">
                                {workflowMetadata.agents.map((agent) => (
                                  <div key={agent.id} className="flex items-center gap-2 group">
                                    <span className="text-sm font-normal">
                                      {agent.name}
                                    </span>
                                    <Popover>
                                      <PopoverTrigger asChild>
                                        <button
                                          className="p-0.5 hover:bg-gray-100 rounded flex-shrink-0"
                                          onClick={(e) => {
                                            e.preventDefault();
                                            e.stopPropagation();
                                          }}
                                        >
                                          <Info className="h-3.5 w-3.5 text-muted-foreground" />
                                        </button>
                                      </PopoverTrigger>
                                      <PopoverContent className="max-w-xs" align="start">
                                        <div className="space-y-2">
                                          <p className="font-semibold text-sm">{agent.name}</p>
                                          <p className="text-xs text-muted-foreground">{agent.description}</p>
                                        </div>
                                      </PopoverContent>
                                    </Popover>
                                  </div>
                                ))}
                              </div>
                            </div>
                            {agentsScrollBottom && (
                              <div className="absolute bottom-0 left-0 right-0 h-8 bg-gradient-to-t from-white to-transparent pointer-events-none z-10" />
                            )}
                          </div>
                        </div>
                      )}
                    </div>
                  </div>
                )}

                {workflowMetadata?.agents?.length === 0 && (
                  <p className="text-xs text-muted-foreground text-left py-2">
                    No agents found in this workflow
                  </p>
                )}
              </>
            )}
            
            {/* Show activating/switching state */}
            {workflowActivating && (
              <Alert>
                <Loader2 className="h-4 w-4 animate-spin" />
                <AlertTitle>{activeWorkflow ? 'Switching Workflow...' : 'Activating Workflow...'}</AlertTitle>
                <AlertDescription>
                  <div className="space-y-2">
                    <p>Please wait. This may take 10-20 seconds...</p>
                  </div>
                </AlertDescription>
              </Alert>
            )}
          </div>
        )}
      </AccordionContent>
    </AccordionItem>
  );
}
</file>

<file path="components/frontend/src/app/projects/[name]/sessions/[sessionName]/not-found.tsx">
'use client';

import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { FileQuestion } from 'lucide-react';

export default function SessionNotFound() {
  return (
    <div className="container mx-auto p-6">
      <Card className="max-w-lg mx-auto mt-12">
        <CardHeader>
          <div className="flex items-center gap-2">
            <FileQuestion className="h-5 w-5 text-muted-foreground" />
            <CardTitle>Session not found</CardTitle>
          </div>
          <CardDescription>
            The session you&apos;re looking for doesn&apos;t exist or has been deleted.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <Button onClick={() => window.history.back()}>Go back</Button>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="components/frontend/src/app/projects/[name]/sessions/new/repository-dialog.tsx">
"use client";

import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { useGitHubForks, useRepoBranches } from "@/services/queries";

type Repo = {
  input: { url: string; branch: string };
  output?: { url: string; branch: string };
};

type RepositoryDialogProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  repo: Repo;
  onRepoChange: (repo: Repo) => void;
  onSave: () => void;
  isEditing: boolean;
  projectName: string;
};

export function RepositoryDialog({
  open,
  onOpenChange,
  repo,
  onRepoChange,
  onSave,
  isEditing,
  projectName,
}: RepositoryDialogProps) {
  const [forkOptions, setForkOptions] = useState<Array<{ fullName: string; url: string }>>([]);
  const [outputBranchMode, setOutputBranchMode] = useState<"same" | "auto">("auto");

  // Fetch forks using React Query - only when we have an input URL
  const { data: forksData } = useGitHubForks(projectName, repo.input.url);

  // Fetch branches for the input repository
  const { data: branchesData, isLoading: branchesLoading } = useRepoBranches(
    projectName,
    repo.input.url,
    { enabled: !!repo.input.url && open }
  );
  
  useEffect(() => {
    if (open && repo.input.url && forksData) {
      // Filter forks based on the input URL
      const filtered = forksData.filter(fork => {
        // Match fork URL with input URL
        return fork.url === repo.input.url || fork.fullName.includes(repo.input.url.split('/').pop() || '');
      });
      setForkOptions(filtered);
    }
  }, [open, repo.input.url, forksData]);

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle>{isEditing ? "Edit Repository" : "Add Repository"}</DialogTitle>
          <DialogDescription>Configure input and optional output repository settings</DialogDescription>
        </DialogHeader>
        <div className="space-y-4 py-4">
          <div className="space-y-2">
            <label className="text-sm font-medium">Input Repository URL</label>
            <Input
              placeholder="https://github.com/org/repo.git"
              value={repo.input.url}
              onChange={(e) => onRepoChange({ ...repo, input: { ...repo.input, url: e.target.value } })}
            />
          </div>
          <div className="space-y-2">
            <label className="text-sm font-medium">Input Branch</label>
            <Select
              value={repo.input.branch || "main"}
              onValueChange={(value) => onRepoChange({ ...repo, input: { ...repo.input, branch: value } })}
            >
              <SelectTrigger>
                <SelectValue placeholder={branchesLoading ? "Loading branches..." : "Select branch"} />
              </SelectTrigger>
              <SelectContent>
                {branchesLoading ? (
                  <SelectItem value="loading" disabled>Loading branches...</SelectItem>
                ) : branchesData?.branches && branchesData.branches.length > 0 ? (
                  branchesData.branches.map((branch) => (
                    <SelectItem key={branch.name} value={branch.name}>
                      {branch.name}
                    </SelectItem>
                  ))
                ) : (
                  <>
                    <SelectItem value="main">main</SelectItem>
                    <SelectItem value="master">master</SelectItem>
                    <SelectItem value="develop">develop</SelectItem>
                  </>
                )}
              </SelectContent>
            </Select>
            {!repo.input.url && (
              <p className="text-xs text-muted-foreground">Enter repository URL first to load branches</p>
            )}
          </div>
          <div className="space-y-2">
            <label className="text-sm font-medium">Output Repository (optional)</label>
            <Select
              value={repo.output?.url || "__none__"}
              onValueChange={(val) => {
                if (val === "__none__") {
                  onRepoChange({ ...repo, output: undefined });
                } else {
                  onRepoChange({
                    ...repo,
                    output: { url: val, branch: outputBranchMode === "same" ? repo.input.branch : "" },
                  });
                }
              }}
            >
              <SelectTrigger>
                <SelectValue
                  placeholder={repo.input.url ? "Select fork or same as input" : "Enter input repo first"}
                />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="__none__">No output (don&apos;t push)</SelectItem>
                {repo.input.url && <SelectItem value={repo.input.url}>Same as input</SelectItem>}
                {forkOptions.map((f) => (
                  <SelectItem key={f.fullName} value={f.url}>
                    {f.fullName}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            <p className="text-xs text-muted-foreground">Must be upstream or one of your forks</p>
          </div>
          {repo.output?.url && (
            <div className="space-y-2">
              <label className="text-sm font-medium">Output Branch</label>
              <Select
                value={outputBranchMode}
                onValueChange={(val: "same" | "auto") => {
                  setOutputBranchMode(val);
                  if (val === "same") {
                    onRepoChange({ ...repo, output: { ...repo.output!, branch: repo.input.branch } });
                  } else {
                    onRepoChange({ ...repo, output: { ...repo.output!, branch: "" } });
                  }
                }}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Select output branch mode" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="same">Same as input branch</SelectItem>
                  <SelectItem value="auto">Auto-generate sessions/&#123;&#123;session_id&#125;&#125;</SelectItem>
                </SelectContent>
              </Select>
              <p className="text-xs text-muted-foreground">To avoid conflicts, custom branches are not allowed</p>
            </div>
          )}
        </div>
        <div className="flex justify-end gap-2">
          <Button type="button" variant="outline" onClick={() => onOpenChange(false)}>
            Cancel
          </Button>
          <Button
            type="button"
            onClick={() => {
              if (!repo.input.url) return;
              onSave();
              onOpenChange(false);
            }}
          >
            {isEditing ? "Update" : "Add"}
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="components/frontend/src/app/projects/[name]/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { useParams, useSearchParams } from 'next/navigation';
import { Star, Settings, Users, RefreshCw } from 'lucide-react';
import { cn } from '@/lib/utils';

import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { PageHeader } from '@/components/page-header';
import { Breadcrumbs } from '@/components/breadcrumbs';

import { SessionsSection } from '@/components/workspace-sections/sessions-section';
import { SharingSection } from '@/components/workspace-sections/sharing-section';
import { SettingsSection } from '@/components/workspace-sections/settings-section';
import { useProject } from '@/services/queries/use-projects';

type Section = 'sessions' | 'sharing' | 'settings';

export default function ProjectDetailsPage() {
  const params = useParams();
  const searchParams = useSearchParams();
  const projectName = params?.name as string;
  
  // Fetch project data for display name and description
  const { data: project, isLoading: projectLoading } = useProject(projectName);
  
  // Initialize active section from query parameter or default to 'sessions'
  const initialSection = (searchParams.get('section') as Section) || 'sessions';
  const [activeSection, setActiveSection] = useState<Section>(initialSection);

  // Update active section when query parameter changes
  useEffect(() => {
    const sectionParam = searchParams.get('section') as Section;
    if (sectionParam && ['sessions', 'sharing', 'settings'].includes(sectionParam)) {
      setActiveSection(sectionParam);
    }
  }, [searchParams]);

  const navItems = [
    { id: 'sessions' as Section, label: 'Sessions', icon: Star },
    { id: 'sharing' as Section, label: 'Sharing', icon: Users },
    { id: 'settings' as Section, label: 'Workspace Settings', icon: Settings },
  ];

  // Loading state
  if (!projectName || projectLoading) {
    return (
      <div className="container mx-auto p-6">
        <div className="flex items-center justify-center h-64">
          <RefreshCw className="animate-spin h-8 w-8" />
          <span className="ml-2">Loading workspace...</span>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-[#f8fafc]">
      {/* Sticky header */}
      <div className="sticky top-0 z-20 bg-white border-b">
        <div className="container mx-auto px-6 py-4">
          <Breadcrumbs
            items={[
              { label: 'Workspaces', href: '/projects' },
              { label: projectName },
            ]}
            className="mb-4"
          />
          <PageHeader
            title={project?.displayName || projectName}
            description={project?.description || 'Workspace details and configuration'}
          />
        </div>
      </div>

      <div className="container mx-auto p-0">
        {/* Content */}
        <div className="px-6 pt-4 flex gap-6">
          {/* Sidebar Navigation */}
          <aside className="w-56 shrink-0">
            <Card>
              <CardHeader>
                <CardTitle>Workspace</CardTitle>
              </CardHeader>
              <CardContent className="px-4 pb-4 pt-2">
                <div className="space-y-1">
                  {navItems.map((item) => {
                    const isActive = activeSection === item.id;
                    const Icon = item.icon;
                    return (
                      <Button
                        key={item.id}
                        variant={isActive ? "secondary" : "ghost"}
                        className={cn("w-full justify-start", isActive && "font-semibold")}
                        onClick={() => setActiveSection(item.id)}
                      >
                        <Icon className="w-4 h-4 mr-2" />
                        {item.label}
                      </Button>
                    );
                  })}
                </div>
              </CardContent>
            </Card>
          </aside>

          {/* Main Content */}
          {activeSection === 'sessions' && <SessionsSection projectName={projectName} />}
          {activeSection === 'sharing' && <SharingSection projectName={projectName} />}
          {activeSection === 'settings' && <SettingsSection projectName={projectName} />}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/frontend/src/app/projects/error.tsx">
'use client';

import { useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { AlertCircle } from 'lucide-react';

export default function ProjectsError({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    console.error('Projects page error:', error);
  }, [error]);

  return (
    <div className="container mx-auto p-6">
      <Card className="max-w-lg mx-auto mt-12">
        <CardHeader>
          <div className="flex items-center gap-2">
            <AlertCircle className="h-5 w-5 text-destructive" />
            <CardTitle>Failed to load projects</CardTitle>
          </div>
          <CardDescription>
            {error.message || 'An unexpected error occurred while loading workspaces.'}
          </CardDescription>
        </CardHeader>
        <CardContent>
          <Button onClick={reset}>Try again</Button>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="components/frontend/src/app/globals.css">
@import "tailwindcss";
@import "tw-animate-css";
@import "highlight.js/styles/github-dark.css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.5 0.22 264);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.5 0.22 264);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.6 0.2 264);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

/* Thin scrollbar styling */
.scrollbar-thin {
  scrollbar-width: thin;
  scrollbar-color: #d1d5db #f3f4f6;
}
</file>

<file path="components/frontend/src/app/loading.tsx">
import { Loader2 } from 'lucide-react';

export default function RootLoading() {
  return (
    <div className="flex items-center justify-center min-h-screen">
      <div className="flex flex-col items-center gap-4">
        <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
        {/* <p className="text-sm text-muted-foreground">Loading...</p> */}
      </div>
    </div>
  );
}
</file>

<file path="components/frontend/src/components/session/OverviewTab.tsx">
"use client";

import React from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Brain, Clock, RefreshCw, Sparkle, ExternalLink, Box, Container, HardDrive } from "lucide-react";
import { format } from "date-fns";
import { cn } from "@/lib/utils";
import type { AgenticSession } from "@/types/agentic-session";
import type { SessionMessage } from "@/types";

type Props = {
  session: AgenticSession;
  promptExpanded: boolean;
  setPromptExpanded: (v: boolean) => void;
  latestLiveMessage: SessionMessage | null;
  diffTotals: Record<number, { total_added: number; total_removed: number }>;
  onPush: (repoIndex: number) => Promise<void>;
  onAbandon: (repoIndex: number) => Promise<void>;
  busyRepo: Record<number, 'push' | 'abandon' | null>;
  buildGithubCompareUrl: (inUrl: string, inBranch?: string, outUrl?: string, outBranch?: string) => string | null;
  onRefreshDiff: () => Promise<void>;
  k8sResources?: {
    jobName?: string;
    jobStatus?: string;
    pods?: Array<{
      name: string;
      phase: string;
      containers: Array<{
        name: string;
        state: string;
        exitCode?: number;
        reason?: string;
      }>;
      isTempPod?: boolean;
    }>;
    pvcName?: string;
    pvcExists?: boolean;
    pvcSize?: string;
  };
};

// Utility to generate OpenShift console URLs
const getOpenShiftConsoleUrl = (namespace: string, resourceType: 'Job' | 'Pod' | 'PVC', resourceName: string): string | null => {
  // Try to derive console URL from current window location
  // OpenShift console is typically at console-openshift-console.apps.<cluster-domain>
  const hostname = window.location.hostname;
  
  // Check if we're on an OpenShift route (apps.*)
  if (hostname.includes('.apps.')) {
    const clusterDomain = hostname.split('.apps.')[1];
    const consoleUrl = `https://console-openshift-console.apps.${clusterDomain}`;
    
    const resourceMap = {
      'Job': 'batch~v1~Job',
      'Pod': 'core~v1~Pod',
      'PVC': 'core~v1~PersistentVolumeClaim',
    };
    
    return `${consoleUrl}/k8s/ns/${namespace}/${resourceMap[resourceType]}/${resourceName}`;
  }
  
  // Fallback: For local development or non-standard setups, return null
  return null;
};

export const OverviewTab: React.FC<Props> = ({ session, promptExpanded, setPromptExpanded, latestLiveMessage, diffTotals, onPush, onAbandon, busyRepo, buildGithubCompareUrl, onRefreshDiff, k8sResources }) => {
  const [refreshingDiff, setRefreshingDiff] = React.useState(false);
  const [expandedPods, setExpandedPods] = React.useState<Record<string, boolean>>({});
  
  const projectNamespace = session.metadata?.namespace || '';
  
  const getStatusColor = (status: string) => {
    const lower = status.toLowerCase();
    if (lower.includes('running') || lower.includes('active')) return 'bg-blue-100 text-blue-800 border-blue-300';
    if (lower.includes('succeeded') || lower.includes('completed')) return 'bg-green-100 text-green-800 border-green-300';
    if (lower.includes('failed') || lower.includes('error')) return 'bg-red-100 text-red-800 border-red-300';
    if (lower.includes('waiting') || lower.includes('pending')) return 'bg-yellow-100 text-yellow-800 border-yellow-300';
    if (lower.includes('terminating')) return 'bg-purple-100 text-purple-800 border-purple-300';
    if (lower.includes('notfound') || lower.includes('not found')) return 'bg-orange-100 text-orange-800 border-orange-300';
    if (lower.includes('terminated')) return 'bg-gray-100 text-gray-800 border-gray-300';
    return 'bg-gray-100 text-gray-800 border-gray-300';
  };
  
  return (
    <div className="space-y-6">
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center">
              <Brain className="w-5 h-5 mr-2" />
              Initial Prompt
            </CardTitle>
          </CardHeader>
          <CardContent>
            {(() => {
              const promptText = session.spec.prompt || "";
              const promptIsLong = promptText.length > 400;
              return (
                <>
                  <div className={cn("relative", !promptExpanded && promptIsLong ? "max-h-40 overflow-hidden" : "")}>
                    <p className="whitespace-pre-wrap text-sm">{promptText}</p>
                    {!promptExpanded && promptIsLong ? (
                      <div className="absolute inset-x-0 bottom-0 h-12 bg-gradient-to-t from-white to-transparent pointer-events-none" />
                    ) : null}
                  </div>
                  {promptIsLong && (
                    <button
                      className="mt-2 text-xs text-blue-600 hover:underline"
                      onClick={() => setPromptExpanded(!promptExpanded)}
                      aria-expanded={promptExpanded}
                      aria-controls="initial-prompt"
                    >
                      {promptExpanded ? "View less" : "View more"}
                    </button>
                  )}
                </>
              );
            })()}
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <div className="flex items-center justify-between">
              <CardTitle>Latest Message</CardTitle>
            </div>
          </CardHeader>
          <CardContent>
            {latestLiveMessage ? (
              <div className="space-y-2 text-sm">
                <div className="flex items-center gap-2">
                  <Badge variant="outline" className="text-xs">{latestLiveMessage.type}</Badge>
                  <span className="text-xs text-gray-500">{new Date(latestLiveMessage.timestamp).toLocaleTimeString()}</span>
                </div>
                <div className="relative max-h-40 overflow-hidden">
                  <pre className="whitespace-pre-wrap break-words bg-gray-50 rounded p-2 text-xs text-gray-800">{JSON.stringify(latestLiveMessage.payload, null, 2)}</pre>
                  <div className="absolute inset-x-0 bottom-0 h-12 bg-gradient-to-t from-white to-transparent pointer-events-none" />
                </div>
              </div>
            ) : (
              <div className="text-sm text-gray-500">No messages yet</div>
            )}
          </CardContent>
        </Card>
      </div>

      <div className="grid grid-cols-1 gap-6">
        {session.status && (
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center">
                <Clock className="w-5 h-5 mr-2" />
                System Status & Configuration
              </CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-4 text-sm">
                <div>
                  <div className="text-xs font-semibold text-muted-foreground mb-2">Runtime</div>
                  <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                    {session.status.message && (
                      <div>
                        <p className="font-semibold">Status</p>
                        <p className="text-muted-foreground">{session.status.message}</p>
                      </div>
                    )}
                    {session.status.startTime && (
                      <div>
                        <p className="font-semibold">Started</p>
                        <p className="text-muted-foreground">{format(new Date(session.status.startTime), "PPp")}</p>
                      </div>
                    )}
                    {session.status.completionTime && (
                      <div>
                        <p className="font-semibold">Completed</p>
                        <p className="text-muted-foreground">{format(new Date(session.status.completionTime), "PPp")}</p>
                      </div>
                    )}
                    {session.status.jobName && (
                      <div>
                        <p className="font-semibold">K8s Job</p>
                        <div className="flex items-center gap-2">
                          <p className="text-muted-foreground font-mono text-xs">{session.status.jobName}</p>
                          <Badge variant="outline" className={session.spec?.interactive ? "bg-green-50 text-green-700 border-green-200" : "bg-gray-50 text-gray-700 border-gray-200"}>
                            {session.spec?.interactive ? "Interactive" : "Headless"}
                          </Badge>
                        </div>
                      </div>
                    )}
                  </div>
                </div>

                <div>
                  <div className="text-xs font-semibold text-muted-foreground mb-2">LLM Config</div>
                  <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <div>
                      <p className="font-semibold">Model</p>
                      <p className="text-muted-foreground">{session.spec.llmSettings.model}</p>
                    </div>
                    <div>
                      <p className="font-semibold">Temperature</p>
                      <p className="text-muted-foreground">{session.spec.llmSettings.temperature}</p>
                    </div>
                    <div>
                      <p className="font-semibold">Max Tokens</p>
                      <p className="text-muted-foreground">{session.spec.llmSettings.maxTokens}</p>
                    </div>
                    <div>
                      <p className="font-semibold">Timeout</p>
                      <p className="text-muted-foreground">{session.spec.timeout}s</p>
                    </div>
                  </div>
                </div>

                {k8sResources && (
                  <div>
                    <div className="text-xs font-semibold text-muted-foreground mb-2">Kubernetes Resources</div>
                    <div className="space-y-2">
                      {/* PVC - Always shown at root level (owned by AgenticSession CR) */}
                      {k8sResources.pvcName && (
                        <div className="flex items-center gap-2">
                          <Badge variant="outline" className="text-xs">
                            <HardDrive className="w-3 h-3 mr-1" />
                            PVC
                          </Badge>
                          {(() => {
                            const consoleUrl = getOpenShiftConsoleUrl(projectNamespace, 'PVC', k8sResources.pvcName);
                            return consoleUrl ? (
                              <a
                                href={consoleUrl}
                                target="_blank"
                                rel="noopener noreferrer"
                                className="font-mono text-xs text-blue-600 hover:text-blue-800 hover:underline flex items-center gap-1"
                              >
                                {k8sResources.pvcName}
                                <ExternalLink className="w-3 h-3" />
                              </a>
                            ) : (
                              <span className="font-mono text-xs">{k8sResources.pvcName}</span>
                            );
                          })()}
                          <Badge className={`text-xs ${k8sResources.pvcExists ? 'bg-green-100 text-green-800 border-green-300' : 'bg-red-100 text-red-800 border-red-300'}`}>
                            {k8sResources.pvcExists ? 'Exists' : 'Not Found'}
                          </Badge>
                          {k8sResources.pvcSize && <span className="text-xs text-gray-500">{k8sResources.pvcSize}</span>}
                        </div>
                      )}
                      
                      {/* Temp Content Pods - Always at root level (for completed sessions) */}
                      {k8sResources.pods && k8sResources.pods.filter(p => p.isTempPod).map((pod) => (
                        <div key={pod.name} className="space-y-1">
                          <div className="flex items-center gap-2">
                            <button
                              onClick={() => setExpandedPods(prev => ({ ...prev, [pod.name]: !prev[pod.name] }))}
                              className="text-xs text-blue-600 hover:underline flex items-center gap-1"
                            >
                              {expandedPods[pod.name] ? 'Hide' : 'Show'}
                            </button>
                            <Badge variant="outline" className="text-xs">
                              <Container className="w-3 h-3 mr-1" />
                              Temp Pod
                            </Badge>
                            {(() => {
                              const consoleUrl = getOpenShiftConsoleUrl(projectNamespace, 'Pod', pod.name);
                              return consoleUrl ? (
                                <a
                                  href={consoleUrl}
                                  target="_blank"
                                  rel="noopener noreferrer"
                                  className="font-mono text-xs text-blue-600 hover:text-blue-800 hover:underline flex items-center gap-1 truncate max-w-[250px]"
                                  title={pod.name}
                                >
                                  {pod.name}
                                  <ExternalLink className="w-3 h-3 flex-shrink-0" />
                                </a>
                              ) : (
                                <span className="font-mono text-xs truncate max-w-[250px]" title={pod.name}>
                                  {pod.name}
                                </span>
                              );
                            })()}
                            <Badge className={`text-xs ${getStatusColor(pod.phase)}`}>
                              {pod.phase}
                            </Badge>
                            <Badge variant="outline" className="text-xs bg-purple-50 text-purple-700 border-purple-200">
                              Workspace viewer
                            </Badge>
                          </div>
                          
                          {/* Temp pod containers */}
                          {expandedPods[pod.name] && pod.containers && pod.containers.length > 0 && (
                            <div className="ml-4 space-y-1 border-l-2 border-gray-200 pl-3">
                              {pod.containers.map((container) => (
                                <div key={container.name} className="flex items-center gap-2">
                                  <Badge variant="outline" className="text-xs">
                                    <Box className="w-3 h-3 mr-1" />
                                    {container.name}
                                  </Badge>
                                  <Badge className={`text-xs ${getStatusColor(container.state)}`}>
                                    {container.state}
                                  </Badge>
                                  {container.exitCode !== undefined && (
                                    <span className="text-xs text-gray-500">Exit: {container.exitCode}</span>
                                  )}
                                  {container.reason && (
                                    <span className="text-xs text-gray-500">({container.reason})</span>
                                  )}
                                </div>
                              ))}
                            </div>
                          )}
                        </div>
                      ))}
                      
                      {/* Job - Only shown when job exists */}
                      {k8sResources.jobName && (
                      <div className="text-xs space-y-1">
                        <div className="flex items-center gap-2">
                          <Badge variant="outline" className="text-xs">
                            <Box className="w-3 h-3 mr-1" />
                            Job
                          </Badge>
                          {(() => {
                            const consoleUrl = getOpenShiftConsoleUrl(projectNamespace, 'Job', k8sResources.jobName);
                            return consoleUrl ? (
                              <a
                                href={consoleUrl}
                                target="_blank"
                                rel="noopener noreferrer"
                                className="font-mono text-xs text-blue-600 hover:text-blue-800 hover:underline flex items-center gap-1"
                              >
                                {k8sResources.jobName}
                                <ExternalLink className="w-3 h-3" />
                              </a>
                            ) : (
                              <span className="font-mono text-xs">{k8sResources.jobName}</span>
                            );
                          })()}
                          <Badge className={`text-xs ${getStatusColor(k8sResources.jobStatus || 'Unknown')}`}>
                            {k8sResources.jobStatus || 'Unknown'}
                          </Badge>
                        </div>
                        
                        {/* Job Pods - Only non-temp pods */}
                        {k8sResources.pods && k8sResources.pods.filter(p => !p.isTempPod).length > 0 && (
                          <div className="ml-4 space-y-1 border-l-2 border-gray-200 pl-3">
                            {k8sResources.pods.filter(p => !p.isTempPod).map((pod) => (
                              <div key={pod.name} className="space-y-1">
                                <div className="flex items-center gap-2">
                                  <button
                                    onClick={() => setExpandedPods(prev => ({ ...prev, [pod.name]: !prev[pod.name] }))}
                                    className="text-xs text-blue-600 hover:underline flex items-center gap-1"
                                  >
                                    {expandedPods[pod.name] ? 'Hide' : 'Show'}
                                  </button>
                                  <Badge variant="outline" className="text-xs">
                                    <Container className="w-3 h-3 mr-1" />
                                    Pod
                                  </Badge>
                                  {(() => {
                                    const consoleUrl = getOpenShiftConsoleUrl(projectNamespace, 'Pod', pod.name);
                                    return consoleUrl ? (
                                      <a
                                        href={consoleUrl}
                                        target="_blank"
                                        rel="noopener noreferrer"
                                        className="font-mono text-xs text-blue-600 hover:text-blue-800 hover:underline flex items-center gap-1 truncate max-w-[200px]"
                                        title={pod.name}
                                      >
                                        {pod.name}
                                        <ExternalLink className="w-3 h-3 flex-shrink-0" />
                                      </a>
                                    ) : (
                                      <span className="font-mono text-xs truncate max-w-[200px]" title={pod.name}>
                                        {pod.name}
                                      </span>
                                    );
                                  })()}
                                  <Badge className={`text-xs ${getStatusColor(pod.phase)}`}>
                                    {pod.phase}
                                  </Badge>
                                  {pod.isTempPod && (
                                    <Badge variant="outline" className="text-xs bg-purple-50 text-purple-700 border-purple-200">
                                      Workspace viewer
                                    </Badge>
                                  )}
                                </div>
                                
                                {expandedPods[pod.name] && pod.containers && (
                                  <div className="ml-4 space-y-1 border-l-2 border-gray-200 pl-3">
                                    {pod.containers.map((container) => (
                                      <div key={container.name} className="flex items-center gap-2">
                                        <Badge variant="outline" className="text-xs">
                                          <Box className="w-3 h-3 mr-1" />
                                          {container.name}
                                        </Badge>
                                        <Badge className={`text-xs ${getStatusColor(container.state)}`}>
                                          {container.state}
                                        </Badge>
                                        {container.exitCode !== undefined && (
                                          <span className="text-xs text-gray-500">Exit: {container.exitCode}</span>
                                        )}
                                        {container.reason && (
                                          <span className="text-xs text-gray-500">({container.reason})</span>
                                        )}
                                      </div>
                                    ))}
                                  </div>
                                )}
                              </div>
                            ))}
                          </div>
                        )}
                      </div>
                      )}
                    </div>
                  </div>
                )}

                <div>
                  <div className="flex items-center justify-between mb-2">
                    <div className="text-xs font-semibold text-muted-foreground">Repositories</div>
                    <Button
                      size="sm"
                      variant="ghost"
                      onClick={async () => {
                        setRefreshingDiff(true);
                        try {
                          await onRefreshDiff();
                        } finally {
                          setRefreshingDiff(false);
                        }
                      }}
                      disabled={refreshingDiff}
                      className="h-6 px-2"
                    >
                      <RefreshCw className={cn("h-3 w-3", refreshingDiff && "animate-spin")} />
                    </Button>
                  </div>
                  {session.spec.repos && session.spec.repos.length > 0 ? (
                    <div className="space-y-2">
                      {session.spec.repos.map((repo, idx) => {
                        const isMain = session.spec.mainRepoIndex === idx;
                        // Use the actual output branch, or default to sessions/{sessionName}
                        const outBranch = repo.output?.branch && repo.output.branch.trim() && repo.output.branch !== 'auto' 
                          ? repo.output.branch 
                          : `sessions/${session.metadata.name}`;
                        const compareUrl = buildGithubCompareUrl(repo.input.url, repo.input.branch || 'main', repo.output?.url, outBranch);
                        
                        // Check if temp pod is running and ready
                        const tempPod = k8sResources?.pods?.find(p => p.isTempPod);
                        const tempPodReady = tempPod?.phase === 'Running';
                        
                        const br = diffTotals[idx] || { total_added: 0, total_removed: 0 };
                        const hasChanges = tempPodReady && (br.total_added > 0 || br.total_removed > 0);
                        return (
                          <div key={idx} className="flex items-center gap-2 text-sm font-mono">
                            {isMain && <span className="text-xs bg-primary/10 text-primary px-2 py-0.5 rounded font-sans">MAIN</span>}
                            <span className="text-muted-foreground break-all">{repo.input.url}</span>
                            <span className="text-xs bg-primary/10 text-primary px-2 py-0.5 rounded font-sans">{repo.input.branch || "main"}</span>
                            <span className="text-muted-foreground"></span>
                            <span className="text-muted-foreground break-all">{repo.output?.url || "(no push)"}</span>
                            {repo.output?.url && (
                              <span className="text-xs bg-primary/10 text-primary px-2 py-0.5 rounded font-sans">{repo.output?.branch || (
                                <div className="flex items-center gap-1">
                                <Sparkle
                                className="h-3 w-3 text-muted-foreground"
                                />
                                auto
                                </div>
                               )}</span>
                            )}
                            {repo.status && (
                              <span className="text-xs px-2 py-0.5 rounded font-sans border border-muted-foreground/20">
                                {repo.status}
                              </span>
                            )}
                            <span className="flex-1" />
                            
                            {!tempPodReady ? (
                              <span className="text-xs text-muted-foreground italic">
                                (read-only - temp service not running)
                              </span>
                            ) : !hasChanges ? (
                              repo.status === 'pushed' && compareUrl ? (
                                <a 
                                  href={compareUrl} 
                                  target="_blank" 
                                  rel="noreferrer" 
                                  className="flex items-center gap-1 text-xs text-blue-600 hover:underline"
                                >
                                  Compare
                                  <ExternalLink className="h-3 w-3" />
                                </a>
                              ) : (
                                <span className="text-xs text-muted-foreground">no diff</span>
                              )
                            ) : (
                              <span className="flex items-center gap-2">
                                {br.total_added > 0 && (
                                  <span className="text-xs px-1 py-0.5 rounded border bg-green-50 text-green-700 border-green-200">
                                    +{br.total_added}
                                  </span>
                                )}
                                {br.total_removed > 0 && (
                                  <span className="text-xs px-1 py-0.5 rounded border bg-red-50 text-red-700 border-red-200">
                                    -{br.total_removed}
                                  </span>
                                )}
                              </span>
                            )}
                            {hasChanges && compareUrl && repo.status === 'pushed' ? (
                              <a 
                                href={compareUrl} 
                                target="_blank" 
                                rel="noreferrer" 
                                className="flex items-center gap-1 text-xs text-blue-600 hover:underline"
                              >
                                Compare
                                <ExternalLink className="h-3 w-3" />
                              </a>
                            ) : null}
                            {hasChanges && tempPodReady && (
                              repo.output?.url ? (
                                <div className="flex items-center gap-2">
                                  <Button size="sm" variant="secondary" onClick={() => onPush(idx)} disabled={!tempPodReady}>{busyRepo[idx] === 'push' ? 'Pushing' : 'Push'}</Button>
                                  <Button size="sm" variant="outline" onClick={() => onAbandon(idx)} disabled={!tempPodReady}>{busyRepo[idx] === 'abandon' ? 'Abandoning' : 'Abandon'}</Button>
                                </div>
                              ) : (
                                <Button size="sm" variant="outline" onClick={() => onAbandon(idx)} disabled={!tempPodReady}>{busyRepo[idx] === 'abandon' ? 'Abandoning' : 'Abandon changes'}</Button>
                              )
                            )}
                          </div>
                        );
                      })}
                    </div>
                  ) : (
                    <p className="text-muted-foreground">No repositories configured</p>
                  )}
                </div>
              </div>
            </CardContent>
          </Card>
        )}
      </div>
    </div>
  );
};

export default OverviewTab;
</file>

<file path="components/frontend/src/components/session/ResultsTab.tsx">
"use client";

import React from "react";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";
import rehypeHighlight from "rehype-highlight";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";

type ResultMeta = {
  subtype?: string;
  duration_ms?: number;
  duration_api_ms?: number;
  is_error?: boolean;
  num_turns?: number;
  session_id?: string;
  total_cost_usd?: number | null;
  usage?: Record<string, unknown> | null;
};

type Props = {
  result?: string | null;
  meta?: ResultMeta | null;
  components?: Record<string, React.ComponentType<unknown>>;
};

const ResultsTab: React.FC<Props> = ({ result, meta, components }) => {
  if (!result && !meta) return <div className="text-sm text-muted-foreground">No artifacts yet</div>;
  return (
    <Card>
      <CardHeader>
        <CardTitle>
          Agent Artifacts
        </CardTitle>
      </CardHeader>
      <CardContent>
        {result ? (
          <div className="bg-white rounded-lg prose prose-sm max-w-none prose-headings:text-gray-900 prose-p:text-gray-700 prose-strong:text-gray-900 prose-code:bg-gray-100 prose-code:px-1 prose-code:py-0.5 prose-code:rounded prose-pre:bg-gray-900 prose-pre:text-gray-100">
            <ReactMarkdown remarkPlugins={[remarkGfm]} rehypePlugins={[rehypeHighlight]} components={components}>
              {result}
            </ReactMarkdown>
          </div>
        ) : null}

        {meta ? (
          <div className="mt-4 border rounded-md p-3 bg-white">
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-3 text-sm">
              {typeof meta.subtype === 'string' && meta.subtype ? (
                <div>
                  <div className="text-xs text-muted-foreground">Status</div>
                  <div className="font-medium capitalize">{meta.subtype}{meta.is_error ? " (error)" : ""}</div>
                </div>
              ) : null}
              {typeof meta.num_turns === 'number' ? (
                <div>
                  <div className="text-xs text-muted-foreground">Turns</div>
                  <div className="font-medium">{meta.num_turns}</div>
                </div>
              ) : null}
              {typeof meta.duration_ms === 'number' ? (
                <div>
                  <div className="text-xs text-muted-foreground">Duration</div>
                  <div className="font-medium">{meta.duration_ms} ms</div>
                </div>
              ) : null}
              {typeof meta.duration_api_ms === 'number' ? (
                <div>
                  <div className="text-xs text-muted-foreground">API Time</div>
                  <div className="font-medium">{meta.duration_api_ms} ms</div>
                </div>
              ) : null}
              {typeof meta.total_cost_usd === 'number' ? (
                <div>
                  <div className="text-xs text-muted-foreground">Cost (USD)</div>
                  <div className="font-medium">${meta.total_cost_usd.toFixed(6)}</div>
                </div>
              ) : null}
              {typeof meta.session_id === 'string' && meta.session_id ? (
                <div className="sm:col-span-2">
                  <div className="text-xs text-muted-foreground">Session ID</div>
                  <div className="font-mono text-xs break-all">{meta.session_id}</div>
                </div>
              ) : null}
            </div>

            {meta.usage ? (
              <div className="mt-3">
                <div className="text-xs text-muted-foreground mb-1">Usage</div>
                <pre className="bg-gray-900 text-gray-100 rounded p-3 text-xs overflow-auto"><code>{JSON.stringify(meta.usage, null, 2)}</code></pre>
              </div>
            ) : null}
          </div>
        ) : null}
      </CardContent>
    </Card>
  );
};

export default ResultsTab;
</file>

<file path="components/frontend/src/components/ui/accordion.tsx">
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronRight } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-90",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRight className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))

AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }
</file>

<file path="components/frontend/src/components/ui/dialog.tsx">
"use client";

import * as React from "react";
import { createPortal } from "react-dom";
import { X } from "lucide-react";
import { cn } from "@/lib/utils";

type DialogProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  children: React.ReactNode;
};

const DialogContext = React.createContext<{
  open: boolean;
  onOpenChange: (open: boolean) => void;
}>({ open: false, onOpenChange: () => {} });

const Dialog: React.FC<DialogProps> = ({ open, onOpenChange, children }) => {
  return (
    <DialogContext.Provider value={{ open, onOpenChange }}>
      {children}
    </DialogContext.Provider>
  );
};

const DialogTrigger = React.forwardRef<
  HTMLButtonElement,
  React.ButtonHTMLAttributes<HTMLButtonElement>
>(({ children, onClick, ...props }, ref) => {
  return (
    <button ref={ref} onClick={onClick} {...props}>
      {children}
    </button>
  );
});
DialogTrigger.displayName = "DialogTrigger";

const DialogContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, children, ...props }, ref) => {
  const { open, onOpenChange } = React.useContext(DialogContext);
  const [mounted, setMounted] = React.useState(false);

  React.useEffect(() => {
    setMounted(true);
    return () => setMounted(false);
  }, []);

  if (!open || !mounted) return null;

  const content = (
    <div className="fixed inset-0 z-50">
      <div
        className="fixed inset-0 z-50 bg-black/50 backdrop-blur-sm"
        onClick={() => onOpenChange(false)}
      />
      <div className="fixed left-1/2 top-1/2 z-[60] -translate-x-1/2 -translate-y-1/2">
        <div
          ref={ref}
          className={cn(
            "w-full max-w-lg bg-white rounded-lg border shadow-lg p-6 relative",
            className
          )}
          {...props}
        >
          {children}
          <button
            onClick={() => onOpenChange(false)}
            className="absolute right-4 top-4 rounded-sm opacity-70 hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-blue-500"
          >
            <X className="h-4 w-4" />
            <span className="sr-only">Close</span>
          </button>
        </div>
      </div>
    </div>
  );

  return createPortal(content, document.body);
});
DialogContent.displayName = "DialogContent";

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left mb-4",
      className
    )}
    {...props}
  />
);
DialogHeader.displayName = "DialogHeader";

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2 mt-6",
      className
    )}
    {...props}
  />
);
DialogFooter.displayName = "DialogFooter";

const DialogTitle = React.forwardRef<
  HTMLHeadingElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h2
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
));
DialogTitle.displayName = "DialogTitle";

const DialogDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-gray-600", className)}
    {...props}
  />
));
DialogDescription.displayName = "DialogDescription";

export {
  Dialog,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
};

export type { DialogProps };
</file>

<file path="components/frontend/src/components/ui/stream-message.tsx">
"use client";

import React from "react";
import { MessageObject, ToolUseMessages } from "@/types/agentic-session";
import { LoadingDots, Message } from "@/components/ui/message";
import { ToolMessage } from "@/components/ui/tool-message";
import { ThinkingMessage } from "@/components/ui/thinking-message";
import { SystemMessage } from "@/components/ui/system-message";
import { Button } from "@/components/ui/button";

export type StreamMessageProps = {
  message: MessageObject | ToolUseMessages;
  onGoToResults?: () => void;
  plainCard?: boolean;
  isNewest?: boolean;
};

const getRandomAgentMessage = () => {
  const messages = [
    "The agents are working together on your request...",
    "One agent is going on a tangent, the others are reeling them back in...",
    "The agents are collaborating in perfect harmony...",
    "One agent wishes it could touch grass...",
    "The agents are debating the best approach (it's getting heated)...",
    "The agents scheduled a standup, but then realized they don't have feet...",
    "One agent suggested a pivot to blockchain, but the others vetoed it...",
    "The agents are having a productive meeting...",
    "One agent is caffeinated and the others are trying to keep up...",
    "The agents are brainstorming (if you can call it that)...",
  ];
  return messages[Math.floor(Math.random() * messages.length)];
};

export const StreamMessage: React.FC<StreamMessageProps> = ({ message, onGoToResults, plainCard=false, isNewest=false }) => {
  const isToolUsePair = (m: MessageObject | ToolUseMessages): m is ToolUseMessages =>
    m != null && typeof m === "object" && "toolUseBlock" in m && "resultBlock" in m;

  if (isToolUsePair(message)) {
    return <ToolMessage toolUseBlock={message.toolUseBlock} resultBlock={message.resultBlock} />;
  }

  const m = message as MessageObject;
  switch (m.type) {
    case "agent_running": {
      if (!isNewest) return null;
      return <LoadingDots />;
    }
    case "agent_waiting": {
      if (!isNewest) return null;
      return (
        <span className="text-xs text-gray-500">{getRandomAgentMessage()}</span>
      )
    }
    case "user_message":
    case "agent_message": {
      if (typeof m.content === "string") {
        return <Message role={m.type === "agent_message" ? "bot" : "user"} content={m.content} name="Claude AI" borderless={plainCard}/>;
      }
      switch (m.content.type) {
        case "thinking_block":
          return <ThinkingMessage block={m.content} />
        case "text_block":
          return <Message role={m.type === "agent_message" ? "bot" : "user"} content={m.content.text} name="Claude AI" borderless={plainCard}/>
        case "tool_use_block":
          return <ToolMessage toolUseBlock={m.content} borderless={plainCard}/>
        case "tool_result_block":
          return <ToolMessage resultBlock={m.content} borderless={plainCard}/>
      }
    }
    case "system_message": {
      return <SystemMessage subtype={m.subtype} data={m.data} borderless={plainCard}/>;
    }
    case "result_message": {
      // Show a minimal message with an action to open full results tab
      return (
        <Message
          borderless={plainCard}
          role="bot"
          content={m.is_error ? "Agent completed with errors." : "Agent completed successfully."}
          name="Claude AI"
          actions={
            <div className="flex items-center justify-between">
              <div className="text-xs text-gray-500">
                Duration: {m.duration_ms} ms  API: {m.duration_api_ms} ms  Turns: {m.num_turns}
              </div>
              <Button variant='link' size="sm" className="ml-3" onClick={onGoToResults}>Go to Results</Button>
            </div>
          }
        />
      );
    }
    default:
      return null;
  }
};

export default StreamMessage;
</file>

<file path="components/frontend/src/components/ui/toast.tsx">
"use client"

import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 right-0 z-[100] flex max-h-screen w-full flex-col-reverse gap-2 p-4 md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        success: "border-green-500 bg-green-50 text-green-900 dark:bg-green-900 dark:text-green-50",
        destructive:
          "destructive border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}
</file>

<file path="components/frontend/src/components/ui/tool-message.tsx">
"use client";

import React, { useState } from "react";
import { cn } from "@/lib/utils";
import { Badge } from "@/components/ui/badge";
import { ToolResultBlock, ToolUseBlock } from "@/types/agentic-session";
import {
  ChevronDown,
  ChevronRight,
  Loader2,
  Check,
  X,
  Cog,
} from "lucide-react";
import ReactMarkdown from "react-markdown";
import type { Components } from "react-markdown";
import remarkGfm from "remark-gfm";

export type ToolMessageProps = {
  toolUseBlock?: ToolUseBlock;
  resultBlock?: ToolResultBlock;
  className?: string;
  borderless?: boolean;
};

const formatToolName = (toolName?: string) => {
  if (!toolName) return "Unknown Tool";
  // Remove mcp__ prefix and format nicely
  return toolName
    .replace(/^mcp__/, "")
    .replace(/_/g, " ")
    .split(" ")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(" ");
};

const formatToolInput = (input?: string) => {
  if (!input) return "{}";
  try {
    const parsed = JSON.parse(input);
    return JSON.stringify(parsed, null, 2);
  } catch {
    return input;
  }
};

type ExpandableMarkdownProps = {
  content: string;
  maxLength?: number;
  className?: string;
};

const ExpandableMarkdown: React.FC<ExpandableMarkdownProps> = ({
  content,
  maxLength = 2000,
  className,
}) => {
  const [expanded, setExpanded] = useState(false);
  const shouldTruncate = content.length > maxLength;
  const display = expanded || !shouldTruncate ? content : content.substring(0, maxLength);

  // Match Message.tsx rendering so headers/code look correct
  const markdownComponents: Components = {
    code: ({
      inline,
      className,
      children,
      ...props
    }: {
      inline?: boolean;
      className?: string;
      children?: React.ReactNode;
    } & React.HTMLAttributes<HTMLElement>) => {
      return inline ? (
        <code className="bg-gray-100 px-1 py-0.5 rounded text-xs" {...(props as React.HTMLAttributes<HTMLElement>)}>
          {children}
        </code>
      ) : (
        <pre className="bg-gray-800 text-gray-100 p-2 rounded text-xs overflow-x-auto">
          <code className={className} {...(props as React.HTMLAttributes<HTMLElement>)}>
            {children}
          </code>
        </pre>
      );
    },
    p: ({ children }) => <p className="text-gray-600 leading-relaxed mb-2 text-sm">{children}</p>,
    h1: ({ children }) => <h1 className="text-lg font-bold text-gray-800 mb-2">{children}</h1>,
    h2: ({ children }) => <h2 className="text-md font-semibold text-gray-800 mb-2">{children}</h2>,
    h3: ({ children }) => <h3 className="text-sm font-medium text-gray-800 mb-1">{children}</h3>,
  };

  return (
    <div className={cn("max-w-none", className)}>
      <ReactMarkdown remarkPlugins={[remarkGfm]} components={markdownComponents}>
        {display}
      </ReactMarkdown>
      {shouldTruncate && (
        <div className="mt-2">
          <button
            type="button"
            onClick={() => setExpanded(!expanded)}
            className="text-xs px-2 py-1 rounded border bg-white hover:bg-gray-50 text-gray-700"
          >
            {expanded ? "Show less" : "Show more"}
          </button>
        </div>
      )}
    </div>
  );
};

// Helpers for Subagent rendering
const getInitials = (name?: string) => {
  if (!name) return "?";
  const parts = name.trim().split(/\s+/);
  if (parts.length === 1) return parts[0].charAt(0).toUpperCase();
  return (parts[0].charAt(0) + parts[parts.length - 1].charAt(0)).toUpperCase();
};

const hashStringToNumber = (str: string) => {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = (hash << 5) - hash + str.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }
  return Math.abs(hash);
};

const getColorClassesForName = (name: string) => {
  const colorChoices = [
    { avatarBg: "bg-purple-600", cardBg: "bg-purple-50", border: "border-purple-200", badgeText: "text-purple-700", badgeBorder: "border-purple-200" },
    { avatarBg: "bg-blue-600", cardBg: "bg-blue-50", border: "border-blue-200", badgeText: "text-blue-700", badgeBorder: "border-blue-200" },
    { avatarBg: "bg-emerald-600", cardBg: "bg-emerald-50", border: "border-emerald-200", badgeText: "text-emerald-700", badgeBorder: "border-emerald-200" },
    { avatarBg: "bg-teal-600", cardBg: "bg-teal-50", border: "border-teal-200", badgeText: "text-teal-700", badgeBorder: "border-teal-200" },
    { avatarBg: "bg-cyan-600", cardBg: "bg-cyan-50", border: "border-cyan-200", badgeText: "text-cyan-700", badgeBorder: "border-cyan-200" },
    { avatarBg: "bg-sky-600", cardBg: "bg-sky-50", border: "border-sky-200", badgeText: "text-sky-700", badgeBorder: "border-sky-200" },
    { avatarBg: "bg-indigo-600", cardBg: "bg-indigo-50", border: "border-indigo-200", badgeText: "text-indigo-700", badgeBorder: "border-indigo-200" },
    { avatarBg: "bg-fuchsia-600", cardBg: "bg-fuchsia-50", border: "border-fuchsia-200", badgeText: "text-fuchsia-700", badgeBorder: "border-fuchsia-200" },
    { avatarBg: "bg-rose-600", cardBg: "bg-rose-50", border: "border-rose-200", badgeText: "text-rose-700", badgeBorder: "border-rose-200" },
    { avatarBg: "bg-amber-600", cardBg: "bg-amber-50", border: "border-amber-200", badgeText: "text-amber-700", badgeBorder: "border-amber-200" },
  ];
  const idx = hashStringToNumber(name) % colorChoices.length;
  return colorChoices[idx];
};

const extractTextFromResultContent = (content: unknown): string => {
  try {
    if (typeof content === "string") return content;
    if (Array.isArray(content)) {
      const texts = content
        .map((item) => {
          if (item && typeof item === "object" && "text" in (item as Record<string, unknown>)) {
            return String((item as Record<string, unknown>).text ?? "");
          }
          return "";
        })
        .filter(Boolean);
      if (texts.length) return texts.join("\n\n");
    }
    if (content && typeof content === "object") {
      // Some schemas nest under content: []
      const maybe = (content as Record<string, unknown>).content;
      if (Array.isArray(maybe)) {
        const texts = maybe
          .map((item) => {
            if (item && typeof item === "object" && "text" in (item as Record<string, unknown>)) {
              return String((item as Record<string, unknown>).text ?? "");
            }
            return "";
          })
          .filter(Boolean);
        if (texts.length) return texts.join("\n\n");
      }
    }
    return JSON.stringify(content ?? "");
  } catch {
    return String(content ?? "");
  }
};

export const ToolMessage = React.forwardRef<HTMLDivElement, ToolMessageProps>(
  ({ toolUseBlock, resultBlock, className, borderless, ...props }, ref) => {
    const [isExpanded, setIsExpanded] = useState(false);

    const toolResultBlock = resultBlock;
    const isToolCall = Boolean(toolUseBlock && !toolResultBlock);
    const isToolResult = Boolean(toolResultBlock);

    // For tool calls/results, show collapsible interface
    const toolName = formatToolName(toolUseBlock?.name);
    const isLoading = isToolCall; // Tool call without result is loading
    const isError = toolResultBlock?.is_error === true;
    const isSuccess = isToolResult && !isError;

    // Subagent detection and data
    const inputData = (toolUseBlock?.input ?? undefined) as unknown as Record<string, unknown> | undefined;
    const subagentType = (inputData?.subagent_type as string) || undefined;
    const subagentDescription = (inputData?.description as string) || undefined;
    const subagentPrompt = (inputData?.prompt as string) || undefined;
    const isSubagent = Boolean(subagentType);
    const subagentClasses = subagentType ? getColorClassesForName(subagentType) : undefined;
    const displayName = isSubagent ? subagentType : toolName;
    
    // Compact mode for simple tool calls (non-subagent)
    const isCompact = !isSubagent;

    return (
      <div ref={ref} className={cn(isCompact ? "mb-1" : "mb-4", className)} {...props}>
        <div className="flex items-start space-x-3">
          {/* Avatar */}
          <div className="flex-shrink-0">
            {isSubagent ? (
              <div className={cn("w-8 h-8 rounded-full flex items-center justify-center", subagentClasses?.avatarBg)}>
                <span className="text-white text-xs font-semibold">
                  {getInitials(subagentType)}
                </span>
              </div>
            ) : (
              <div className="w-6 h-6 rounded-full flex items-center justify-center bg-purple-600">
                <Cog className="w-3 h-3 text-white" />
              </div>
            )}
          </div>

          {/* Tool Message Content */}
          <div className="flex-1 min-w-0">
            <div
              className={cn(
                isCompact ? "" : (borderless ? "p-0" : "rounded-lg border shadow-sm"),
                isSubagent ? subagentClasses?.cardBg : "",
                isSubagent ? subagentClasses?.border : undefined
              )}
            >
              {/* Collapsible Header */}
              <div
                className={cn(
                  "flex items-center justify-between cursor-pointer hover:bg-gray-50 transition-colors",
                  isCompact ? "py-1 px-0" : "p-3"
                )}
                onClick={() => setIsExpanded(!isExpanded)}
              >
                <div className={cn("flex items-center", isCompact ? "space-x-1.5" : "space-x-2")}>
                  {/* Status Icon */}
                  {!isCompact && (
                    <div className="flex-shrink-0">
                      {isLoading && (
                        <Loader2 className="w-4 h-4 text-blue-500 animate-spin" />
                      )}
                      {isSuccess && <Check className="w-4 h-4 text-green-500" />}
                      {isError && <X className="w-4 h-4 text-red-500" />}
                    </div>
                  )}
                  {isCompact && (
                    <div className="flex-shrink-0">
                      {isLoading && (
                        <Loader2 className="w-3 h-3 text-blue-500 animate-spin" />
                      )}
                      {isError && <X className="w-3 h-3 text-red-500" />}
                    </div>
                  )}

                  {/* Tool Name */}
                  <div className="flex-1 flex items-center min-h-0">
                    <Badge
                      variant="outline"
                      className={cn(
                        "text-xs",
                        isLoading && "animate-pulse",
                        isError && "border-red-200 text-red-700",
                        isSuccess && "border-green-200 text-green-700",
                        isSubagent && subagentClasses?.badgeBorder,
                        isSubagent && subagentClasses?.badgeText,
                        isCompact && "!py-0 px-1.5 leading-tight"
                      )}
                    >
                      {isSubagent ? displayName : (isLoading ? "Calling" : "Called") + " " + displayName}
                    </Badge>
                  </div>

                  {/* Expand/Collapse Icon */}
                  <div className="flex-shrink-0">
                    {isExpanded ? (
                      <ChevronDown className={cn(isCompact ? "w-3 h-3" : "w-4 h-4", "text-gray-400")} />
                    ) : (
                      <ChevronRight className={cn(isCompact ? "w-3 h-3" : "w-4 h-4", "text-gray-400")} />
                    )}
                  </div>
                </div>
              </div>

              {/* Subagent primary content (description + prompt) */}
              {isSubagent ? (
                <div className="px-3 pb-3 space-y-3">
                  <div>
                    {subagentDescription && subagentDescription.trim() ? (
                      <div className="text-gray-800">
                        <ExpandableMarkdown className="prose-sm" content={subagentDescription} />
                      </div>
                    ) : isLoading ? (
                      <div className="text-gray-500 text-sm italic">
                        Working on your request...
                      </div>
                    ) : null}
                    
                    {isLoading && subagentDescription && subagentDescription.trim() && (
                      <div className="flex items-center gap-2 text-xs text-gray-500 mt-2">
                        <Loader2 className="w-3 h-3 animate-bounce" />
                        <span>Waiting for result</span>
                      </div>
                    )}
                  </div>

                  {isExpanded && subagentPrompt && (
                    <div>
                      <h4 className="text-xs font-medium text-gray-700 mb-1">Prompt</h4>
                      <div className="rounded p-2 overflow-x-auto">
                        <ExpandableMarkdown className="prose-sm" content={subagentPrompt} />
                      </div>
                    </div>
                  )}
                </div>
              ) : (
                // Default tool rendering (existing behavior)
                isExpanded && (
                  <div className="px-3 pb-3 space-y-3 bg-gray-50">
                    {toolUseBlock?.input && (
                      <div>
                        <h4 className="text-xs font-medium text-gray-700 mb-1">Input</h4>
                        <div className="bg-gray-800 rounded text-xs p-2 overflow-x-auto">
                          <pre className="text-gray-100">
                            {formatToolInput(JSON.stringify(toolUseBlock.input))}
                          </pre>
                        </div>
                      </div>
                    )}

                    {isToolResult && (
                      <div>
                        <h4 className="text-xs font-medium text-gray-700 mb-1">
                          Result {isError && <span className="text-red-600">(Error)</span>}
                        </h4>
                        <div
                          className={cn(
                            "rounded p-2 overflow-x-auto text-gray-800",
                            isError && "bg-red-50 border border-red-200"
                          )}
                        >
                          <ExpandableMarkdown
                            className="prose-sm"
                            content={
                              typeof toolResultBlock?.content === "string"
                                ? (toolResultBlock?.content as string)
                                : JSON.stringify(toolResultBlock?.content ?? "")
                            }
                          />
                        </div>
                      </div>
                    )}
                  </div>
                )
              )}
            </div>

            {/* Subagent Result Card (separate) */}
            {isSubagent && isToolResult && (
              <div
                className={cn(
                  "mt-2 rounded-lg border shadow-sm",
                  subagentClasses?.cardBg,
                  subagentClasses?.border
                )}
              >
                <div className="flex items-center justify-between p-3">
                  <div className="flex items-center space-x-2">
                    <div className="flex-shrink-0">
                      {isSuccess && <Check className="w-4 h-4 text-green-500" />}
                      {isError && <X className="w-4 h-4 text-red-500" />}
                    </div>
                    <div className="flex-1">
                      <Badge
                        variant="outline"
                        className={cn("text-xs", subagentClasses?.badgeBorder, subagentClasses?.badgeText)}
                      >
                        {displayName}
                      </Badge>
                    </div>
                  </div>
                </div>
                <div className="px-3 pb-3">
                  <div className={cn("rounded p-2 overflow-x-auto text-gray-800")}>
                    <ExpandableMarkdown className="prose-sm" content={extractTextFromResultContent(toolResultBlock?.content as unknown)} />
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
    );
  }
);

ToolMessage.displayName = "ToolMessage";
</file>

<file path="components/frontend/src/components/workspace-sections/sessions-section.tsx">
'use client';

import { formatDistanceToNow } from 'date-fns';
import { Plus, RefreshCw, MoreVertical, Square, Trash2, ArrowRight, Brain } from 'lucide-react';
import Link from 'next/link';

import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '@/components/ui/dropdown-menu';
import { EmptyState } from '@/components/empty-state';
import { SessionPhaseBadge } from '@/components/status-badge';
import { CreateSessionDialog } from '@/components/create-session-dialog';

import { useSessions, useStopSession, useDeleteSession, useContinueSession } from '@/services/queries';
import { successToast, errorToast } from '@/hooks/use-toast';

type SessionsSectionProps = {
  projectName: string;
};

export function SessionsSection({ projectName }: SessionsSectionProps) {
  const { data: sessions = [], isLoading, refetch } = useSessions(projectName);
  const stopSessionMutation = useStopSession();
  const deleteSessionMutation = useDeleteSession();
  const continueSessionMutation = useContinueSession();

  const handleStop = async (sessionName: string) => {
    stopSessionMutation.mutate(
      { projectName, sessionName },
      {
        onSuccess: () => {
          successToast(`Session "${sessionName}" stopped successfully`);
        },
        onError: (error) => {
          errorToast(error instanceof Error ? error.message : 'Failed to stop session');
        },
      }
    );
  };

  const handleDelete = async (sessionName: string) => {
    if (!confirm(`Delete agentic session "${sessionName}"? This action cannot be undone.`)) return;
    deleteSessionMutation.mutate(
      { projectName, sessionName },
      {
        onSuccess: () => {
          successToast(`Session "${sessionName}" deleted successfully`);
        },
        onError: (error) => {
          errorToast(error instanceof Error ? error.message : 'Failed to delete session');
        },
      }
    );
  };

  const handleContinue = async (sessionName: string) => {
    continueSessionMutation.mutate(
      { projectName, parentSessionName: sessionName },
      {
        onSuccess: () => {
          successToast(`Session "${sessionName}" restarted successfully`);
        },
        onError: (error) => {
          errorToast(error instanceof Error ? error.message : 'Failed to restart session');
        },
      }
    );
  };

  const sortedSessions = [...sessions].sort((a, b) => {
    const aTime = a?.metadata?.creationTimestamp ? new Date(a.metadata.creationTimestamp).getTime() : 0;
    const bTime = b?.metadata?.creationTimestamp ? new Date(b.metadata.creationTimestamp).getTime() : 0;
    return bTime - aTime;
  });

  return (
    <Card className="flex-1">
      <CardHeader>
        <div className="flex items-start justify-between">
          <div>
            <CardTitle>Sessions</CardTitle>
            <CardDescription>
              Sessions scoped to this workspace
            </CardDescription>
          </div>
          <div className="flex gap-2">
            <Button variant="outline" onClick={() => refetch()} disabled={isLoading}>
              <RefreshCw className={`w-4 h-4 mr-2 ${isLoading ? 'animate-spin' : ''}`} />
              Refresh
            </Button>
            <CreateSessionDialog
              projectName={projectName}
              onSuccess={() => refetch()}
              trigger={
                <Button>
                  <Plus className="w-4 h-4 mr-2" />
                  New Session
                </Button>
              }
            />
          </div>
        </div>
      </CardHeader>
      <CardContent>
        {sessions.length === 0 ? (
          <EmptyState
            icon={Brain}
            title="No sessions found"
            description="Create your first agentic session"
          />
        ) : (
          <div className="overflow-x-auto">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead className="min-w-[180px]">Name</TableHead>
                  <TableHead>Status</TableHead>
                  <TableHead>Mode</TableHead>
                  <TableHead className="hidden md:table-cell">Model</TableHead>
                  <TableHead className="hidden lg:table-cell">Created</TableHead>
                  <TableHead className="hidden xl:table-cell">Cost</TableHead>
                  <TableHead className="w-[50px]">Actions</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {sortedSessions.map((session) => {
                  const sessionName = session.metadata.name;
                  const phase = session.status?.phase || 'Pending';
                  const isActionPending =
                    (stopSessionMutation.isPending && stopSessionMutation.variables?.sessionName === sessionName) ||
                    (deleteSessionMutation.isPending && deleteSessionMutation.variables?.sessionName === sessionName);

                  return (
                    <TableRow key={session.metadata?.uid || session.metadata?.name}>
                      <TableCell className="font-medium min-w-[180px]">
                        <Link
                          href={`/projects/${projectName}/sessions/${session.metadata.name}`}
                          className="text-blue-600 hover:underline hover:text-blue-800 transition-colors block"
                        >
                          <div>
                            <div className="font-medium">{session.spec.displayName || session.metadata.name}</div>
                            {session.spec.displayName && (
                              <div className="text-xs text-gray-500 font-normal">{session.metadata.name}</div>
                            )}
                          </div>
                        </Link>
                      </TableCell>
                      <TableCell>
                        <SessionPhaseBadge phase={phase} />
                      </TableCell>
                      <TableCell>
                        <span className="text-xs px-2 py-1 rounded border bg-gray-50">
                          {session.spec?.interactive ? 'Interactive' : 'Headless'}
                        </span>
                      </TableCell>
                      <TableCell className="hidden md:table-cell">
                        <span className="text-sm text-gray-600 truncate max-w-[120px] block">
                          {session.spec.llmSettings.model}
                        </span>
                      </TableCell>
                      <TableCell className="hidden lg:table-cell">
                        {session.metadata?.creationTimestamp &&
                          formatDistanceToNow(new Date(session.metadata.creationTimestamp), { addSuffix: true })}
                      </TableCell>
                      <TableCell className="hidden xl:table-cell">
                        {session.status?.total_cost_usd ? (
                          <span className="text-sm font-mono">${session.status.total_cost_usd.toFixed(4)}</span>
                        ) : (
                          <span className="text-sm text-gray-400"></span>
                        )}
                      </TableCell>
                      <TableCell>
                        {isActionPending ? (
                          <Button variant="ghost" size="sm" className="h-8 w-8 p-0" disabled>
                            <RefreshCw className="h-4 w-4 animate-spin" />
                          </Button>
                        ) : (
                          <SessionActions
                            sessionName={sessionName}
                            phase={phase}
                            onStop={handleStop}
                            onContinue={handleContinue}
                            onDelete={handleDelete}
                          />
                        )}
                      </TableCell>
                    </TableRow>
                  );
                })}
              </TableBody>
            </Table>
          </div>
        )}
      </CardContent>
    </Card>
  );
}

type SessionActionsProps = {
  sessionName: string;
  phase: string;
  onStop: (sessionName: string) => void;
  onContinue: (sessionName: string) => void;
  onDelete: (sessionName: string) => void;
};

function SessionActions({ sessionName, phase, onStop, onContinue, onDelete }: SessionActionsProps) {
  type RowAction = {
    key: string;
    label: string;
    onClick: () => void;
    icon: React.ReactNode;
    className?: string;
  };

  const actions: RowAction[] = [];

  if (phase === 'Pending' || phase === 'Creating' || phase === 'Running') {
    actions.push({
      key: 'stop',
      label: 'Stop',
      onClick: () => onStop(sessionName),
      icon: <Square className="h-4 w-4" />,
      className: 'text-orange-600',
    });
  }

  if (phase === 'Completed' || phase === 'Failed' || phase === 'Stopped' || phase === 'Error') {
    actions.push({
      key: 'continue',
      label: 'Continue',
      onClick: () => onContinue(sessionName),
      icon: <ArrowRight className="h-4 w-4" />,
      className: 'text-green-600',
    });
  }

  if (phase !== 'Creating') {
    actions.push({
      key: 'delete',
      label: 'Delete',
      onClick: () => onDelete(sessionName),
      icon: <Trash2 className="h-4 w-4" />,
      className: 'text-red-600',
    });
  }

  if (actions.length === 1) {
    const action = actions[0];
    return (
      <Button variant="ghost" size="sm" className="h-8 w-8 p-0" onClick={action.onClick}>
        {action.icon}
      </Button>
    );
  }

  if (actions.length === 0) {
    return (
      <Button variant="ghost" size="sm" className="h-8 w-8 p-0" disabled>
        <MoreVertical className="h-4 w-4" />
      </Button>
    );
  }

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" size="sm" className="h-8 w-8 p-0">
          <MoreVertical className="h-4 w-4" />
          <span className="sr-only">Open menu</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        {actions.map((action) => (
          <DropdownMenuItem key={action.key} onClick={action.onClick} className={action.className}>
            {action.label}
          </DropdownMenuItem>
        ))}
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="components/frontend/src/components/breadcrumbs.tsx">
"use client";

/**
 * Breadcrumbs Component
 * Navigation breadcrumbs for hierarchical navigation
 */

import * as React from 'react';
import Link from 'next/link';
import { ChevronRight } from 'lucide-react';
import { cn } from '@/lib/utils';

export type BreadcrumbItem = {
  label: string;
  href?: string;
  icon?: React.ReactNode;
};

export type BreadcrumbsProps = {
  items: BreadcrumbItem[];
  className?: string;
  separator?: React.ReactNode;
};

export function Breadcrumbs({
  items,
  className,
  separator = <ChevronRight className="h-4 w-4" />,
}: BreadcrumbsProps) {
  // Temporarily hiding Home from breadcrumbs
  // const allItems: BreadcrumbItem[] = showHome
  //   ? [{ label: 'Home', href: '/', icon: <Home className="h-4 w-4" /> }, ...items]
  //   : items;
  const allItems: BreadcrumbItem[] = items;

  return (
    <nav aria-label="Breadcrumb" className={cn('flex items-center space-x-1 text-sm', className)}>
      <ol className="flex items-center space-x-1">
        {allItems.map((item, index) => {
          const isLast = index === allItems.length - 1;

          return (
            <li key={index} className="flex items-center space-x-1">
              {index > 0 && (
                <span className="text-muted-foreground" aria-hidden="true">
                  {separator}
                </span>
              )}
              {isLast ? (
                <span
                  className="flex items-center gap-1.5 font-medium text-foreground"
                  aria-current="page"
                >
                  {item.icon}
                  {item.label}
                </span>
              ) : (
                <Link
                  href={item.href || '#'}
                  className="flex items-center gap-1.5 text-muted-foreground hover:text-foreground transition-colors"
                >
                  {item.icon}
                  {item.label}
                </Link>
              )}
            </li>
          );
        })}
      </ol>
    </nav>
  );
}

/**
 * Compact breadcrumbs that collapse middle items on mobile
 */
export function CompactBreadcrumbs({ items, className }: BreadcrumbsProps) {
  // Temporarily hiding Home from breadcrumbs
  // const allItems: BreadcrumbItem[] = showHome
  //   ? [{ label: 'Home', href: '/', icon: <Home className="h-4 w-4" /> }, ...items]
  //   : items;
  const allItems: BreadcrumbItem[] = items;

  // On mobile, show first, last, and ellipsis if there are many items
  const shouldCollapse = allItems.length > 3;

  return (
    <nav aria-label="Breadcrumb" className={cn('flex items-center space-x-1 text-sm', className)}>
      <ol className="flex items-center space-x-1">
        {shouldCollapse ? (
          <>
            {/* First item */}
            <li className="flex items-center space-x-1">
              <Link
                href={allItems[0].href || '#'}
                className="flex items-center gap-1.5 text-muted-foreground hover:text-foreground transition-colors"
              >
                {allItems[0].icon}
                <span className="hidden sm:inline">{allItems[0].label}</span>
              </Link>
            </li>

            {/* Separator */}
            <span className="text-muted-foreground" aria-hidden="true">
              <ChevronRight className="h-4 w-4" />
            </span>

            {/* Ellipsis on mobile, middle items on desktop */}
            <li className="flex items-center space-x-1">
              <span className="text-muted-foreground sm:hidden">...</span>
              <span className="hidden sm:flex sm:items-center sm:space-x-1">
                {allItems.slice(1, -1).map((item, index) => (
                  <React.Fragment key={index}>
                    {index > 0 && (
                      <ChevronRight className="h-4 w-4 text-muted-foreground" aria-hidden="true" />
                    )}
                    <Link
                      href={item.href || '#'}
                      className="flex items-center gap-1.5 text-muted-foreground hover:text-foreground transition-colors"
                    >
                      {item.icon}
                      {item.label}
                    </Link>
                  </React.Fragment>
                ))}
              </span>
            </li>

            {/* Separator */}
            <span className="text-muted-foreground" aria-hidden="true">
              <ChevronRight className="h-4 w-4" />
            </span>

            {/* Last item */}
            <li>
              <span className="flex items-center gap-1.5 font-medium text-foreground" aria-current="page">
                {allItems[allItems.length - 1].icon}
                {allItems[allItems.length - 1].label}
              </span>
            </li>
          </>
        ) : (
          <Breadcrumbs items={items} className={className} />
        )}
      </ol>
    </nav>
  );
}
</file>

<file path="components/frontend/src/components/clone-session-dialog.tsx">
"use client";

import { useState } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import { Copy, Loader2 } from "lucide-react";

import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { AgenticSession } from "@/types/agentic-session";
import { useProjects, useCloneSession } from "@/services/queries";

const formSchema = z.object({
  project: z.string().min(1, "Please select a project"),
});

type FormValues = z.infer<typeof formSchema>;

type CloneSessionDialogProps = {
  session: AgenticSession;
  trigger: React.ReactNode;
  onSuccess?: () => void;
  projectName?: string; // when provided, hide selector and use this project
}

export function CloneSessionDialog({
  session,
  trigger,
  onSuccess,
  projectName,
}: CloneSessionDialogProps) {
  const [open, setOpen] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const { data: projects = [], isLoading: loadingProjects } = useProjects();
  const cloneSessionMutation = useCloneSession();

  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      project: projectName || session.spec.project || "",
    },
  });

  const onSubmit = async (values: FormValues) => {
    setError(null);
    const targetProject = projectName || values.project;

    cloneSessionMutation.mutate(
      {
        projectName: targetProject,
        sessionName: session.metadata.name,
        data: {
          targetProject: targetProject,
          newSessionName: `${session.metadata.name}-clone-${Date.now()}`,
        },
      },
      {
        onSuccess: () => {
          setOpen(false);
          onSuccess?.();
        },
        onError: (err) => {
          setError(err.message || "Failed to clone session");
        },
      }
    );
  };

  const handleOpenChange = (newOpen: boolean) => {
    setOpen(newOpen);
    if (!newOpen) {
      // Reset form and state when closing
      form.reset();
      setError(null);
    }
  };

  const handleTriggerClick = () => {
    setOpen(true);
  };

  return (
    <>
      <div onClick={handleTriggerClick}>{trigger}</div>
      <Dialog open={open} onOpenChange={handleOpenChange}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle className="flex items-center">
              <Copy className="w-5 h-5 mr-2" />
              Clone Session
            </DialogTitle>
            <DialogDescription>
              {projectName
                ? `Clone "${session.spec.displayName || session.metadata.name}" into this project.`
                : `Clone "${session.spec.displayName || session.metadata.name}" to a target project.`}
            </DialogDescription>
          </DialogHeader>

        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            {!projectName && (
            <FormField
              control={form.control}
              name="project"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Target Project</FormLabel>
                  <Select
                    onValueChange={field.onChange}
                    defaultValue={field.value}
                    disabled={loadingProjects || cloneSessionMutation.isPending}
                  >
                    <FormControl>
                      <SelectTrigger>
                        <SelectValue
                          placeholder={
                            loadingProjects
                              ? "Loading workspaces..."
                              : "Select a workspace"
                          }
                        />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      {projects.map((project) => (
                      <SelectItem key={project.name} value={project.name}>
                          {project.displayName || project.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                  <FormDescription>
                    Select the project where the cloned session will be created
                  </FormDescription>
                  <FormMessage />
                </FormItem>
              )}
            />)}

            {error && (
              <div className="bg-red-50 border border-red-200 rounded-md p-3">
                <p className="text-red-700 text-sm">{error}</p>
              </div>
            )}

            <DialogFooter>
              <Button
                type="button"
                variant="outline"
                onClick={() => setOpen(false)}
                disabled={cloneSessionMutation.isPending}
              >
                Cancel
              </Button>
              <Button type="submit" disabled={cloneSessionMutation.isPending || (!projectName && loadingProjects)}>
                {cloneSessionMutation.isPending && (
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                )}
                {cloneSessionMutation.isPending ? "Cloning..." : "Clone Session"}
              </Button>
            </DialogFooter>
          </form>
        </Form>
        </DialogContent>
      </Dialog>
    </>
  );
}
</file>

<file path="components/frontend/src/components/create-workspace-dialog.tsx">
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { CreateProjectRequest } from "@/types/project";
import { Save, Loader2, Info } from "lucide-react";
import { successToast, errorToast } from "@/hooks/use-toast";
import { useCreateProject } from "@/services/queries";
import { useClusterInfo } from "@/hooks/use-cluster-info";
import { Alert, AlertDescription } from "@/components/ui/alert";

type CreateWorkspaceDialogProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
};

export function CreateWorkspaceDialog({
  open,
  onOpenChange,
}: CreateWorkspaceDialogProps) {
  const router = useRouter();
  const createProjectMutation = useCreateProject();
  const { isOpenShift, isLoading: clusterLoading } = useClusterInfo();
  const [error, setError] = useState<string | null>(null);
  const [formData, setFormData] = useState<CreateProjectRequest>({
    name: "",
    displayName: "",
    description: "",
  });

  const [nameError, setNameError] = useState<string | null>(null);
  const [manuallyEditedName, setManuallyEditedName] = useState(false);

  const generateWorkspaceName = (displayName: string): string => {
    return displayName
      .toLowerCase()
      .replace(/\s+/g, "-") // Replace spaces with hyphens
      .replace(/[^a-z0-9-]/g, "") // Remove invalid characters
      .replace(/-+/g, "-") // Collapse multiple hyphens
      .replace(/^-+|-+$/g, "") // Remove leading/trailing hyphens
      .slice(0, 63); // Truncate to max length
  };

  const validateProjectName = (name: string) => {
    // Validate name pattern: ^[a-z0-9]([-a-z0-9]*[a-z0-9])?$
    const namePattern = /^[a-z0-9]([-a-z0-9]*[a-z0-9])?$/;

    if (!name) {
      return "Workspace name is required";
    }

    if (name.length > 63) {
      return "Workspace name must be 63 characters or less";
    }

    if (!namePattern.test(name)) {
      return "Workspace name must be lowercase alphanumeric with hyphens (cannot start or end with hyphen)";
    }

    return null;
  };

  const handleDisplayNameChange = (displayName: string) => {
    setFormData((prev) => ({
      ...prev,
      displayName,
      // Auto-generate name only if it hasn't been manually edited
      name: manuallyEditedName ? prev.name : generateWorkspaceName(displayName),
    }));
    
    // Validate the auto-generated name
    if (!manuallyEditedName) {
      const generatedName = generateWorkspaceName(displayName);
      setNameError(validateProjectName(generatedName));
    }
  };

  // Commented out - name input field is hidden, auto-generated from displayName
  // const handleNameChange = (name: string) => {
  //   setManuallyEditedName(true);
  //   setFormData((prev) => ({ ...prev, name }));
  //   setNameError(validateProjectName(name));
  // };

  const resetForm = () => {
    setFormData({
      name: "",
      displayName: "",
      description: "",
    });
    setNameError(null);
    setError(null);
    setManuallyEditedName(false);
  };

  const handleClose = () => {
    if (!createProjectMutation.isPending) {
      resetForm();
      onOpenChange(false);
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    // Validate required fields
    if (isOpenShift && !formData.displayName?.trim()) {
      setError("Display Name is required");
      return;
    }

    const nameValidationError = validateProjectName(formData.name);
    if (nameValidationError) {
      setNameError(nameValidationError);
      return;
    }

    setError(null);

    // Prepare the request payload
    const payload: CreateProjectRequest = {
      name: formData.name,
      // Only include displayName and description on OpenShift
      ...(isOpenShift &&
        formData.displayName?.trim() && {
          displayName: formData.displayName.trim(),
        }),
      ...(isOpenShift &&
        formData.description?.trim() && {
          description: formData.description.trim(),
        }),
    };

    createProjectMutation.mutate(payload, {
      onSuccess: (project) => {
        successToast(
          `Workspace "${formData.displayName || formData.name}" created successfully`
        );
        resetForm();
        onOpenChange(false);
        router.push(`/projects/${encodeURIComponent(project.name)}`);
      },
      onError: (err) => {
        const message =
          err instanceof Error ? err.message : "Failed to create workspace";
        setError(message);
        errorToast(message);
      },
    });
  };

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent className="w-[672px] max-w-[90vw] max-h-[90vh] overflow-y-auto">
        <DialogHeader className="space-y-3">
          <DialogTitle>Create New Workspace</DialogTitle>
          <DialogDescription>
            Set up a new workspace for your team
          </DialogDescription>
        </DialogHeader>

        <form onSubmit={handleSubmit} className="space-y-8 pt-2">
          {/* Cluster info banner */}
          {!clusterLoading && !isOpenShift && (
            <Alert>
              <Info className="h-4 w-4" />
              <AlertDescription>
                Running on vanilla Kubernetes. Display name and description
                fields are not available.
              </AlertDescription>
            </Alert>
          )}

          {/* Basic Information */}
          <div className="space-y-6">

            {/* OpenShift-only fields */}
            {isOpenShift && (
              <div className="space-y-2">
                <Label htmlFor="displayName">Workspace Name *</Label>
                <Input
                  id="displayName"
                  value={formData.displayName}
                  onChange={(e) => handleDisplayNameChange(e.target.value)}
                  placeholder="e.g. My Research Workspace"
                  maxLength={100}
                />
              </div>
            )}

            {/* Vanilla Kubernetes name field */}
            {!isOpenShift && (
              <div className="space-y-2">
                <Label htmlFor="name">Workspace Name *</Label>
                <Input
                  id="name"
                  value={formData.name}
                  onChange={(e) => {
                    const name = e.target.value;
                    setFormData((prev) => ({ ...prev, name }));
                    setNameError(validateProjectName(name));
                  }}
                  placeholder="my-research-workspace"
                  className={nameError ? "border-red-500" : ""}
                />
                {nameError && <p className="text-sm text-red-600">{nameError}</p>}
                <p className="text-sm text-gray-600">
                  Lowercase alphanumeric with hyphens.
                </p>
              </div>
            )}

            {/* OpenShift-only description field */}
            {isOpenShift && (
              <div className="space-y-2">
                <Label htmlFor="description">Description</Label>
                <Textarea
                  id="description"
                  value={formData.description}
                  onChange={(e) =>
                    setFormData((prev) => ({
                      ...prev,
                      description: e.target.value,
                    }))
                  }
                  placeholder="Description of the workspace purpose and goals..."
                  maxLength={500}
                  rows={3}
                />
              </div>
            )}
          </div>

          {error && (
            <div className="p-4 bg-red-50 border border-red-200 rounded-md">
              <p className="text-red-700">{error}</p>
            </div>
          )}

          <DialogFooter className="pt-2">
            <Button
              type="button"
              variant="outline"
              onClick={handleClose}
              disabled={createProjectMutation.isPending}
            >
              Cancel
            </Button>
            <Button
              type="submit"
              disabled={createProjectMutation.isPending || !!nameError}
            >
              {createProjectMutation.isPending ? (
                <>
                  <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                  Creating...
                </>
              ) : (
                <>
                  <Save className="w-4 h-4 mr-2" />
                  Create Workspace
                </>
              )}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="components/frontend/src/components/empty-state.tsx">
"use client";

/**
 * EmptyState component
 * Displays a consistent empty state with icon, title, description, and optional action
 */

import { LucideIcon } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';

type EmptyStateProps = {
  icon?: LucideIcon;
  title: string;
  description?: string;
  action?: {
    label: string;
    onClick: () => void;
  };
  className?: string;
};

export function EmptyState({
  icon: Icon,
  title,
  description,
  action,
  className,
}: EmptyStateProps) {
  return (
    <div
      className={cn(
        'flex flex-col items-center justify-center py-12 px-4 text-center',
        className
      )}
    >
      {Icon && (
        <div className="mb-4 rounded-full bg-muted p-4">
          <Icon className="h-8 w-8 text-muted-foreground" />
        </div>
      )}
      <h3 className="mb-2 text-lg font-semibold">{title}</h3>
      {description && (
        <p className="mb-6 max-w-md text-sm text-muted-foreground">
          {description}
        </p>
      )}
      {action && (
        <Button type="button" onClick={action.onClick}>{action.label}</Button>
      )}
    </div>
  );
}
</file>

<file path="components/frontend/src/hooks/use-cluster-info.ts">
/**
 * Cluster information hook
 * Detects cluster type (OpenShift vs vanilla Kubernetes) by calling the /api/cluster-info endpoint
 */

import { useClusterInfo as useClusterInfoQuery } from '@/services/queries/use-cluster';

export type ClusterInfo = {
  isOpenShift: boolean;
  vertexEnabled: boolean;
  isLoading: boolean;
  isError: boolean;
};

/**
 * Detects whether the cluster is OpenShift or vanilla Kubernetes
 * and whether Vertex AI is enabled
 * Calls the /api/cluster-info endpoint which checks for project.openshift.io API group
 * and CLAUDE_CODE_USE_VERTEX environment variable
 */
export function useClusterInfo(): ClusterInfo {
  const { data, isLoading, isError } = useClusterInfoQuery();

  return {
    isOpenShift: data?.isOpenShift ?? false,
    vertexEnabled: data?.vertexEnabled ?? false,
    isLoading,
    isError,
  };
}
</file>

<file path="components/frontend/src/lib/agents.ts">
import { AgentPersona } from "@/types/agentic-session";

// Agent persona definitions based on the YAML files in claude-runner
export const AVAILABLE_AGENTS: AgentPersona[] = [
  {
    persona: "emma-engineering_manager",
    name: "Emma Engineering Manager",
    role: "Engineering Manager",
    description: "Engineering Manager Agent focused on team wellbeing, strategic planning, and delivery coordination. Use PROACTIVELY for team management, capacity planning, and balancing technical excellence with business needs."
  },
  {
    persona: "stella-staff_engineer",
    name: "Stella Staff Engineer",
    role: "Staff Engineer",
    description: "Staff Engineer Agent focused on technical leadership, implementation excellence, and mentoring. Use PROACTIVELY for complex technical problems, code review, and bridging architecture to implementation."
  },
  {
    persona: "parker-product_manager",
    name: "Parker Product Manager",
    role: "Product Manager",
    description: "Product Manager Agent focused on market strategy, customer feedback, and business value delivery. Use PROACTIVELY for product roadmap decisions, competitive analysis, and translating business requirements to technical features."
  },
  {
    persona: "lee-team_lead",
    name: "Lee Team Lead",
    role: "Team Lead",
    description: "Team Lead Agent focused on team coordination, technical decision facilitation, and delivery execution. Use PROACTIVELY for sprint leadership, technical planning, and cross-team communication."
  },
  {
    persona: "sam-scrum_master",
    name: "Sam Scrum Master",
    role: "Scrum Master",
    description: "Scrum Master Agent focused on agile facilitation, impediment removal, and team process optimization. Use PROACTIVELY for sprint planning, retrospectives, and process improvement."
  },
  {
    persona: "aria-ux_architect",
    name: "Aria UX Architect",
    role: "UX Architect",
    description: "UX Architect Agent focused on user experience strategy, journey mapping, and design system architecture. Use PROACTIVELY for holistic UX planning, ecosystem design, and user research strategy."
  },
  {
    persona: "uma-ux_team_lead",
    name: "Uma UX Team Lead",
    role: "UX Team Lead",
    description: "UX Team Lead Agent focused on design quality, team coordination, and design system governance. Use PROACTIVELY for design process management, critique facilitation, and design team leadership."
  },
  {
    persona: "felix-ux_feature_lead",
    name: "Felix UX Feature Lead",
    role: "UX Feature Lead",
    description: "UX Feature Lead Agent focused on component design, pattern reusability, and accessibility implementation. Use PROACTIVELY for detailed feature design, component specification, and accessibility compliance."
  },
  {
    persona: "ryan-ux_researcher",
    name: "Ryan UX Researcher",
    role: "UX Researcher",
    description: "UX Researcher Agent focused on user insights, data analysis, and evidence-based design decisions. Use PROACTIVELY for user research planning, usability testing, and translating insights to design recommendations."
  },
  {
    persona: "casey-content_strategist",
    name: "Casey Content Strategist",
    role: "Content Strategist",
    description: "Content Strategist Agent focused on information architecture, content standards, and strategic content planning. Use PROACTIVELY for content taxonomy, style guidelines, and content effectiveness measurement."
  },
  {
    persona: "terry-technical_writer",
    name: "Terry Technical Writer",
    role: "Technical Writer",
    description: "Technical Writer Agent focused on user-centered documentation, procedure testing, and clear technical communication. Use PROACTIVELY for hands-on documentation creation and technical accuracy validation."
  },
  {
    persona: "tessa-writing_manager",
    name: "Tessa Writing Manager",
    role: "Writing Manager",
    description: "Technical Writing Manager Agent focused on documentation strategy, team coordination, and content quality. Use PROACTIVELY for documentation planning, writer management, and content standards."
  },
  {
    persona: "jack-delivery_owner",
    name: "Jack Delivery Owner",
    role: "Delivery Owner",
    description: "Delivery Owner Agent focused on cross-team coordination, dependency tracking, and milestone management. Use PROACTIVELY for release planning, risk mitigation, and delivery status reporting."
  },
  {
    persona: "phoenix-pxe_specialist",
    name: "Phoenix PXE Specialist",
    role: "PXE Specialist",
    description: "PXE (Product Experience Engineering) Agent focused on customer impact assessment, lifecycle management, and field experience insights. Use PROACTIVELY for upgrade planning, risk assessment, and customer telemetry analysis."
  },
  {
    persona: "phoenix-pxe_specialist",
    name: "Neil Test Engineer",
    role: "Test Engineer/Architect",
    description: "Test engineer Agent focused on, the testing requirements i.e. whether the changes are testable, implementation matches product/customer requirements, cross component impact, automation testing, performance & security impact"
  }
];

// Default agent selections for different workflow types
export const DEFAULT_AGENT_SELECTIONS = {
  BALANCED: ["emma-engineering_manager", "stella-staff_engineer", "parker-product_manager", "lee-team_lead"],
  TECHNICAL: ["stella-staff_engineer", "emma-engineering_manager", "aria-ux_architect", "terry-technical_writer"],
  PRODUCT: ["parker-product_manager", "ryan-ux_researcher", "casey-content_strategist", "jack-delivery_owner"],
  DESIGN: ["aria-ux_architect", "felix-ux_feature_lead", "ryan-ux_researcher", "casey-content_strategist"],
  PROCESS: ["sam-scrum_master", "emma-engineering_manager", "jack-delivery_owner", "lee-team_lead"]
};

// Utility functions
export function getAgentByPersona(persona: string): AgentPersona | undefined {
  return AVAILABLE_AGENTS.find(agent => agent.persona === persona);
}

export function getDefaultAgents(type: keyof typeof DEFAULT_AGENT_SELECTIONS = "BALANCED"): AgentPersona[] {
  return DEFAULT_AGENT_SELECTIONS[type].map(persona => getAgentByPersona(persona)!).filter(Boolean);
}

export function getAgentsByExpertise(expertise: string): AgentPersona[] {
  return AVAILABLE_AGENTS.filter(agent =>
      agent.description.toLowerCase().includes(expertise.toLowerCase()) ||
      agent.role.toLowerCase().includes(expertise.toLowerCase())
  );
}

export function groupAgentsByRole(): { [role: string]: AgentPersona[] } {
  const groups: { [role: string]: AgentPersona[] } = {};

  AVAILABLE_AGENTS.forEach(agent => {
    const category = getCategoryForRole(agent.role);
    if (!groups[category]) {
      groups[category] = [];
    }
    groups[category].push(agent);
  });

  return groups;
}

function getCategoryForRole(role: string): string {
  if (role.includes("Engineering") || role.includes("Technical")) return "Engineering";
  if (role.includes("UX") || role.includes("Design")) return "Design";
  if (role.includes("Product") || role.includes("Strategy")) return "Product";
  if (role.includes("Content") || role.includes("Documentation")) return "Content";
  return "Process & Leadership";
}
</file>

<file path="components/frontend/src/services/api/cluster.ts">
/**
 * Cluster API service
 * Handles cluster information and detection
 */

import { apiClient } from './client';

export type ClusterInfo = {
  isOpenShift: boolean;
  vertexEnabled: boolean;
};

/**
 * Get cluster information (OpenShift vs vanilla Kubernetes, Vertex AI status)
 * This endpoint does not require authentication
 */
export async function getClusterInfo(): Promise<ClusterInfo> {
  return apiClient.get<ClusterInfo>('/cluster-info');
}
</file>

<file path="components/frontend/src/services/api/repo.ts">
/**
 * Repository API service
 * Handles repository file and tree operations
 */

import { apiClient } from './client';
import type { ListBranchesResponse } from '@/types/api';

type RepoParams = {
  repo: string;
  ref: string;
  path: string;
};

type TreeEntry = {
  type: string;
  name?: string;
  path?: string;
  sha?: string;
};

type TreeResponse = {
  entries: TreeEntry[];
  sha?: string;
};

/**
 * Get file content (blob) from repository
 */
export async function getRepoBlob(
  projectName: string,
  params: RepoParams
): Promise<Response> {
  // Return raw Response for status checking and text extraction
  return apiClient.getRaw(
    `/projects/${projectName}/repo/blob`,
    {
      params: {
        repo: params.repo,
        ref: params.ref,
        path: params.path,
      },
    }
  );
}

/**
 * Get directory tree from repository
 */
export async function getRepoTree(
  projectName: string,
  params: RepoParams
): Promise<TreeResponse> {
  const url = `/projects/${encodeURIComponent(projectName)}/repo/tree`;
  
  return apiClient.get<TreeResponse>(url, {
    params: {
      repo: params.repo,
      ref: params.ref,
      path: params.path,
    },
  });
}

/**
 * Check if a file exists in repository
 */
export async function checkFileExists(
  projectName: string,
  params: RepoParams
): Promise<boolean> {
  try {
    const response = await getRepoBlob(projectName, params);
    return response.ok;
  } catch {
    return false;
  }
}

/**
 * List all branches in a repository
 */
export async function listRepoBranches(
  projectName: string,
  repo: string
): Promise<ListBranchesResponse> {
  const url = `/projects/${encodeURIComponent(projectName)}/repo/branches`;

  return apiClient.get<ListBranchesResponse>(url, {
    params: {
      repo: repo,
    },
  });
}
</file>

<file path="components/frontend/src/services/api/sessions.ts">
/**
 * Agentic Sessions API service
 * Handles all session-related API calls
 */

import { apiClient } from './client';
import type {
  AgenticSession,
  CreateAgenticSessionRequest,
  CreateAgenticSessionResponse,
  GetAgenticSessionResponse,
  ListAgenticSessionsResponse,
  StopAgenticSessionRequest,
  StopAgenticSessionResponse,
  CloneAgenticSessionRequest,
  CloneAgenticSessionResponse,
  Message,
  GetSessionMessagesResponse,
} from '@/types/api';

/**
 * List sessions for a project
 */
export async function listSessions(projectName: string): Promise<AgenticSession[]> {
  const response = await apiClient.get<ListAgenticSessionsResponse | AgenticSession[]>(
    `/projects/${projectName}/agentic-sessions`
  );
  // Handle both wrapped and unwrapped responses
  if (Array.isArray(response)) {
    return response;
  }
  return response.items || [];
}

/**
 * Get a single session
 */
export async function getSession(
  projectName: string,
  sessionName: string
): Promise<AgenticSession> {
  const response = await apiClient.get<GetAgenticSessionResponse | AgenticSession>(
    `/projects/${projectName}/agentic-sessions/${sessionName}`
  );
  // Handle both wrapped and unwrapped responses
  if ('session' in response && response.session) {
    return response.session;
  }
  return response as AgenticSession;
}

/**
 * Create a new session
 */
export async function createSession(
  projectName: string,
  data: CreateAgenticSessionRequest
): Promise<AgenticSession> {
  const response = await apiClient.post<
    CreateAgenticSessionResponse,
    CreateAgenticSessionRequest
  >(`/projects/${projectName}/agentic-sessions`, data);
  
  // Backend returns simplified response, fetch the full session object
  return await getSession(projectName, response.name);
}

/**
 * Stop a running session
 */
export async function stopSession(
  projectName: string,
  sessionName: string,
  data?: StopAgenticSessionRequest
): Promise<string> {
  const response = await apiClient.post<
    StopAgenticSessionResponse,
    StopAgenticSessionRequest | undefined
  >(`/projects/${projectName}/agentic-sessions/${sessionName}/stop`, data);
  return response.message;
}

/**
 * Start/restart a session
 */
export async function startSession(
  projectName: string,
  sessionName: string
): Promise<{ message: string }> {
  return apiClient.post<{ message: string }>(
    `/projects/${projectName}/agentic-sessions/${sessionName}/start`
  );
}

/**
 * Clone an existing session
 */
export async function cloneSession(
  projectName: string,
  sessionName: string,
  data: CloneAgenticSessionRequest
): Promise<AgenticSession> {
  const response = await apiClient.post<
    CloneAgenticSessionResponse,
    CloneAgenticSessionRequest
  >(`/projects/${projectName}/agentic-sessions/${sessionName}/clone`, data);
  return response.session;
}

/**
 * Get session messages
 */
export async function getSessionMessages(
  projectName: string,
  sessionName: string
): Promise<Message[]> {
  const response = await apiClient.get<GetSessionMessagesResponse>(
    `/projects/${projectName}/agentic-sessions/${sessionName}/messages`
  );
  return response.messages;
}

/**
 * Delete a session
 */
export async function deleteSession(
  projectName: string,
  sessionName: string
): Promise<void> {
  await apiClient.delete(`/projects/${projectName}/agentic-sessions/${sessionName}`);
}

/**
 * Send a chat message to an interactive session
 */
export async function sendChatMessage(
  projectName: string,
  sessionName: string,
  content: string
): Promise<void> {
  await apiClient.post<void, { content: string }>(
    `/projects/${projectName}/agentic-sessions/${sessionName}/messages`,
    { content }
  );
}

/**
 * Send a control message (interrupt, end_session) to a session
 */
export async function sendControlMessage(
  projectName: string,
  sessionName: string,
  type: 'interrupt' | 'end_session'
): Promise<void> {
  await apiClient.post<void, { type: string }>(
    `/projects/${projectName}/agentic-sessions/${sessionName}/messages`,
    { type }
  );
}

/**
 * Get K8s resource information (job, pods, PVC) for a session
 */
export async function getSessionK8sResources(
  projectName: string,
  sessionName: string
): Promise<{
  jobName: string;
  jobStatus?: string;
  pods?: Array<{
    name: string;
    phase: string;
    containers: Array<{
      name: string;
      state: string;
      exitCode?: number;
      reason?: string;
    }>;
  }>;
  pvcName: string;
  pvcExists: boolean;
  pvcSize?: string;
}> {
  return apiClient.get(`/projects/${projectName}/agentic-sessions/${sessionName}/k8s-resources`);
}

/**
 * Spawn temporary content pod for workspace access
 */
export async function spawnContentPod(
  projectName: string,
  sessionName: string
): Promise<{ status: string; podName: string; ready?: boolean }> {
  return apiClient.post(`/projects/${projectName}/agentic-sessions/${sessionName}/spawn-content-pod`);
}

/**
 * Check temporary content pod status
 */
export async function getContentPodStatus(
  projectName: string,
  sessionName: string
): Promise<{ status: string; ready: boolean; podName: string; createdAt?: string }> {
  return apiClient.get(`/projects/${projectName}/agentic-sessions/${sessionName}/content-pod-status`);
}

/**
 * Delete temporary content pod
 */
export async function deleteContentPod(
  projectName: string,
  sessionName: string
): Promise<void> {
  await apiClient.delete(`/projects/${projectName}/agentic-sessions/${sessionName}/content-pod`);
}
</file>

<file path="components/frontend/src/services/api/workflows.ts">
import { apiClient } from "./client";

export type OOTBWorkflow = {
  id: string;
  name: string;
  description: string;
  gitUrl: string;
  branch: string;
  path?: string;
  enabled: boolean;
};

export type ListOOTBWorkflowsResponse = {
  workflows: OOTBWorkflow[];
};

export async function listOOTBWorkflows(projectName?: string): Promise<OOTBWorkflow[]> {
  const response = await apiClient.get<ListOOTBWorkflowsResponse>(
    "/workflows/ootb",
    projectName ? { params: { project: projectName } } : undefined
  );
  return response.workflows;
}

export type WorkflowCommand = {
  id: string;
  name: string;
  description: string;
  slashCommand: string;
  icon?: string;
};

export type WorkflowAgent = {
  id: string;
  name: string;
  description: string;
  tools?: string[];
};

export type WorkflowConfig = {
  name?: string;
  description?: string;
  systemPrompt?: string;
  artifactsDir?: string;
};

export type WorkflowMetadataResponse = {
  commands: WorkflowCommand[];
  agents: WorkflowAgent[];
  config?: WorkflowConfig;
};

export async function getWorkflowMetadata(
  projectName: string,
  sessionName: string
): Promise<WorkflowMetadataResponse> {
  const response = await apiClient.get<WorkflowMetadataResponse>(
    `/projects/${projectName}/agentic-sessions/${sessionName}/workflow/metadata`
  );
  return response;
}
</file>

<file path="components/frontend/src/services/queries/use-repo.ts">
/**
 * React Query hooks for repository operations
 */

import { useQuery } from '@tanstack/react-query';
import * as repoApi from '../api/repo';

type RepoParams = {
  repo: string;
  ref: string;
  path: string;
};

/**
 * Query keys for repository operations
 */
export const repoKeys = {
  all: ['repo'] as const,
  blobs: () => [...repoKeys.all, 'blob'] as const,
  blob: (projectName: string, params: RepoParams) =>
    [...repoKeys.blobs(), projectName, params.repo, params.ref, params.path] as const,
  trees: () => [...repoKeys.all, 'tree'] as const,
  tree: (projectName: string, params: RepoParams) =>
    [...repoKeys.trees(), projectName, params.repo, params.ref, params.path] as const,
  branches: () => [...repoKeys.all, 'branches'] as const,
  repoBranches: (projectName: string, repo: string) =>
    [...repoKeys.branches(), projectName, repo] as const,
};

/**
 * Hook to fetch a file blob from repository
 * Returns the Response object for status checking and content reading
 */
export function useRepoBlob(
  projectName: string,
  params: RepoParams,
  options?: { enabled?: boolean }
) {
  return useQuery({
    queryKey: repoKeys.blob(projectName, params),
    queryFn: () => repoApi.getRepoBlob(projectName, params),
    enabled: (options?.enabled ?? true) && !!projectName && !!params.repo && !!params.ref && !!params.path,
    staleTime: 5 * 60 * 1000, // 5 minutes - files don't change frequently
  });
}

/**
 * Hook to fetch a directory tree from repository
 */
export function useRepoTree(
  projectName: string,
  params: RepoParams,
  options?: { enabled?: boolean }
) {
  return useQuery({
    queryKey: repoKeys.tree(projectName, params),
    queryFn: () => repoApi.getRepoTree(projectName, params),
    enabled: (options?.enabled ?? true) && !!projectName && !!params.repo && !!params.ref && !!params.path,
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
}

/**
 * Hook to check if a file exists in repository
 */
export function useRepoFileExists(
  projectName: string,
  params: RepoParams,
  options?: { enabled?: boolean }
) {
  return useQuery({
    queryKey: [...repoKeys.blob(projectName, params), 'exists'] as const,
    queryFn: () => repoApi.checkFileExists(projectName, params),
    enabled: (options?.enabled ?? true) && !!projectName && !!params.repo && !!params.ref && !!params.path,
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
}

/**
 * Hook to fetch all branches in a repository
 */
export function useRepoBranches(
  projectName: string,
  repo: string,
  options?: { enabled?: boolean }
) {
  return useQuery({
    queryKey: repoKeys.repoBranches(projectName, repo),
    queryFn: () => repoApi.listRepoBranches(projectName, repo),
    enabled: (options?.enabled ?? true) && !!projectName && !!repo,
    staleTime: 2 * 60 * 1000, // 2 minutes - branches may change more frequently than files
  });
}
</file>

<file path="components/frontend/src/services/queries/use-sessions.ts">
/**
 * React Query hooks for agentic sessions
 */

import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import * as sessionsApi from '../api/sessions';
import type {
  AgenticSession,
  CreateAgenticSessionRequest,
  StopAgenticSessionRequest,
  CloneAgenticSessionRequest,
} from '@/types/api';

/**
 * Query keys for sessions
 */
export const sessionKeys = {
  all: ['sessions'] as const,
  lists: () => [...sessionKeys.all, 'list'] as const,
  list: (projectName: string) => [...sessionKeys.lists(), projectName] as const,
  details: () => [...sessionKeys.all, 'detail'] as const,
  detail: (projectName: string, sessionName: string) =>
    [...sessionKeys.details(), projectName, sessionName] as const,
  messages: (projectName: string, sessionName: string) =>
    [...sessionKeys.detail(projectName, sessionName), 'messages'] as const,
};

/**
 * Hook to fetch sessions for a project
 */
export function useSessions(projectName: string) {
  return useQuery({
    queryKey: sessionKeys.list(projectName),
    queryFn: () => sessionsApi.listSessions(projectName),
    enabled: !!projectName,
  });
}

/**
 * Hook to fetch a single session
 */
export function useSession(projectName: string, sessionName: string) {
  return useQuery({
    queryKey: sessionKeys.detail(projectName, sessionName),
    queryFn: () => sessionsApi.getSession(projectName, sessionName),
    enabled: !!projectName && !!sessionName,
    // Poll for status updates on running sessions
    refetchInterval: (query) => {
      const session = query.state.data as AgenticSession | undefined;
      const isRunning =
        session?.status?.phase === 'Running' ||
        session?.status?.phase === 'Creating' ||
        session?.status?.phase === 'Pending';
      return isRunning ? 5000 : false; // Poll every 5 seconds if running
    },
  });
}

/**
 * Hook to fetch session messages
 */
export function useSessionMessages(projectName: string, sessionName: string, sessionPhase?: string) {
  return useQuery({
    queryKey: sessionKeys.messages(projectName, sessionName),
    queryFn: () => sessionsApi.getSessionMessages(projectName, sessionName),
    enabled: !!projectName && !!sessionName,
    // Messages are typically handled via WebSocket, so longer stale time
    staleTime: 5 * 1000, // 5 seconds
    // Poll for message updates on running sessions
    refetchInterval: () => {
      const isRunning =
        sessionPhase === 'Running' ||
        sessionPhase === 'Creating' ||
        sessionPhase === 'Pending';
      return isRunning ? 5000 : false; // Poll every 5 seconds if running
    },
  });
}

/**
 * Hook to create a session
 */
export function useCreateSession() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      projectName,
      data,
    }: {
      projectName: string;
      data: CreateAgenticSessionRequest;
    }) => sessionsApi.createSession(projectName, data),
    onSuccess: (_session, { projectName }) => {
      // Invalidate and refetch sessions list
      queryClient.invalidateQueries({
        queryKey: sessionKeys.list(projectName),
        refetchType: 'all', // Refetch both active and inactive queries
      });
    },
  });
}

/**
 * Hook to stop a session
 */
export function useStopSession() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      projectName,
      sessionName,
      data,
    }: {
      projectName: string;
      sessionName: string;
      data?: StopAgenticSessionRequest;
    }) => sessionsApi.stopSession(projectName, sessionName, data),
    onSuccess: (_message, { projectName, sessionName }) => {
      // Invalidate session details to refetch status
      queryClient.invalidateQueries({
        queryKey: sessionKeys.detail(projectName, sessionName),
        refetchType: 'all',
      });
      // Invalidate list to update session count
      queryClient.invalidateQueries({
        queryKey: sessionKeys.list(projectName),
        refetchType: 'all',
      });
    },
  });
}

/**
 * Hook to start/restart a session
 */
export function useStartSession() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      projectName,
      sessionName,
    }: {
      projectName: string;
      sessionName: string;
    }) => sessionsApi.startSession(projectName, sessionName),
    onSuccess: (_response, { projectName, sessionName }) => {
      // Invalidate session details to refetch status
      queryClient.invalidateQueries({
        queryKey: sessionKeys.detail(projectName, sessionName),
        refetchType: 'all',
      });
      // Invalidate list to update session count
      queryClient.invalidateQueries({
        queryKey: sessionKeys.list(projectName),
        refetchType: 'all',
      });
    },
  });
}

/**
 * Hook to clone a session
 */
export function useCloneSession() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      projectName,
      sessionName,
      data,
    }: {
      projectName: string;
      sessionName: string;
      data: CloneAgenticSessionRequest;
    }) => sessionsApi.cloneSession(projectName, sessionName, data),
    onSuccess: (_session, { projectName }) => {
      // Invalidate and refetch sessions list to show new cloned session
      queryClient.invalidateQueries({
        queryKey: sessionKeys.list(projectName),
        refetchType: 'all', // Refetch both active and inactive queries
      });
    },
  });
}

/**
 * Hook to delete a session
 */
export function useDeleteSession() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      projectName,
      sessionName,
    }: {
      projectName: string;
      sessionName: string;
    }) => sessionsApi.deleteSession(projectName, sessionName),
    onSuccess: (_data, { projectName, sessionName }) => {
      // Remove from cache
      queryClient.removeQueries({
        queryKey: sessionKeys.detail(projectName, sessionName),
      });
      // Invalidate list
      queryClient.invalidateQueries({
        queryKey: sessionKeys.list(projectName),
        refetchType: 'all',
      });
    },
  });
}

/**
 * Hook to send chat message to interactive session
 */
export function useSendChatMessage() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      projectName,
      sessionName,
      content,
    }: {
      projectName: string;
      sessionName: string;
      content: string;
    }) => sessionsApi.sendChatMessage(projectName, sessionName, content),
    onSuccess: (_data, { projectName, sessionName }) => {
      // Invalidate messages to refetch
      queryClient.invalidateQueries({
        queryKey: sessionKeys.messages(projectName, sessionName),
      });
      // Invalidate session to update status
      queryClient.invalidateQueries({
        queryKey: sessionKeys.detail(projectName, sessionName),
      });
    },
  });
}

/**
 * Hook to send control message (interrupt, end_session)
 */
export function useSendControlMessage() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      projectName,
      sessionName,
      type,
    }: {
      projectName: string;
      sessionName: string;
      type: 'interrupt' | 'end_session';
    }) => sessionsApi.sendControlMessage(projectName, sessionName, type),
    onSuccess: (_data, { projectName, sessionName }) => {
      // Invalidate messages to refetch
      queryClient.invalidateQueries({
        queryKey: sessionKeys.messages(projectName, sessionName),
      });
      // Invalidate session to update status
      queryClient.invalidateQueries({
        queryKey: sessionKeys.detail(projectName, sessionName),
      });
    },
  });
}

/**
 * Hook to fetch K8s resources (job, pods, PVC) for a session
 */
export function useSessionK8sResources(projectName: string, sessionName: string) {
  return useQuery({
    queryKey: [...sessionKeys.detail(projectName, sessionName), 'k8s-resources'] as const,
    queryFn: () => sessionsApi.getSessionK8sResources(projectName, sessionName),
    enabled: !!projectName && !!sessionName,
    refetchInterval: 5000, // Poll every 5 seconds
  });
}

/**
 * Hook to continue a session (restarts the existing session)
 */
export function useContinueSession() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      projectName,
      parentSessionName,
    }: {
      projectName: string;
      parentSessionName: string;
    }) => {
      // Restart the existing session by updating its status to Creating
      return sessionsApi.startSession(projectName, parentSessionName);
    },
    onSuccess: (_response, { projectName, parentSessionName }) => {
      // Invalidate session details to refetch status
      queryClient.invalidateQueries({
        queryKey: sessionKeys.detail(projectName, parentSessionName),
        refetchType: 'all',
      });
      // Invalidate list to update session count
      queryClient.invalidateQueries({
        queryKey: sessionKeys.list(projectName),
        refetchType: 'all',
      });
    },
  });
}
</file>

<file path="components/frontend/src/types/api/github.ts">
/**
 * GitHub integration API types
 */

export type GitHubStatus = {
  installed: boolean;
  installationId?: number;
  githubUserId?: string;
  userId?: string;
  host?: string;
  updatedAt?: string;
  // Legacy OAuth fields (deprecated)
  connected?: boolean;
  username?: string;
  scopes?: string[];
};

export type GitHubFork = {
  name: string;
  fullName: string;
  owner: string;
  url: string;
  defaultBranch: string;
  private: boolean;
  createdAt: string;
  updatedAt: string;
};

export type ListForksResponse = {
  forks: GitHubFork[];
};

export type CreateForkRequest = {
  owner: string;
  repo: string;
  organization?: string;
};

export type CreateForkResponse = {
  fork: GitHubFork;
};

export type PRDiff = {
  files: PRDiffFile[];
  additions: number;
  deletions: number;
  changes: number;
};

export type PRDiffFile = {
  filename: string;
  status: 'added' | 'modified' | 'deleted' | 'renamed';
  additions: number;
  deletions: number;
  changes: number;
  patch?: string;
};

export type GetPRDiffResponse = {
  diff: PRDiff;
};

export type CreatePRRequest = {
  owner: string;
  repo: string;
  title: string;
  body: string;
  head: string;
  base: string;
  draft?: boolean;
};

export type CreatePRResponse = {
  url: string;
  number: number;
};

export type GitHubConnectRequest = {
  installationId: number;
  // Legacy OAuth fields (deprecated)
  code?: string;
  state?: string;
};

export type GitHubConnectResponse = {
  message: string;
  username: string;
};

export type GitHubDisconnectResponse = {
  message: string;
};

export type GitHubBranch = {
  name: string;
};

export type ListBranchesResponse = {
  branches: GitHubBranch[];
};
</file>

<file path="components/frontend/src/types/api/index.ts">
/**
 * API types index - public exports
 */

export * from './common';
export * from './projects';
export * from './sessions';
export * from './auth';
export * from './github';
</file>

<file path="components/frontend/src/types/api/projects.ts">
/**
 * Project API types
 * These types align with the backend Go structs
 */

export type ProjectStatus = 'active' | 'archived' | 'pending' | 'error' | 'terminating';

export type Project = {
  name: string;
  displayName: string; // Empty on vanilla k8s, set on OpenShift
  description?: string; // Empty on vanilla k8s, set on OpenShift
  labels: Record<string, string>;
  annotations: Record<string, string>;
  creationTimestamp: string;
  status: ProjectStatus;
  isOpenShift: boolean; // Indicates if cluster is OpenShift (affects available features)
  namespace?: string;
  resourceVersion?: string;
  uid?: string;
};

export type CreateProjectRequest = {
  name: string;
  displayName?: string; // Optional: only used on OpenShift
  description?: string; // Optional: only used on OpenShift
  labels?: Record<string, string>;
};

export type CreateProjectResponse = {
  project: Project;
};

export type UpdateProjectRequest = {
  displayName?: string;
  description?: string;
  labels?: Record<string, string>;
  annotations?: Record<string, string>;
};

export type UpdateProjectResponse = {
  project: Project;
};

export type ListProjectsResponse = {
  items: Project[];
};

export type GetProjectResponse = {
  project: Project;
};

export type DeleteProjectResponse = {
  message: string;
};

export type PermissionRole = 'view' | 'edit' | 'admin';

export type SubjectType = 'user' | 'group';

export type PermissionAssignment = {
  subjectType: SubjectType;
  subjectName: string;
  role: PermissionRole;
  permissions?: string[];
  memberCount?: number;
  grantedAt?: string;
  grantedBy?: string;
};

export type BotAccount = {
  name: string;
  description?: string;
};

export type Model = {
  name: string;
  displayName: string;
  costPerToken: number;
  maxTokens: number;
  default?: boolean;
};

export type ResourceLimits = {
  cpu: string;
  memory: string;
  storage: string;
  maxDurationMinutes: number;
};

export type Integration = {
  type: string;
  enabled: boolean;
};

export type AvailableResources = {
  models: Model[];
  resourceLimits: ResourceLimits;
  priorityClasses: string[];
  integrations: Integration[];
};

export type ProjectDefaults = {
  model: string;
  temperature: number;
  maxTokens: number;
  timeout: number;
  priorityClass: string;
};

export type ProjectConstraints = {
  maxConcurrentSessions: number;
  maxSessionsPerUser: number;
  maxCostPerSession: number;
  maxCostPerUserPerDay: number;
  allowSessionCloning: boolean;
  allowBotAccounts: boolean;
};

export type CurrentUsage = {
  activeSessions: number;
  totalCostToday: number;
};

export type ProjectCondition = {
  type: string;
  status: string;
  reason?: string;
  message?: string;
  lastTransitionTime?: string;
};
</file>

<file path="components/frontend/package.json">
{
  "name": "ambient-runner-frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@hookform/resolvers": "^5.2.1",
    "@radix-ui/react-accordion": "^1.2.12",
    "@radix-ui/react-avatar": "^1.1.10",
    "@radix-ui/react-checkbox": "^1.3.3",
    "@radix-ui/react-dropdown-menu": "^2.1.16",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-progress": "^1.1.7",
    "@radix-ui/react-select": "^2.2.6",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-tabs": "^1.1.13",
    "@radix-ui/react-toast": "^1.2.15",
    "@radix-ui/react-tooltip": "^1.2.8",
    "@tanstack/react-query": "^5.90.2",
    "@tanstack/react-query-devtools": "^5.90.2",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "highlight.js": "^11.11.1",
    "lucide-react": "^0.542.0",
    "next": "15.5.2",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-hook-form": "^7.62.0",
    "react-markdown": "^10.1.0",
    "react-resizable-panels": "^3.0.6",
    "rehype-highlight": "^7.0.2",
    "remark-gfm": "^4.0.1",
    "tailwind-merge": "^3.3.1",
    "zod": "^4.1.5"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.5.2",
    "tailwindcss": "^4",
    "tw-animate-css": "^1.3.8",
    "typescript": "^5"
  }
}
</file>

<file path="components/frontend/src/app/projects/[name]/sessions/new/model-configuration.tsx">
"use client";

import { Control } from "react-hook-form";
import { FormControl, FormDescription, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";

const models = [
  { value: "claude-sonnet-4-5", label: "Claude Sonnet 4.5" },
  { value: "claude-opus-4-1", label: "Claude Opus 4.1" },
  { value: "claude-haiku-4-5", label: "Claude Haiku 4.5" },
];

type ModelConfigurationProps = {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  control: Control<any>;
};

export function ModelConfiguration({ control }: ModelConfigurationProps) {
  return (
    <div className="space-y-4">
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <FormField
          control={control}
          name="model"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Model</FormLabel>
              <Select onValueChange={field.onChange} defaultValue={field.value}>
                <FormControl>
                  <SelectTrigger>
                    <SelectValue placeholder="Select a model" />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  {models.map((m) => (
                    <SelectItem key={m.value} value={m.value}>
                      {m.label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="temperature"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Temperature</FormLabel>
              <FormControl>
                <Input
                  type="number"
                  step="0.1"
                  min="0"
                  max="2"
                  {...field}
                  onChange={(e) => field.onChange(parseFloat(e.target.value))}
                />
              </FormControl>
              <FormDescription>Controls randomness (0.0 - 2.0)</FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <FormField
          control={control}
          name="maxTokens"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Max Output Tokens</FormLabel>
              <FormControl>
                <Input
                  type="number"
                  step="100"
                  min="100"
                  max="8000"
                  {...field}
                  onChange={(e) => field.onChange(parseInt(e.target.value))}
                />
              </FormControl>
              <FormDescription>Maximum response length (100-8000)</FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={control}
          name="timeout"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Timeout (seconds)</FormLabel>
              <FormControl>
                <Input
                  type="number"
                  step="60"
                  min="60"
                  max="1800"
                  {...field}
                  onChange={(e) => field.onChange(parseInt(e.target.value))}
                />
              </FormControl>
              <FormDescription>Session timeout (60-1800 seconds)</FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />
      </div>
    </div>
  );
}
</file>

<file path="components/frontend/src/app/projects/[name]/sessions/page.tsx">
'use client';

import { useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';

export default function ProjectSessionsListPage() {
  const params = useParams();
  const router = useRouter();
  const projectName = params?.name as string;

  // Redirect to main workspace page (sessions is the default view)
  useEffect(() => {
    if (projectName) {
      router.replace(`/projects/${projectName}`);
    }
  }, [projectName, router]);

  return null;
}
</file>

<file path="components/frontend/src/app/projects/page.tsx">
'use client';

import { useState } from 'react';
import Link from 'next/link';
import { formatDistanceToNow } from 'date-fns';
import { Plus, RefreshCw, Trash2, FolderOpen } from 'lucide-react';

import { Button } from '@/components/ui/button';
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import { useProjects, useDeleteProject } from '@/services/queries';
import { PageHeader } from '@/components/page-header';
import { EmptyState } from '@/components/empty-state';
import { ErrorMessage } from '@/components/error-message';
import { DestructiveConfirmationDialog } from '@/components/confirmation-dialog';
import { CreateWorkspaceDialog } from '@/components/create-workspace-dialog';
import { successToast, errorToast } from '@/hooks/use-toast';
import type { Project } from '@/types/api';

export default function ProjectsPage() {
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [projectToDelete, setProjectToDelete] = useState<Project | null>(null);
  const [showCreateDialog, setShowCreateDialog] = useState(false);

  // React Query hooks
  const { data: projects = [], isLoading, error, refetch } = useProjects();
  const deleteProjectMutation = useDeleteProject();

  const handleRefreshClick = () => {
    refetch();
  };

  const openDeleteDialog = (project: Project) => {
    setProjectToDelete(project);
    setShowDeleteDialog(true);
  };

  const closeDeleteDialog = () => {
    setShowDeleteDialog(false);
    setProjectToDelete(null);
  };

  const confirmDelete = async () => {
    if (!projectToDelete) return;

    deleteProjectMutation.mutate(projectToDelete.name, {
      onSuccess: () => {
        successToast(`Project "${projectToDelete.displayName || projectToDelete.name}" deleted successfully`);
        closeDeleteDialog();
      },
      onError: (error) => {
        errorToast(error instanceof Error ? error.message : 'Failed to delete project');
      },
    });
  };

  // Loading state
  if (isLoading) {
    return (
      <div className="min-h-screen bg-[#f8fafc]">
        <div className="container mx-auto p-6">
          <div className="flex items-center justify-center h-64">
            <RefreshCw className="h-8 w-8 animate-spin" />
            <span className="ml-2">Loading workspaces...</span>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-[#f8fafc]">
      {/* Sticky header */}
      <div className="sticky top-0 z-20 bg-white border-b">
        <div className="container mx-auto px-6 py-4">
          <PageHeader
            title="Workspaces"
            description="Select or create a workspace to get started"
          />
        </div>
      </div>

      <div className="container mx-auto p-0">
        {/* Error state */}
        {error && (
          <div className="px-6 pt-4">
            <ErrorMessage error={error} onRetry={() => refetch()} />
          </div>
        )}

        {/* Content */}
        <div className="px-6 pt-4">
        <Card>
          <CardHeader>
            <div className="flex items-start justify-between">
              <div>
                <CardTitle>Workspaces</CardTitle>
                <CardDescription>
                  Configure and manage workspace settings, resource limits, and access
                  controls
                </CardDescription>
              </div>
              <div className="flex gap-2">
                <Button
                  variant="outline"
                  onClick={handleRefreshClick}
                  disabled={isLoading}
                >
                  <RefreshCw
                    className={`w-4 h-4 mr-2 ${isLoading ? 'animate-spin' : ''}`}
                  />
                  Refresh
                </Button>
                <Button onClick={() => setShowCreateDialog(true)}>
                  <Plus className="w-4 h-4 mr-2" />
                  New Workspace
                </Button>
              </div>
            </div>
          </CardHeader>
          <CardContent>
            {projects.length === 0 ? (
              <EmptyState
                icon={FolderOpen}
                title="No projects found"
                description="Get started by creating your first project"
                action={{
                  label: 'Create Workspace',
                  onClick: () => setShowCreateDialog(true),
                }}
              />
            ) : (
              <div className="overflow-x-auto">
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead className="min-w-[200px]">Name</TableHead>
                      <TableHead className="hidden md:table-cell">
                        Description
                      </TableHead>
                      <TableHead className="hidden lg:table-cell">
                        Created
                      </TableHead>
                      <TableHead className="w-[50px]">Actions</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {projects.map((project) => (
                      <TableRow key={project.name}>
                        <TableCell className="font-medium min-w-[200px]">
                          <Link
                            href={`/projects/${project.name}`}
                            className="text-blue-600 hover:underline hover:text-blue-800 transition-colors block"
                          >
                            <div>
                              <div className="font-medium">
                                {project.displayName || project.name}
                              </div>
                              <div className="text-xs text-gray-500 font-normal">
                                {project.name}
                              </div>
                            </div>
                          </Link>
                        </TableCell>
                        <TableCell className="hidden md:table-cell max-w-[200px]">
                          <span
                            className="truncate block"
                            title={project.description || ''}
                          >
                            {project.description || ''}
                          </span>
                        </TableCell>
                        <TableCell className="hidden lg:table-cell">
                          {project.creationTimestamp &&
                            formatDistanceToNow(
                              new Date(project.creationTimestamp),
                              { addSuffix: true }
                            )}
                        </TableCell>
                        <TableCell>
                          <Button
                            variant="ghost"
                            size="sm"
                            className="h-8 w-8 p-0"
                            onClick={() => openDeleteDialog(project)}
                          >
                            <Trash2 className="h-4 w-4" />
                          </Button>
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </div>
            )}
          </CardContent>
        </Card>
      </div>

        {/* Delete confirmation dialog */}
        <DestructiveConfirmationDialog
          open={showDeleteDialog}
          onOpenChange={setShowDeleteDialog}
          onConfirm={confirmDelete}
          title="Delete workspace"
          description={`Are you sure you want to delete workspace "${projectToDelete?.name}"? This will permanently remove the workspace and all related resources. This action cannot be undone.`}
          confirmText="Delete"
          loading={deleteProjectMutation.isPending}
        />

        {/* Create workspace dialog */}
        <CreateWorkspaceDialog
          open={showCreateDialog}
          onOpenChange={setShowCreateDialog}
        />
      </div>
    </div>
  );
}
</file>

<file path="components/frontend/src/components/session/WorkspaceTab.tsx">
"use client";

import React from "react";
import { Button } from "@/components/ui/button";
import { RefreshCw, FolderOpen, HardDrive } from "lucide-react";
import { Badge } from "@/components/ui/badge";
import { FileTree, type FileTreeNode } from "@/components/file-tree";
import type { AgenticSession } from "@/types/agentic-session";
import { EmptyState } from "@/components/empty-state";

export type WorkspaceTabProps = {
  session: AgenticSession;
  wsLoading: boolean;
  wsUnavailable: boolean;
  wsTree: FileTreeNode[];
  wsSelectedPath?: string;
  onRefresh: (background?: boolean) => void;
  onSelect: (node: FileTreeNode) => void;
  onToggle: (node: FileTreeNode) => void;
  k8sResources?: {
    pvcName?: string;
    pvcExists?: boolean;
    pvcSize?: string;
  };
  contentPodError?: string | null;
  onRetrySpawn?: () => void;
};

const WorkspaceTab: React.FC<WorkspaceTabProps> = ({ session, wsLoading, wsUnavailable, wsTree, wsSelectedPath, onRefresh, onSelect, onToggle, k8sResources, contentPodError, onRetrySpawn }) => {
  if (wsLoading) {
    return (
      <div className="flex items-center justify-center h-32 text-sm text-muted-foreground">
        <RefreshCw className="animate-spin h-4 w-4 mr-2" /> Loading workspace...
      </div>
    );
  }
  
  // Show error with retry button if content pod failed to spawn
  if (contentPodError) {
    return (
      <div className="flex flex-col items-center justify-center h-64 text-sm text-center p-6">
        <div className="text-destructive font-medium mb-2">Workspace Viewer Error</div>
        <div className="text-muted-foreground mb-4 max-w-md">{contentPodError}</div>
        {onRetrySpawn && (
          <Button onClick={onRetrySpawn} variant="outline" size="sm">
            <RefreshCw className="h-4 w-4 mr-2" /> Retry
          </Button>
        )}
      </div>
    );
  }
  
  if (wsUnavailable) {
    return (
      <div className="flex items-center justify-center h-32 text-sm text-muted-foreground text-center">
        {session.status?.phase === "Pending" || session.status?.phase === "Creating" ? (
          <div>
            <div className="flex items-center justify-center"><RefreshCw className="animate-spin h-4 w-4 mr-2" /> Service not ready</div>
            <div className="mt-2">{session.status?.message || "Preparing session workspace..."}</div>
          </div>
        ) : (
          <div>
            <div className="font-medium">Workspace unavailable</div>
            <div className="mt-1">Access to the PVC is not available when the session is {session.status?.phase || "Unavailable"}.</div>
          </div>
        )}
      </div>
    );
  }
  return (
    <div className="grid grid-cols-1 gap-0">
      <div className="border rounded-md overflow-hidden">
        <div className="p-3 border-b flex items-center justify-between">
          <div className="flex-1">
            {k8sResources?.pvcName ? (
              <div className="flex items-center gap-2">
                <Badge variant="outline" className="text-xs">
                  <HardDrive className="w-3 h-3 mr-1" />
                  PVC
                </Badge>
                <span className="font-mono text-xs text-muted-foreground">{k8sResources.pvcName}</span>
                <Badge className={`text-xs ${k8sResources.pvcExists ? 'bg-green-100 text-green-800 border-green-300' : 'bg-red-100 text-red-800 border-red-300'}`}>
                  {k8sResources.pvcExists ? 'Exists' : 'Not Found'}
                </Badge>
                {k8sResources.pvcSize && (
                  <span className="text-xs text-muted-foreground">{k8sResources.pvcSize}</span>
                )}
              </div>
            ) : (
              <p className="text-xs text-muted-foreground">{wsTree.length} items</p>
            )}
          </div>
          <Button size="sm" variant="outline" onClick={() => onRefresh(false)} disabled={wsLoading} className="h-8">
            <RefreshCw className="h-4 w-4" />
          </Button>
        </div>
        <div className="p-2">
          {wsTree.length === 0 ? (
            <EmptyState
              icon={FolderOpen}
              title="No files yet"
              description="The workspace is empty. Files will appear here as the session progresses."
            />
          ) : (
            <FileTree nodes={wsTree} selectedPath={wsSelectedPath} onSelect={onSelect} onToggle={onToggle} />
          )}
        </div>
      </div>
      {/* TODO: Artifact/File Viewer - Temporarily hidden until Artifact Viewer feature is implemented
      <div className="overflow-auto">
        <Card className="m-3">
          <CardContent className="p-4">
            {wsSelectedPath ? (
              <>
                <div className="flex items-center justify-between mb-2">
                  <div className="text-sm">
                    <span className="font-medium">{wsSelectedPath.split('/').pop()}</span>
                    <Badge variant="outline" className="ml-2">{wsSelectedPath}</Badge>
                  </div>
                  <div className="flex items-center gap-2">
                    <Button size="sm" onClick={async () => { await onSave(wsSelectedPath, wsFileContent); }}>Save</Button>
                  </div>
                </div>
                <textarea
                  className="w-full h-[60vh] bg-gray-900 text-gray-100 p-4 rounded overflow-auto text-sm font-mono"
                  value={wsFileContent}
                  onChange={(e) => setWsFileContent(e.target.value)}
                />
              </>
            ) : (
              <EmptyState
                icon={FileText}
                title="No file selected"
                description="Select a file from the tree to view and edit its contents."
              />
            )}
          </CardContent>
        </Card>
      </div>
      */}
    </div>
  );
};

export default WorkspaceTab;
</file>

<file path="components/frontend/src/components/ui/message.tsx">
"use client";

import React from "react";
import { cn } from "@/lib/utils";
import { Badge } from "@/components/ui/badge";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";
import type { Components } from "react-markdown";

export type MessageRole = "bot" | "user";

export type MessageProps = {
  role: MessageRole;
  content: string;
  isLoading?: boolean;
  avatar?: string;
  name?: string;
  className?: string;
  components?: Components;
  borderless?: boolean;
  actions?: React.ReactNode;
};

const defaultComponents: Components = {
  code: ({
    inline,
    className,
    children,
    ...props
  }: {
    inline?: boolean;
    className?: string;
    children?: React.ReactNode;
  } & React.HTMLAttributes<HTMLElement>) => {
    return inline ? (
      <code
        className="bg-gray-100 px-1 py-0.5 rounded text-xs"
        {...(props as React.HTMLAttributes<HTMLElement>)}
      >
        {children}
      </code>
    ) : (
      <pre className="bg-gray-800 text-gray-100 p-2 rounded text-xs overflow-x-auto">
        <code
          className={className}
          {...(props as React.HTMLAttributes<HTMLElement>)}
        >
          {children}
        </code>
      </pre>
    );
  },
  p: ({ children }) => (
    <p className="text-gray-600 leading-relaxed mb-2 text-sm">{children}</p>
  ),
  h1: ({ children }) => (
    <h1 className="text-lg font-bold text-gray-800 mb-2">{children}</h1>
  ),
  h2: ({ children }) => (
    <h2 className="text-md font-semibold text-gray-800 mb-2">{children}</h2>
  ),
  h3: ({ children }) => (
    <h3 className="text-sm font-medium text-gray-800 mb-1">{children}</h3>
  ),
};

const LOADING_MESSAGES = [
  "Pretending to be productive",
  "Downloading more RAM",
  "Consulting the magic 8-ball",
  "Teaching bugs to behave",
  "Brewing digital coffee",
  "Rolling for initiative",
  "Surfing the data waves",
  "Juggling bits and bytes",
  "Tipping my fedora",
  "Reticulating splines",
];

export const LoadingDots = () => {
  const [messageIndex, setMessageIndex] = React.useState(() =>
    Math.floor(Math.random() * LOADING_MESSAGES.length)
  );

  React.useEffect(() => {
    const intervalId = setInterval(() => {
      setMessageIndex((prevIndex) => (prevIndex + 1) % LOADING_MESSAGES.length);
    }, 8000);
    return () => clearInterval(intervalId);
  }, []);

  return (
    <div className="flex items-center mt-2">
      <svg
        width="24"
        height="8"
        viewBox="0 0 24 8"
        xmlns="http://www.w3.org/2000/svg"
        className="mr-2"
      >
        <style>
          {`
            @keyframes loadingDotPulse {
              0%, 60%, 100% {
                opacity: 0.3;
              }
              30% {
                opacity: 1;
              }
            }
            .loading-dot {
              animation: loadingDotPulse 1.4s infinite ease-in-out;
            }
            .loading-dot-1 {
              animation-delay: 0s;
            }
            .loading-dot-2 {
              animation-delay: 0.2s;
            }
            .loading-dot-3 {
              animation-delay: 0.4s;
            }
          `}
        </style>
        <circle
          className="loading-dot loading-dot-1"
          cx="4"
          cy="4"
          r="3"
          fill="#3b82f6"
        />
        <circle
          className="loading-dot loading-dot-2"
          cx="12"
          cy="4"
          r="3"
          fill="#3b82f6"
        />
        <circle
          className="loading-dot loading-dot-3"
          cx="20"
          cy="4"
          r="3"
          fill="#3b82f6"
        />
      </svg>
      <span className="ml-2 text-xs text-gray-400">{LOADING_MESSAGES[messageIndex]}</span>
    </div>
  );
};

export const Message = React.forwardRef<HTMLDivElement, MessageProps>(
  (
    { role, content, isLoading, className, components, borderless, actions, ...props },
    ref
  ) => {
    const isBot = role === "bot";
    const avatarBg = isBot ? "bg-blue-600" : "bg-green-600";
    const avatarText = isBot ? "AI" : "U";
    const displayName = isBot ? "Claude AI" : "User";

    const avatar = (
      <div className="flex-shrink-0">
      <div
        className={cn(
          "w-8 h-8 rounded-full flex items-center justify-center",
          avatarBg,
          isLoading && "animate-pulse"
        )}
      >
        <span className="text-white text-xs font-semibold">
          {avatarText}
        </span>
      </div>
    </div>
    )

    return (
      <div ref={ref} className={cn("mb-4", className)} {...props}>
        <div className="flex items-start space-x-3">
          {/* Avatar */}
         {isBot ? avatar : null}

          {/* Message Content */}
          <div className="flex-1 min-w-0">
            <div className={cn(borderless ? "p-0" : "bg-white rounded-lg border shadow-sm p-3")}> 
              {/* Header */}
              <div className={cn("flex items-center", borderless ? "mb-1" : "mb-2")}> 
                <Badge
                  variant="outline"
                  className={cn("text-xs", isLoading && "animate-pulse")}
                >
                  {displayName}
                </Badge>
              </div>

              {/* Content */}
              <div className="text-sm text-gray-800">
                {isLoading ? (
                  <div>
                    <div className="text-sm text-gray-600 mb-2">{content}</div>
                    <LoadingDots />
                  </div>
                ) : (
                  <ReactMarkdown
                    remarkPlugins={[remarkGfm]}
                    components={components || defaultComponents}
                  >
                    {content}
                  </ReactMarkdown>
                )}
              </div>

              {actions ? (
                <div className={cn(borderless ? "mt-1" : "mt-3 pt-2 border-t")}>{actions}</div>
              ) : null}
            </div>
          </div>

          {isBot ? null : avatar}
        </div>
      </div>
    );
  }
);

Message.displayName = "Message";
</file>

<file path="components/frontend/src/components/ui/system-message.tsx">
import React from "react";
import { cn } from "@/lib/utils";

type SystemMessageData = {
  message?: string;
  [key: string]: unknown;
};

export type SystemMessageProps = {
  subtype?: string;
  data: SystemMessageData;
  className?: string;
  borderless?: boolean;
};

export const SystemMessage: React.FC<SystemMessageProps> = ({ data, className }) => {
  // Expect a simple string in data.message; fallback to JSON.stringify
  const text: string = typeof (data?.message) === 'string' ? data.message : (typeof data === 'string' ? data : JSON.stringify(data ?? {}, null, 2));

  // Compact style: Just small grey text, no card, no avatar
  return (
    <div className={cn("my-1 px-2", className)}>
      <p className="text-xs text-gray-400 italic">
        {text}
      </p>
    </div>
  );
};

export default SystemMessage;
</file>

<file path="components/frontend/src/components/workspace-sections/settings-section.tsx">
"use client";

import { useEffect, useState } from "react";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Button } from "@/components/ui/button";
import { Save, Loader2, Info, AlertTriangle } from "lucide-react";
import { Plus, Trash2, Eye, EyeOff, ChevronDown, ChevronRight } from "lucide-react";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { successToast, errorToast } from "@/hooks/use-toast";
import { useProject, useUpdateProject } from "@/services/queries/use-projects";
import { useSecretsValues, useUpdateSecrets, useIntegrationSecrets, useUpdateIntegrationSecrets } from "@/services/queries/use-secrets";
import { useClusterInfo } from "@/hooks/use-cluster-info";
import { useMemo } from "react";

type SettingsSectionProps = {
  projectName: string;
};

export function SettingsSection({ projectName }: SettingsSectionProps) {
  const [formData, setFormData] = useState({ displayName: "", description: "" });
  const [secrets, setSecrets] = useState<Array<{ key: string; value: string }>>([]);
  const [showValues, setShowValues] = useState<Record<number, boolean>>({});
  const [anthropicApiKey, setAnthropicApiKey] = useState<string>("");
  const [showAnthropicKey, setShowAnthropicKey] = useState<boolean>(false);
  const [gitUserName, setGitUserName] = useState<string>("");
  const [gitUserEmail, setGitUserEmail] = useState<string>("");
  const [gitToken, setGitToken] = useState<string>("");
  const [showGitToken, setShowGitToken] = useState<boolean>(false);
  const [jiraUrl, setJiraUrl] = useState<string>("");
  const [jiraProject, setJiraProject] = useState<string>("");
  const [jiraEmail, setJiraEmail] = useState<string>("");
  const [jiraToken, setJiraToken] = useState<string>("");
  const [showJiraToken, setShowJiraToken] = useState<boolean>(false);
  const [anthropicExpanded, setAnthropicExpanded] = useState<boolean>(false);
  const [githubExpanded, setGithubExpanded] = useState<boolean>(false);
  const [jiraExpanded, setJiraExpanded] = useState<boolean>(false);
  const FIXED_KEYS = useMemo(() => ["ANTHROPIC_API_KEY","GIT_USER_NAME","GIT_USER_EMAIL","GITHUB_TOKEN","JIRA_URL","JIRA_PROJECT","JIRA_EMAIL","JIRA_API_TOKEN"] as const, []);

  // React Query hooks
  const { data: project, isLoading: projectLoading } = useProject(projectName);
  const { data: runnerSecrets } = useSecretsValues(projectName);  // ambient-runner-secrets (ANTHROPIC_API_KEY)
  const { data: integrationSecrets } = useIntegrationSecrets(projectName);  // ambient-non-vertex-integrations (GITHUB_TOKEN, GIT_USER_*, JIRA_*, custom)
  const { vertexEnabled } = useClusterInfo();
  const updateProjectMutation = useUpdateProject();
  const updateSecretsMutation = useUpdateSecrets();
  const updateIntegrationSecretsMutation = useUpdateIntegrationSecrets();

  // Sync project data to form
  useEffect(() => {
    if (project) {
      setFormData({ displayName: project.displayName || "", description: project.description || "" });
    }
  }, [project]);

  // Sync secrets values to state (merge both secrets)
  useEffect(() => {
    const allSecrets = [...(runnerSecrets || []), ...(integrationSecrets || [])];
    if (allSecrets.length > 0) {
      const byKey: Record<string, string> = Object.fromEntries(allSecrets.map(s => [s.key, s.value]));
      setAnthropicApiKey(byKey["ANTHROPIC_API_KEY"] || "");
      setGitUserName(byKey["GIT_USER_NAME"] || "");
      setGitUserEmail(byKey["GIT_USER_EMAIL"] || "");
      setGitToken(byKey["GITHUB_TOKEN"] || "");
      setJiraUrl(byKey["JIRA_URL"] || "");
      setJiraProject(byKey["JIRA_PROJECT"] || "");
      setJiraEmail(byKey["JIRA_EMAIL"] || "");
      setJiraToken(byKey["JIRA_API_TOKEN"] || "");
      setSecrets(allSecrets.filter(s => !FIXED_KEYS.includes(s.key as typeof FIXED_KEYS[number])));
    }
  }, [runnerSecrets, integrationSecrets, FIXED_KEYS]);

  const handleSave = () => {
    if (!project) return;
    updateProjectMutation.mutate(
      {
        name: projectName,
        data: {
          displayName: formData.displayName.trim(),
          description: formData.description.trim() || undefined,
          annotations: project.annotations || {},
        },
      },
      {
        onSuccess: () => {
          successToast("Project settings updated successfully!");
        },
        onError: (error) => {
          const message = error instanceof Error ? error.message : "Failed to update project";
          errorToast(message);
        },
      }
    );
  };

  // Save Anthropic API key separately (ambient-runner-secrets)
  const handleSaveAnthropicKey = () => {
    if (!projectName) return;

    const runnerData: Record<string, string> = {};
    if (anthropicApiKey) runnerData["ANTHROPIC_API_KEY"] = anthropicApiKey;

    if (Object.keys(runnerData).length === 0) {
      errorToast("No Anthropic API key to save");
      return;
    }

    updateSecretsMutation.mutate(
      {
        projectName,
        secrets: Object.entries(runnerData).map(([key, value]) => ({ key, value })),
      },
      {
        onSuccess: () => {
          successToast("Saved to ambient-runner-secrets");
        },
        onError: (error) => {
          const message = error instanceof Error ? error.message : "Failed to save Anthropic API key";
          errorToast(message);
        },
      }
    );
  };

  // Save integration secrets separately (ambient-non-vertex-integrations)
  const handleSaveIntegrationSecrets = () => {
    if (!projectName) return;

    const integrationData: Record<string, string> = {};

    // GITHUB_TOKEN, GIT_USER_*, JIRA_*, custom keys go to ambient-non-vertex-integrations
    if (gitUserName) integrationData["GIT_USER_NAME"] = gitUserName;
    if (gitUserEmail) integrationData["GIT_USER_EMAIL"] = gitUserEmail;
    if (gitToken) integrationData["GITHUB_TOKEN"] = gitToken;
    if (jiraUrl) integrationData["JIRA_URL"] = jiraUrl;
    if (jiraProject) integrationData["JIRA_PROJECT"] = jiraProject;
    if (jiraEmail) integrationData["JIRA_EMAIL"] = jiraEmail;
    if (jiraToken) integrationData["JIRA_API_TOKEN"] = jiraToken;
    for (const { key, value } of secrets) {
      if (!key) continue;
      if (FIXED_KEYS.includes(key as typeof FIXED_KEYS[number])) continue;
      integrationData[key] = value ?? "";
    }

    if (Object.keys(integrationData).length === 0) {
      errorToast("No integration secrets to save");
      return;
    }

    updateIntegrationSecretsMutation.mutate(
      {
        projectName,
        secrets: Object.entries(integrationData).map(([key, value]) => ({ key, value })),
      },
      {
        onSuccess: () => {
          successToast("Saved to ambient-non-vertex-integrations");
        },
        onError: (error) => {
          const message = error instanceof Error ? error.message : "Failed to save integration secrets";
          errorToast(message);
        },
      }
    );
  };

  const addSecretRow = () => {
    setSecrets((prev) => [...prev, { key: "", value: "" }]);
  };

  const removeSecretRow = (idx: number) => {
    setSecrets((prev) => prev.filter((_, i) => i !== idx));
  };

  return (
    <div className="flex-1 space-y-6">
      {/* Only show project metadata editor on OpenShift */}
      {project?.isOpenShift ? (
        <Card>
          <CardHeader>
            <CardTitle>General Settings</CardTitle>
            <CardDescription>Basic workspace configuration</CardDescription>
          </CardHeader>
          <Separator />
          <CardContent className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="displayName">Display Name</Label>
              <Input
                id="displayName"
                value={formData.displayName}
                onChange={(e) => setFormData((prev) => ({ ...prev, displayName: e.target.value }))}
                placeholder="My Awesome Workspace"
                maxLength={100}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="workspaceName">Workspace Name</Label>
              <Input
                id="workspaceName"
                value={projectName}
                readOnly
                disabled
                className="bg-muted/80 text-muted-foreground"
              />
              <p className="text-sm text-muted-foreground">Workspace name cannot be changed after creation</p>
            </div>
            <div className="space-y-2">
              <Label htmlFor="description">Description</Label>
              <Textarea
                id="description"
                value={formData.description}
                onChange={(e) => setFormData((prev) => ({ ...prev, description: e.target.value }))}
                placeholder="Describe the purpose and goals of this workspace..."
                maxLength={500}
                rows={3}
              />
            </div>
            <div className="pt-2">
              <Button onClick={handleSave} disabled={updateProjectMutation.isPending || projectLoading || !project}>
                {updateProjectMutation.isPending ? (
                  <>
                    <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                    Saving...
                  </>
                ) : (
                  <>
                    <Save className="w-4 h-4 mr-2" />
                    Save Changes
                  </>
                )}
              </Button>
            </div>
          </CardContent>
        </Card>
      ) : (
        <Alert>
          <Info className="h-4 w-4" />
          <AlertDescription>
            Running on vanilla Kubernetes. Project display name and description editing is not available.
            The project namespace is: <strong>{projectName}</strong>
          </AlertDescription>
        </Alert>
      )}

      <Card>
        <CardHeader>
          <CardTitle>Integration Secrets</CardTitle>
          <CardDescription>
            Configure environment variables for workspace runners. All values are injected into runner pods.
          </CardDescription>
        </CardHeader>
        <Separator />
        <CardContent className="space-y-6">
          {/* Warning about centralized integrations */}
          <Alert variant="warning">
            <AlertTriangle />
            <AlertTitle>Centralized Integrations Recommended</AlertTitle>
            <AlertDescription>
              <p>Cluster-level integrations (Vertex AI, GitHub App, Jira OAuth) are more secure than personal tokens. Only configure these secrets if centralized integrations are unavailable.</p>
            </AlertDescription>
          </Alert>

          {/* Anthropic Section */}
          <div className="border rounded-lg">
            <button
              type="button"
              onClick={() => setAnthropicExpanded(!anthropicExpanded)}
              className="w-full flex items-center justify-between p-3 hover:bg-muted/50 transition-colors rounded-lg"
            >
              <div className="flex items-center gap-2">
                {anthropicExpanded ? <ChevronDown className="h-4 w-4" /> : <ChevronRight className="h-4 w-4" />}
                <span className="font-semibold">Anthropic</span>
                {anthropicApiKey && <span className="text-xs text-muted-foreground">(configured)</span>}
              </div>
            </button>
            {anthropicExpanded && (
              <div className="px-3 pb-3 space-y-3 border-t pt-3">
                {vertexEnabled && anthropicApiKey && (
                  <Alert variant="warning">
                    <AlertTriangle />
                    <AlertDescription>
                      Vertex AI is enabled for this cluster. The ANTHROPIC_API_KEY will be ignored. Sessions will use Vertex AI instead.
                    </AlertDescription>
                  </Alert>
                )}
                <div className="space-y-2">
                  <Label htmlFor="anthropicApiKey">ANTHROPIC_API_KEY</Label>
                  <div className="text-xs text-muted-foreground">Your Anthropic API key for Claude Code runner (saved to ambient-runner-secrets)</div>
                  <div className="flex items-center gap-2">
                    <Input
                      id="anthropicApiKey"
                      type={showAnthropicKey ? "text" : "password"}
                      placeholder="sk-ant-..."
                      value={anthropicApiKey}
                      onChange={(e) => setAnthropicApiKey(e.target.value)}
                      className="flex-1"
                    />
                    <Button type="button" variant="ghost" size="sm" onClick={() => setShowAnthropicKey((v) => !v)} aria-label={showAnthropicKey ? "Hide key" : "Show key"}>
                      {showAnthropicKey ? <EyeOff className="w-4 h-4" /> : <Eye className="w-4 h-4" />}
                    </Button>
                  </div>
                </div>
                <div className="pt-2">
                  <Button onClick={handleSaveAnthropicKey} disabled={updateSecretsMutation.isPending} size="sm">
                    {updateSecretsMutation.isPending ? (
                      <>
                        <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                        Saving...
                      </>
                    ) : (
                      <>
                        <Save className="w-4 h-4 mr-2" />
                        Save Anthropic Key
                      </>
                    )}
                  </Button>
                </div>
              </div>
            )}
          </div>

          {/* GitHub Integration Section */}
          <div className="border rounded-lg">
            <button
              type="button"
              onClick={() => setGithubExpanded(!githubExpanded)}
              className="w-full flex items-center justify-between p-3 hover:bg-muted/50 transition-colors rounded-lg"
            >
              <div className="flex items-center gap-2">
                {githubExpanded ? <ChevronDown className="h-4 w-4" /> : <ChevronRight className="h-4 w-4" />}
                <span className="font-semibold">GitHub Integration</span>
                {(gitUserName || gitUserEmail || gitToken) && <span className="text-xs text-muted-foreground">(configured)</span>}
              </div>
            </button>
            {githubExpanded && (
              <div className="px-3 pb-3 space-y-3 border-t pt-3">
                <div className="text-xs text-muted-foreground">Configure Git credentials for repository operations (clone, commit, push)</div>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                  <div className="space-y-1">
                    <Label htmlFor="gitUserName">GIT_USER_NAME</Label>
                    <Input id="gitUserName" placeholder="Your Name" value={gitUserName} onChange={(e) => setGitUserName(e.target.value)} />
                  </div>
                  <div className="space-y-1">
                    <Label htmlFor="gitUserEmail">GIT_USER_EMAIL</Label>
                    <Input id="gitUserEmail" placeholder="you@example.com" value={gitUserEmail} onChange={(e) => setGitUserEmail(e.target.value)} />
                  </div>
                </div>
                <div className="space-y-2">
                  <Label htmlFor="gitToken">GITHUB_TOKEN</Label>
                  <div className="text-xs text-muted-foreground mb-1">GitHub personal access token or fine-grained token for git operations and API access</div>
                  <div className="flex items-center gap-2">
                    <Input
                      id="gitToken"
                      type={showGitToken ? "text" : "password"}
                      placeholder="ghp_... or glpat-..."
                      value={gitToken}
                      onChange={(e) => setGitToken(e.target.value)}
                      className="flex-1"
                    />
                    <Button type="button" variant="ghost" size="sm" onClick={() => setShowGitToken((v) => !v)} aria-label={showGitToken ? "Hide token" : "Show token"}>
                      {showGitToken ? <EyeOff className="w-4 h-4" /> : <Eye className="w-4 h-4" />}
                    </Button>
                  </div>
                </div>
              </div>
            )}
          </div>

          {/* Jira Integration Section */}
          <div className="border rounded-lg">
            <button
              type="button"
              onClick={() => setJiraExpanded(!jiraExpanded)}
              className="w-full flex items-center justify-between p-3 hover:bg-muted/50 transition-colors rounded-lg"
            >
              <div className="flex items-center gap-2">
                {jiraExpanded ? <ChevronDown className="h-4 w-4" /> : <ChevronRight className="h-4 w-4" />}
                <span className="font-semibold">Jira Integration</span>
                {(jiraUrl || jiraProject || jiraEmail || jiraToken) && <span className="text-xs text-muted-foreground">(configured)</span>}
              </div>
            </button>
            {jiraExpanded && (
              <div className="px-3 pb-3 space-y-3 border-t pt-3">
                <div className="text-xs text-muted-foreground">Configure Jira integration for issue management</div>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                  <div className="space-y-1">
                    <Label htmlFor="jiraUrl">JIRA_URL</Label>
                    <Input id="jiraUrl" placeholder="https://your-domain.atlassian.net" value={jiraUrl} onChange={(e) => setJiraUrl(e.target.value)} />
                  </div>
                  <div className="space-y-1">
                    <Label htmlFor="jiraProject">JIRA_PROJECT</Label>
                    <Input id="jiraProject" placeholder="ABC" value={jiraProject} onChange={(e) => setJiraProject(e.target.value)} />
                  </div>
                  <div className="space-y-1">
                    <Label htmlFor="jiraEmail">JIRA_EMAIL</Label>
                    <Input id="jiraEmail" placeholder="you@example.com" value={jiraEmail} onChange={(e) => setJiraEmail(e.target.value)} />
                  </div>
                  <div className="space-y-1">
                    <Label htmlFor="jiraToken">JIRA_API_TOKEN</Label>
                    <div className="flex items-center gap-2">
                      <Input id="jiraToken" type={showJiraToken ? "text" : "password"} placeholder="token" value={jiraToken} onChange={(e) => setJiraToken(e.target.value)} />
                      <Button type="button" variant="ghost" size="sm" onClick={() => setShowJiraToken((v) => !v)} aria-label={showJiraToken ? "Hide token" : "Show token"}>
                        {showJiraToken ? <EyeOff className="w-4 h-4" /> : <Eye className="w-4 h-4" />}
                      </Button>
                    </div>
                  </div>
                </div>
              </div>
            )}
          </div>

          {/* Custom Environment Variables Section */}
          <div className="space-y-3 pt-2">
            <div className="flex items-center justify-between">
              <div>
                <Label className="text-base font-semibold">Custom Environment Variables</Label>
                <div className="text-xs text-muted-foreground mt-1">Add any additional environment variables for your integrations</div>
              </div>
            </div>
            <div className="space-y-2">
              {secrets.map((item, idx) => (
                <div key={idx} className="flex gap-2 items-center">
                  <Input
                    value={item.key}
                    onChange={(e) =>
                      setSecrets((prev) => prev.map((it, i) => (i === idx ? { ...it, key: e.target.value } : it)))
                    }
                    placeholder="KEY"
                    className="w-1/3"
                  />
                  <div className="flex-1 flex items-center gap-2">
                    <Input
                      type={showValues[idx] ? "text" : "password"}
                      value={item.value}
                      onChange={(e) =>
                        setSecrets((prev) => prev.map((it, i) => (i === idx ? { ...it, value: e.target.value } : it)))
                      }
                      placeholder="value"
                      className="flex-1"
                    />
                    <Button
                      type="button"
                      variant="ghost"
                      size="sm"
                      onClick={() => setShowValues((prev) => ({ ...prev, [idx]: !prev[idx] }))}
                      aria-label={showValues[idx] ? "Hide value" : "Show value"}
                    >
                      {showValues[idx] ? <EyeOff className="w-4 h-4" /> : <Eye className="w-4 h-4" />}
                    </Button>
                  </div>
                  <Button variant="ghost" size="sm" onClick={() => removeSecretRow(idx)} aria-label="Remove row">
                    <Trash2 className="w-4 h-4" />
                  </Button>
                </div>
              ))}
            </div>
            <Button variant="outline" size="sm" onClick={addSecretRow}>
              <Plus className="w-4 h-4 mr-2" /> Add Environment Variable
            </Button>
          </div>

          {/* Save Button */}
          <div className="pt-4 border-t">
            <Button
              onClick={handleSaveIntegrationSecrets}
              disabled={updateIntegrationSecretsMutation.isPending}
            >
              {updateIntegrationSecretsMutation.isPending ? (
                <>
                  <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                  Saving...
                </>
              ) : (
                <>
                  <Save className="w-4 h-4 mr-2" />
                  Save Integration Secrets
                </>
              )}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="components/frontend/src/lib/env.ts">
/**
 * Environment variable configuration
 * Provides type-safe access to environment variables
 */

type Environment = 'development' | 'production' | 'test';

type EnvConfig = {
  // Node environment
  NODE_ENV: Environment;

  // Backend API URL (server-side only)
  BACKEND_URL: string;

  // GitHub configuration (public)
  GITHUB_APP_SLUG: string;

  // Version information (public, optional)
  VTEAM_VERSION?: string;

  // Feedback URL (public, optional)
  FEEDBACK_URL?: string;

  // OpenShift identity (server-side only, optional)
  OC_TOKEN?: string;
  OC_USER?: string;
  OC_EMAIL?: string;
  ENABLE_OC_WHOAMI?: boolean;
};

function getEnv(key: string, defaultValue?: string): string {
  const value = process.env[key];
  if (value === undefined || value === '') {
    if (defaultValue !== undefined) {
      return defaultValue;
    }
    throw new Error(`Missing required environment variable: ${key}`);
  }
  return value;
}

function getOptionalEnv(key: string): string | undefined {
  const value = process.env[key];
  return value === '' ? undefined : value;
}

function getBooleanEnv(key: string, defaultValue = false): boolean {
  const value = process.env[key];
  if (value === undefined || value === '') {
    return defaultValue;
  }
  return value === '1' || value.toLowerCase() === 'true';
}

/**
 * Server-side environment configuration
 * Only available in server components and API routes
 */
export const env: EnvConfig = {
  NODE_ENV: (process.env.NODE_ENV || 'development') as Environment,
  BACKEND_URL: getEnv('BACKEND_URL', 'http://localhost:8080/api'),
  GITHUB_APP_SLUG: getEnv('GITHUB_APP_SLUG', 'ambient-code-vteam'),
  VTEAM_VERSION: getOptionalEnv('VTEAM_VERSION') || 'latest',
  FEEDBACK_URL: getOptionalEnv('FEEDBACK_URL'),
  OC_TOKEN: getOptionalEnv('OC_TOKEN'),
  OC_USER: getOptionalEnv('OC_USER'),
  OC_EMAIL: getOptionalEnv('OC_EMAIL'),
  ENABLE_OC_WHOAMI: getBooleanEnv('ENABLE_OC_WHOAMI', false),
};

/**
 * Public environment variables
 * These are available in both server and client components
 */
export const publicEnv = {
  GITHUB_APP_SLUG: env.GITHUB_APP_SLUG,
  VTEAM_VERSION: env.VTEAM_VERSION,
  FEEDBACK_URL: env.FEEDBACK_URL,
};

/**
 * Check if running in development mode
 */
export const isDevelopment = env.NODE_ENV === 'development';

/**
 * Check if running in production mode
 */
export const isProduction = env.NODE_ENV === 'production';

/**
 * Check if running in test mode
 */
export const isTest = env.NODE_ENV === 'test';
</file>

<file path="components/frontend/src/services/api/index.ts">
/**
 * API services index
 * Re-exports all API service modules
 */

export * from './client';
export * as clusterApi from './cluster';
export * as projectsApi from './projects';
export * as sessionsApi from './sessions';
export * as githubApi from './github';
export * as keysApi from './keys';
export * as repoApi from './repo';
export * as workspaceApi from './workspace';
export * as authApi from './auth';
</file>

<file path="components/frontend/src/services/api/secrets.ts">
/**
 * Secrets API service
 * Handles runner secrets and secret configuration
 */

import { apiClient } from './client';

export type Secret = {
  key: string;
  value: string;
};

export type SecretList = {
  items: { name: string }[];
};

export type SecretsConfig = {
  secretName: string;
};

/**
 * Get list of available secrets (K8s secrets)
 */
export async function getSecretsList(projectName: string): Promise<SecretList> {
  return apiClient.get<SecretList>(
    `/projects/${projectName}/secrets`
  );
}

/**
 * Get runner secrets configuration
 */
export async function getSecretsConfig(projectName: string): Promise<SecretsConfig> {
  return apiClient.get<SecretsConfig>(
    `/projects/${projectName}/runner-secrets/config`
  );
}

/**
 * Get runner secrets values
 */
export async function getSecretsValues(projectName: string): Promise<Secret[]> {
  // apiClient.get already unwraps the 'data' field from the response
  const data = await apiClient.get<Record<string, string>>(
    `/projects/${projectName}/runner-secrets`
  );
  return Object.entries<string>(data || {}).map(([key, value]) => ({ key, value }));
}

/**
 * Update runner secrets configuration
 */
export async function updateSecretsConfig(
  projectName: string,
  secretName: string
): Promise<void> {
  await apiClient.put<void, { secretName: string }>(
    `/projects/${projectName}/runner-secrets/config`,
    { secretName }
  );
}

/**
 * Update runner secrets values
 */
export async function updateSecrets(
  projectName: string,
  secrets: Secret[]
): Promise<void> {
  const data: Record<string, string> = Object.fromEntries(
    secrets.map(s => [s.key, s.value])
  );
  await apiClient.put<void, { data: Record<string, string> }>(
    `/projects/${projectName}/runner-secrets`,
    { data }
  );
}

/**
 * Get integration secrets values (GIT_*, JIRA_*, custom keys)
 * Hardcoded secret name: "ambient-non-vertex-integrations"
 */
export async function getIntegrationSecrets(projectName: string): Promise<Secret[]> {
  const data = await apiClient.get<Record<string, string>>(
    `/projects/${projectName}/integration-secrets`
  );
  return Object.entries<string>(data || {}).map(([key, value]) => ({ key, value }));
}

/**
 * Update integration secrets values (GIT_*, JIRA_*, custom keys)
 * Hardcoded secret name: "ambient-non-vertex-integrations"
 */
export async function updateIntegrationSecrets(
  projectName: string,
  secrets: Secret[]
): Promise<void> {
  const data: Record<string, string> = Object.fromEntries(
    secrets.map(s => [s.key, s.value])
  );
  await apiClient.put<void, { data: Record<string, string> }>(
    `/projects/${projectName}/integration-secrets`,
    { data }
  );
}
</file>

<file path="components/frontend/src/services/api/workspace.ts">
/**
 * Workspace API service
 * Handles session workspace (PVC) operations
 */

import { apiClient } from './client';

export type WorkspaceItem = {
  name: string;
  path: string;
  isDir: boolean;
  size: number;
  modifiedAt: string;
};

export type ListWorkspaceResponse = {
  items: WorkspaceItem[];
};

/**
 * List workspace directory contents
 */
export async function listWorkspace(
  projectName: string,
  sessionName: string,
  path?: string
): Promise<WorkspaceItem[]> {
  const params = path ? { path } : undefined;
  const response = await apiClient.get<ListWorkspaceResponse>(
    `/projects/${projectName}/agentic-sessions/${sessionName}/workspace`,
    { params }
  );
  return response.items;
}

/**
 * Read workspace file content
 */
export async function readWorkspaceFile(
  projectName: string,
  sessionName: string,
  path: string
): Promise<string> {
  const response = await apiClient.getRaw(
    `/projects/${projectName}/agentic-sessions/${sessionName}/workspace/${encodeURIComponent(path)}`
  );
  if (!response.ok) {
    throw new Error('Failed to read workspace file');
  }
  return response.text();
}

/**
 * Write workspace file content
 */
export async function writeWorkspaceFile(
  projectName: string,
  sessionName: string,
  path: string,
  content: string
): Promise<void> {
  await apiClient.putText(
    `/projects/${projectName}/agentic-sessions/${sessionName}/workspace/${encodeURIComponent(path)}`,
    content
  );
}

/**
 * Get GitHub diff for a session repository
 */
export async function getSessionGitHubDiff(
  projectName: string,
  sessionName: string,
  repoIndex: number,
  repoPath: string
): Promise<{ files: { added: number; removed: number }; total_added: number; total_removed: number }> {
  const response = await apiClient.get<{
    files?: { added?: number; removed?: number };
    total_added?: number;
    total_removed?: number;
  }>(
    `/projects/${projectName}/agentic-sessions/${sessionName}/github/diff`,
    {
      params: { repoIndex: String(repoIndex), repoPath },
    }
  );
  return {
    files: {
      added: response.files?.added ?? 0,
      removed: response.files?.removed ?? 0,
    },
    total_added: response.total_added ?? 0,
    total_removed: response.total_removed ?? 0,
  };
}

/**
 * Push session changes to GitHub
 */
export async function pushSessionToGitHub(
  projectName: string,
  sessionName: string,
  repoIndex: number,
  repoPath: string
): Promise<void> {
  await apiClient.post<void, { repoIndex: number; repoPath: string }>(
    `/projects/${projectName}/agentic-sessions/${sessionName}/github/push`,
    { repoIndex, repoPath }
  );
}

/**
 * Abandon session changes (reset to upstream)
 */
export async function abandonSessionChanges(
  projectName: string,
  sessionName: string,
  repoIndex: number,
  repoPath: string
): Promise<void> {
  await apiClient.post<void, { repoIndex: number; repoPath: string }>(
    `/projects/${projectName}/agentic-sessions/${sessionName}/github/abandon`,
    { repoIndex, repoPath }
  );
}

/**
 * Git merge status types
 */
export type GitMergeStatus = {
  canMergeClean: boolean;
  localChanges: number;
  remoteCommitsAhead: number;
  conflictingFiles: string[];
  remoteBranchExists: boolean;
};

/**
 * Get git merge status for artifacts directory
 */
export async function getGitMergeStatus(
  projectName: string,
  sessionName: string,
  path: string = 'artifacts',
  branch: string = 'main'
): Promise<GitMergeStatus> {
  const response = await apiClient.get<GitMergeStatus>(
    `/projects/${projectName}/agentic-sessions/${sessionName}/git/merge-status`,
    { params: { path, branch } }
  );
  return response;
}

/**
 * Pull changes from remote
 */
export async function gitPull(
  projectName: string,
  sessionName: string,
  path: string = 'artifacts',
  branch: string = 'main'
): Promise<void> {
  await apiClient.post<void, { path: string; branch: string }>(
    `/projects/${projectName}/agentic-sessions/${sessionName}/git/pull`,
    { path, branch }
  );
}

/**
 * Push changes to remote
 */
export async function gitPush(
  projectName: string,
  sessionName: string,
  path: string = 'artifacts',
  branch: string = 'main',
  message?: string
): Promise<void> {
  await apiClient.post<void, { path: string; branch: string; message?: string }>(
    `/projects/${projectName}/agentic-sessions/${sessionName}/git/push`,
    { path, branch, message }
  );
}

/**
 * Create a new git branch
 */
export async function gitCreateBranch(
  projectName: string,
  sessionName: string,
  branchName: string,
  path: string = 'artifacts'
): Promise<void> {
  await apiClient.post<void, { path: string; branchName: string }>(
    `/projects/${projectName}/agentic-sessions/${sessionName}/git/create-branch`,
    { path, branchName }
  );
}

/**
 * List remote branches
 */
export async function gitListBranches(
  projectName: string,
  sessionName: string,
  path: string = 'artifacts'
): Promise<string[]> {
  const response = await apiClient.get<{ branches: string[] }>(
    `/projects/${projectName}/agentic-sessions/${sessionName}/git/list-branches`,
    { params: { path } }
  );
  return response.branches;
}

/**
 * Git status types
 */
export type GitStatus = {
  branch?: string;
  remoteUrl?: string;
  ahead?: number;
  behind?: number;
  staged?: number;
  unstaged?: number;
  untracked?: number;
  hasRemote?: boolean;
  initialized?: boolean;
  hasChanges?: boolean;
  uncommittedFiles?: number;
  filesAdded?: number;
  filesRemoved?: number;
  totalAdded?: number;
  totalRemoved?: number;
};

/**
 * Get git status for a directory
 */
export async function gitStatus(
  projectName: string,
  sessionName: string,
  path: string
): Promise<GitStatus> {
  const response = await apiClient.get<GitStatus>(
    `/projects/${projectName}/agentic-sessions/${sessionName}/git/status`,
    { params: { path } }
  );
  return response;
}

/**
 * Configure git remote for a directory
 */
export async function configureGitRemote(
  projectName: string,
  sessionName: string,
  path: string,
  remoteUrl: string,
  branch: string = 'main'
): Promise<void> {
  await apiClient.post<void, { path: string; remoteUrl: string; branch: string }>(
    `/projects/${projectName}/agentic-sessions/${sessionName}/git/configure-remote`,
    { path, remoteUrl, branch }
  );
}

/**
 * Synchronize git (commit, pull, push)
 */
export async function synchronizeGit(
  projectName: string,
  sessionName: string,
  path: string,
  message?: string,
  branch?: string
): Promise<void> {
  await apiClient.post<void, { path: string; message?: string; branch?: string }>(
    `/projects/${projectName}/agentic-sessions/${sessionName}/git/synchronize`,
    { path, message, branch }
  );
}
</file>

<file path="components/frontend/src/services/queries/index.ts">
/**
 * React Query hooks index
 * Re-exports all query hook modules
 */

export * from './use-cluster';
export * from './use-projects';
export * from './use-sessions';
export * from './use-github';
export * from './use-keys';
export * from './use-secrets';
export * from './use-repo';
export * from './use-workspace';
export * from './use-auth';
</file>

<file path="components/frontend/src/services/queries/use-secrets.ts">
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import * as secretsApi from '../api/secrets';

export function useSecretsList(projectName: string) {
  return useQuery({
    queryKey: ['secrets', 'list', projectName],
    queryFn: () => secretsApi.getSecretsList(projectName),
    enabled: !!projectName,
  });
}

export function useSecretsConfig(projectName: string) {
  return useQuery({
    queryKey: ['secrets', 'config', projectName],
    queryFn: () => secretsApi.getSecretsConfig(projectName),
    enabled: !!projectName,
  });
}

export function useSecretsValues(projectName: string) {
  return useQuery({
    queryKey: ['secrets', 'values', projectName],
    queryFn: () => secretsApi.getSecretsValues(projectName),
    enabled: !!projectName,
  });
}

export function useUpdateSecretsConfig() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      projectName,
      secretName,
    }: {
      projectName: string;
      secretName: string;
    }) => secretsApi.updateSecretsConfig(projectName, secretName),
    onSuccess: (_, { projectName }) => {
      queryClient.invalidateQueries({ queryKey: ['secrets', 'config', projectName] });
      // Also invalidate values since they come from the configured secret
      queryClient.invalidateQueries({ queryKey: ['secrets', 'values', projectName] });
    },
  });
}

export function useUpdateSecrets() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      projectName,
      secrets,
    }: {
      projectName: string;
      secrets: secretsApi.Secret[];
    }) => secretsApi.updateSecrets(projectName, secrets),
    onSuccess: (_, { projectName }) => {
      queryClient.invalidateQueries({ queryKey: ['secrets', 'values', projectName] });
    },
  });
}

// Integration secrets hooks (ambient-non-vertex-integrations)

export function useIntegrationSecrets(projectName: string) {
  return useQuery({
    queryKey: ['integration-secrets', projectName],
    queryFn: () => secretsApi.getIntegrationSecrets(projectName),
    enabled: !!projectName,
  });
}

export function useUpdateIntegrationSecrets() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      projectName,
      secrets,
    }: {
      projectName: string;
      secrets: secretsApi.Secret[];
    }) => secretsApi.updateIntegrationSecrets(projectName, secrets),
    onSuccess: (_, { projectName }) => {
      queryClient.invalidateQueries({ queryKey: ['integration-secrets', projectName] });
    },
  });
}
</file>

<file path="components/frontend/src/services/queries/use-workspace.ts">
/**
 * React Query hooks for workspace operations
 */

import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import * as workspaceApi from '../api/workspace';

/**
 * Query keys for workspace
 */
export const workspaceKeys = {
  all: ['workspace'] as const,
  lists: () => [...workspaceKeys.all, 'list'] as const,
  list: (projectName: string, sessionName: string, path?: string) =>
    [...workspaceKeys.lists(), projectName, sessionName, path] as const,
  files: () => [...workspaceKeys.all, 'file'] as const,
  file: (projectName: string, sessionName: string, path: string) =>
    [...workspaceKeys.files(), projectName, sessionName, path] as const,
  diffs: () => [...workspaceKeys.all, 'diff'] as const,
  diff: (projectName: string, sessionName: string, repoIndex: number) =>
    [...workspaceKeys.diffs(), projectName, sessionName, repoIndex] as const,
};

/**
 * Hook to list workspace directory
 */
export function useWorkspaceList(
  projectName: string,
  sessionName: string,
  path?: string,
  options?: { enabled?: boolean }
) {
  return useQuery({
    queryKey: workspaceKeys.list(projectName, sessionName, path),
    queryFn: () => workspaceApi.listWorkspace(projectName, sessionName, path),
    enabled: !!projectName && !!sessionName && (options?.enabled ?? true),
    staleTime: 5 * 1000, // 5 seconds
  });
}

/**
 * Hook to read workspace file
 */
export function useWorkspaceFile(
  projectName: string,
  sessionName: string,
  path: string,
  options?: { enabled?: boolean }
) {
  return useQuery({
    queryKey: workspaceKeys.file(projectName, sessionName, path),
    queryFn: () => workspaceApi.readWorkspaceFile(projectName, sessionName, path),
    enabled: !!projectName && !!sessionName && !!path && (options?.enabled ?? true),
    staleTime: 10 * 1000, // 10 seconds
  });
}

/**
 * Hook to write workspace file
 */
export function useWriteWorkspaceFile() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      projectName,
      sessionName,
      path,
      content,
    }: {
      projectName: string;
      sessionName: string;
      path: string;
      content: string;
    }) => workspaceApi.writeWorkspaceFile(projectName, sessionName, path, content),
    onSuccess: (_data, { projectName, sessionName, path }) => {
      // Invalidate the specific file
      queryClient.invalidateQueries({
        queryKey: workspaceKeys.file(projectName, sessionName, path),
      });
      // Invalidate parent directory listing
      const parentPath = path.split('/').slice(0, -1).join('/');
      queryClient.invalidateQueries({
        queryKey: workspaceKeys.list(projectName, sessionName, parentPath || undefined),
      });
    },
  });
}

/**
 * Hook to get GitHub diff for a session repo
 */
export function useSessionGitHubDiff(
  projectName: string,
  sessionName: string,
  repoIndex: number,
  repoPath: string,
  options?: { enabled?: boolean }
) {
  return useQuery({
    queryKey: workspaceKeys.diff(projectName, sessionName, repoIndex),
    queryFn: () =>
      workspaceApi.getSessionGitHubDiff(projectName, sessionName, repoIndex, repoPath),
    enabled: !!projectName && !!sessionName && (options?.enabled ?? true),
    staleTime: 10 * 1000, // 10 seconds
  });
}

/**
 * Hook to fetch all GitHub diffs for session repos
 */
export function useAllSessionGitHubDiffs(
  projectName: string,
  sessionName: string,
  repos: Array<{ input: { url: string; branch: string }; output?: { url: string; branch: string } }> | undefined,
  deriveRepoFolder: (url: string) => string,
  options?: { enabled?: boolean; sessionPhase?: string }
) {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: [...workspaceKeys.diffs(), projectName, sessionName, 'all'],
    queryFn: async () => {
      if (!repos || repos.length === 0) return {};

      const diffs = await Promise.all(
        repos.map(async (repo, idx) => {
          const url = repo?.input?.url || "";
          if (!url) return { idx, diff: { files: { added: 0, removed: 0 }, total_added: 0, total_removed: 0 } };

          const folder = deriveRepoFolder(url);
          const repoPath = `/sessions/${sessionName}/workspace/${folder}`;

          try {
            const diff = await queryClient.fetchQuery({
              queryKey: workspaceKeys.diff(projectName, sessionName, idx),
              queryFn: () => workspaceApi.getSessionGitHubDiff(projectName, sessionName, idx, repoPath),
            });
            return { idx, diff };
          } catch {
            return { idx, diff: { files: { added: 0, removed: 0 }, total_added: 0, total_removed: 0 } };
          }
        })
      );

      const totals: Record<number, { files: { added: number; removed: number }; total_added: number; total_removed: number }> = {};
      diffs.forEach(({ idx, diff }) => {
        totals[idx] = diff;
      });
      return totals;
    },
    enabled: !!projectName && !!sessionName && !!repos && (options?.enabled ?? true),
    staleTime: 10 * 1000, // 10 seconds
    // Poll for diff updates when session is running
    refetchInterval: () => {
      const isRunning =
        options?.sessionPhase === 'Running' ||
        options?.sessionPhase === 'Creating' ||
        options?.sessionPhase === 'Pending';
      return isRunning ? 10000 : false; // Poll every 10 seconds if running
    },
  });
}

/**
 * Hook to push session changes to GitHub
 */
export function usePushSessionToGitHub() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      projectName,
      sessionName,
      repoIndex,
      repoPath,
    }: {
      projectName: string;
      sessionName: string;
      repoIndex: number;
      repoPath: string;
    }) => workspaceApi.pushSessionToGitHub(projectName, sessionName, repoIndex, repoPath),
    onSuccess: (_data, { projectName, sessionName, repoIndex }) => {
      // Invalidate diff to show changes were pushed
      queryClient.invalidateQueries({
        queryKey: workspaceKeys.diff(projectName, sessionName, repoIndex),
      });
      // Invalidate session to update status
      queryClient.invalidateQueries({
        queryKey: ['sessions', 'detail', projectName, sessionName],
      });
    },
  });
}

/**
 * Hook to abandon session changes
 */
export function useAbandonSessionChanges() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      projectName,
      sessionName,
      repoIndex,
      repoPath,
    }: {
      projectName: string;
      sessionName: string;
      repoIndex: number;
      repoPath: string;
    }) => workspaceApi.abandonSessionChanges(projectName, sessionName, repoIndex, repoPath),
    onSuccess: (_data, { projectName, sessionName, repoIndex }) => {
      // Invalidate diff to show changes were abandoned
      queryClient.invalidateQueries({
        queryKey: workspaceKeys.diff(projectName, sessionName, repoIndex),
      });
      // Invalidate workspace to refresh file listing
      queryClient.invalidateQueries({
        queryKey: workspaceKeys.lists(),
      });
    },
  });
}

/**
 * Hook to get git merge status
 */
export function useGitMergeStatus(
  projectName: string,
  sessionName: string,
  path: string = 'artifacts',
  branch: string = 'main',
  enabled: boolean = true
) {
  return useQuery({
    queryKey: [...workspaceKeys.all, 'git-merge-status', projectName, sessionName, path, branch],
    queryFn: () => workspaceApi.getGitMergeStatus(projectName, sessionName, path, branch),
    enabled: enabled && !!projectName && !!sessionName,
    staleTime: 5000, // 5 seconds - merge status can change frequently
  });
}

/**
 * Hook to pull git changes
 */
export function useGitPull() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      projectName,
      sessionName,
      path = 'artifacts',
      branch = 'main',
    }: {
      projectName: string;
      sessionName: string;
      path?: string;
      branch?: string;
    }) => workspaceApi.gitPull(projectName, sessionName, path, branch),
    onSuccess: (_data, { projectName, sessionName }) => {
      // Invalidate workspace and merge status
      queryClient.invalidateQueries({
        queryKey: workspaceKeys.lists(),
      });
      queryClient.invalidateQueries({
        queryKey: [...workspaceKeys.all, 'git-merge-status', projectName, sessionName],
      });
    },
  });
}

/**
 * Hook to push git changes
 */
export function useGitPush() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      projectName,
      sessionName,
      path = 'artifacts',
      branch = 'main',
      message,
    }: {
      projectName: string;
      sessionName: string;
      path?: string;
      branch?: string;
      message?: string;
    }) => workspaceApi.gitPush(projectName, sessionName, path, branch, message),
    onSuccess: (_data, { projectName, sessionName }) => {
      // Invalidate workspace and merge status
      queryClient.invalidateQueries({
        queryKey: workspaceKeys.lists(),
      });
      queryClient.invalidateQueries({
        queryKey: [...workspaceKeys.all, 'git-merge-status', projectName, sessionName],
      });
    },
  });
}

/**
 * Hook to create git branch
 */
export function useGitCreateBranch() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      projectName,
      sessionName,
      branchName,
      path = 'artifacts',
    }: {
      projectName: string;
      sessionName: string;
      branchName: string;
      path?: string;
    }) => workspaceApi.gitCreateBranch(projectName, sessionName, branchName, path),
    onSuccess: (_data, { projectName, sessionName }) => {
      // Invalidate branches list and merge status
      queryClient.invalidateQueries({
        queryKey: [...workspaceKeys.all, 'git-branches', projectName, sessionName],
      });
      queryClient.invalidateQueries({
        queryKey: [...workspaceKeys.all, 'git-merge-status', projectName, sessionName],
      });
    },
  });
}

/**
 * Hook to list remote branches
 */
export function useGitListBranches(
  projectName: string,
  sessionName: string,
  path: string = 'artifacts',
  enabled: boolean = true
) {
  return useQuery({
    queryKey: [...workspaceKeys.all, 'git-branches', projectName, sessionName, path],
    queryFn: () => workspaceApi.gitListBranches(projectName, sessionName, path),
    enabled: enabled && !!projectName && !!sessionName,
    staleTime: 30000, // 30 seconds - branches don't change often
  });
}

/**
 * Hook to get git status
 */
export function useGitStatus(
  projectName: string,
  sessionName: string,
  path: string,
  options?: { enabled?: boolean }
) {
  return useQuery({
    queryKey: [...workspaceKeys.all, 'git-status', projectName, sessionName, path],
    queryFn: () => workspaceApi.gitStatus(projectName, sessionName, path),
    enabled: !!projectName && !!sessionName && !!path && (options?.enabled ?? true),
    staleTime: 5000, // 5 seconds - status can change frequently
  });
}

/**
 * Hook to configure git remote
 */
export function useConfigureGitRemote() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      projectName,
      sessionName,
      path,
      remoteUrl,
      branch = 'main',
    }: {
      projectName: string;
      sessionName: string;
      path: string;
      remoteUrl: string;
      branch?: string;
    }) => workspaceApi.configureGitRemote(projectName, sessionName, path, remoteUrl, branch),
    onSuccess: (_data, { projectName, sessionName, path }) => {
      // Invalidate git status to reflect new remote
      queryClient.invalidateQueries({
        queryKey: [...workspaceKeys.all, 'git-status', projectName, sessionName, path],
      });
      // Invalidate branches list
      queryClient.invalidateQueries({
        queryKey: [...workspaceKeys.all, 'git-branches', projectName, sessionName, path],
      });
    },
  });
}

/**
 * Hook to synchronize git (commit, pull, push)
 */
export function useSynchronizeGit() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      projectName,
      sessionName,
      path,
      message,
      branch,
    }: {
      projectName: string;
      sessionName: string;
      path: string;
      message?: string;
      branch?: string;
    }) => workspaceApi.synchronizeGit(projectName, sessionName, path, message, branch),
    onSuccess: (_data, { projectName, sessionName, path }) => {
      // Invalidate git status
      queryClient.invalidateQueries({
        queryKey: [...workspaceKeys.all, 'git-status', projectName, sessionName, path],
      });
      // Invalidate workspace to show updated files
      queryClient.invalidateQueries({
        queryKey: workspaceKeys.lists(),
      });
      // Invalidate merge status
      queryClient.invalidateQueries({
        queryKey: [...workspaceKeys.all, 'git-merge-status', projectName, sessionName],
      });
    },
  });
}
</file>

<file path="components/frontend/src/types/api/sessions.ts">
/**
 * Agentic Session API types
 * These types align with the backend Go structs and Kubernetes CRD
 */

export type UserContext = {
  userId: string;
  displayName: string;
  groups: string[];
};

export type BotAccountRef = {
  name: string;
};

export type ResourceOverrides = {
  cpu?: string;
  memory?: string;
  storageClass?: string;
  priorityClass?: string;
};

export type AgenticSessionPhase =
  | 'Pending'
  | 'Creating'
  | 'Running'
  | 'Completed'
  | 'Failed'
  | 'Stopped'
  | 'Error';

export type LLMSettings = {
  model: string;
  temperature: number;
  maxTokens: number;
};

export type SessionRepoInput = {
  url: string;
  branch?: string;
};

export type SessionRepoOutput = {
  url: string;
  branch?: string;
};

export type SessionRepoStatus = 'pushed' | 'abandoned';

export type SessionRepo = {
  input: SessionRepoInput;
  output?: SessionRepoOutput;
  status?: SessionRepoStatus;
};

export type AgenticSessionSpec = {
  prompt: string;
  llmSettings: LLMSettings;
  timeout: number;
  displayName?: string;
  project?: string;
  interactive?: boolean;
  repos?: SessionRepo[];
  mainRepoIndex?: number;
  activeWorkflow?: {
    gitUrl: string;
    branch: string;
    path?: string;
  };
};

export type AgenticSessionStatus = {
  phase: AgenticSessionPhase;
  message?: string;
  startTime?: string;
  completionTime?: string;
  jobName?: string;
  stateDir?: string;
  subtype?: string;
  is_error?: boolean;
  num_turns?: number;
  session_id?: string;
  total_cost_usd?: number | null;
  usage?: Record<string, unknown> | null;
  result?: string | null;
};

export type AgenticSession = {
  metadata: {
    name: string;
    namespace: string;
    creationTimestamp: string;
    uid: string;
    labels?: Record<string, string>;
    annotations?: Record<string, string>;
  };
  spec: AgenticSessionSpec;
  status?: AgenticSessionStatus;
};

export type CreateAgenticSessionRequest = {
  prompt: string;
  llmSettings?: Partial<LLMSettings>;
  displayName?: string;
  timeout?: number;
  project?: string;
  parent_session_id?: string;
  environmentVariables?: Record<string, string>;
  interactive?: boolean;
  workspacePath?: string;
  repos?: SessionRepo[];
  mainRepoIndex?: number;
  autoPushOnComplete?: boolean;
  userContext?: UserContext;
  botAccount?: BotAccountRef;
  resourceOverrides?: ResourceOverrides;
  labels?: Record<string, string>;
  annotations?: Record<string, string>;
};

export type CreateAgenticSessionResponse = {
  message: string;
  name: string;
  uid: string;
};

export type GetAgenticSessionResponse = {
  session: AgenticSession;
};

export type ListAgenticSessionsResponse = {
  items: AgenticSession[];
};

export type StopAgenticSessionRequest = {
  reason?: string;
};

export type StopAgenticSessionResponse = {
  message: string;
};

export type CloneAgenticSessionRequest = {
  targetProject: string;
  newSessionName: string;
};

export type CloneAgenticSessionResponse = {
  session: AgenticSession;
};

// Message content block types
export type TextBlock = {
  type: 'text_block';
  text: string;
};

export type ThinkingBlock = {
  type: 'thinking_block';
  thinking: string;
  signature: string;
};

export type ToolUseBlock = {
  type: 'tool_use_block';
  id: string;
  name: string;
  input: Record<string, unknown>;
};

export type ToolResultBlock = {
  type: 'tool_result_block';
  tool_use_id: string;
  content?: string | Array<Record<string, unknown>> | null;
  is_error?: boolean | null;
};

export type ContentBlock = TextBlock | ThinkingBlock | ToolUseBlock | ToolResultBlock;

// Message types
export type UserMessage = {
  type: 'user_message';
  content: ContentBlock | string;
  timestamp: string;
};

export type AgentMessage = {
  type: 'agent_message';
  content: ContentBlock;
  model: string;
  timestamp: string;
};

export type SystemMessage = {
  type: 'system_message';
  subtype: string;
  data: Record<string, unknown>;
  timestamp: string;
};

export type ResultMessage = {
  type: 'result_message';
  subtype: string;
  duration_ms: number;
  duration_api_ms: number;
  is_error: boolean;
  num_turns: number;
  session_id: string;
  total_cost_usd?: number | null;
  usage?: Record<string, unknown> | null;
  result?: string | null;
  timestamp: string;
};

export type ToolUseMessages = {
  type: 'tool_use_messages';
  toolUseBlock: ToolUseBlock;
  resultBlock: ToolResultBlock;
  timestamp: string;
};

export type AgentRunningMessage = {
  type: 'agent_running';
  timestamp: string;
};

export type AgentWaitingMessage = {
  type: 'agent_waiting';
  timestamp: string;
};

export type Message =
  | UserMessage
  | AgentMessage
  | SystemMessage
  | ResultMessage
  | ToolUseMessages
  | AgentRunningMessage
  | AgentWaitingMessage;

export type GetSessionMessagesResponse = {
  messages: Message[];
};
</file>

<file path="components/frontend/src/app/projects/[name]/sessions/[sessionName]/session-header.tsx">
"use client";

import { useState } from 'react';
import { formatDistanceToNow, format } from 'date-fns';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { RefreshCw, Octagon, Trash2, Copy, MoreVertical, Info, Play } from 'lucide-react';
import { CloneSessionDialog } from '@/components/clone-session-dialog';
import { SessionDetailsModal } from '@/components/session-details-modal';
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger, DropdownMenuSeparator } from '@/components/ui/dropdown-menu';
import type { AgenticSession } from '@/types/agentic-session';
import { getPhaseColor } from '@/utils/session-helpers';

type SessionHeaderProps = {
  session: AgenticSession;
  projectName: string;
  actionLoading: string | null;
  onRefresh: () => void;
  onStop: () => void;
  onContinue: () => void;
  onDelete: () => void;
  durationMs?: number;
  k8sResources?: {
    pvcName?: string;
    pvcSize?: string;
  };
  messageCount: number;
};

export function SessionHeader({
  session,
  projectName,
  actionLoading,
  onRefresh,
  onStop,
  onContinue,
  onDelete,
  durationMs,
  k8sResources,
  messageCount,
}: SessionHeaderProps) {
  const [detailsModalOpen, setDetailsModalOpen] = useState(false);
  
  const phase = session.status?.phase || "Pending";
  const canStop = phase === "Running" || phase === "Creating";
  const canResume = phase === "Stopped";
  const canDelete = phase === "Completed" || phase === "Failed" || phase === "Stopped" || phase === "Error";

  const started = session.status?.startTime 
    ? format(new Date(session.status.startTime), "PPp")
    : null;

  return (
    <>
      <div className="flex items-start justify-between">
        <div>
          <h1 className="text-2xl font-semibold flex items-center gap-2">
            <span>{session.spec.displayName || session.metadata.name}</span>
            <Badge className={getPhaseColor(phase)}>
              {phase}
            </Badge>
          </h1>
          {session.spec.displayName && (
            <div className="text-sm text-gray-500">{session.metadata.name}</div>
          )}
          <div className="text-xs text-gray-500 mt-3">
            <span>Started {started || formatDistanceToNow(new Date(session.metadata.creationTimestamp), { addSuffix: true })}</span>
            <span className="mx-1"></span>
            <button 
              onClick={() => setDetailsModalOpen(true)}
              className="text-blue-600 hover:underline"
            >
              View details
            </button>
          </div>
        </div>
        <div className="flex gap-2">
          <Button
            variant="outline"
            size="sm"
            onClick={onRefresh}
            disabled={actionLoading === "refreshing"}
          >
            <RefreshCw className={`w-4 h-4 mr-2 ${actionLoading === "refreshing" ? "animate-spin" : ""}`} />
            Refresh
          </Button>
          {canStop && (
            <Button
              variant="outline"
              size="sm"
              onClick={onStop}
              disabled={actionLoading === "stopping"}
              className="hover:border-red-600 hover:bg-red-50 group"
            >
              <Octagon className="w-4 h-4 mr-2 fill-red-200 stroke-red-500 group-hover:fill-red-500 group-hover:stroke-red-700 transition-colors" />
              Stop
            </Button>
          )}
          {canResume && (
            <Button
              variant="outline"
              size="sm"
              onClick={onContinue}
              disabled={actionLoading === "resuming"}
              className="hover:border-green-600 hover:bg-green-50 group"
            >
              <Play className="w-4 h-4 mr-2 fill-green-200 stroke-green-600 group-hover:fill-green-500 group-hover:stroke-green-700 transition-colors" />
              Resume
            </Button>
          )}
          
          {/* Actions dropdown menu */}
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="outline" size="sm">
                <MoreVertical className="w-4 h-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuItem onClick={() => setDetailsModalOpen(true)}>
                <Info className="w-4 h-4 mr-2" />
                View details
              </DropdownMenuItem>
              <DropdownMenuSeparator />
              <CloneSessionDialog
                session={session}
                trigger={
                  <DropdownMenuItem onSelect={(e) => e.preventDefault()}>
                    <Copy className="w-4 h-4 mr-2" />
                    Clone
                  </DropdownMenuItem>
                }
                projectName={projectName}
              />
              {canDelete && (
                <>
                  <DropdownMenuSeparator />
                  <DropdownMenuItem
                    onClick={onDelete}
                    disabled={actionLoading === "deleting"}
                    className="text-red-600"
                  >
                    <Trash2 className="w-4 h-4 mr-2" />
                    {actionLoading === "deleting" ? "Deleting..." : "Delete"}
                  </DropdownMenuItem>
                </>
              )}
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      </div>

      <SessionDetailsModal
        session={session}
        open={detailsModalOpen}
        onOpenChange={setDetailsModalOpen}
        durationMs={durationMs}
        k8sResources={k8sResources}
        messageCount={messageCount}
      />
    </>
  );
}
</file>

<file path="components/frontend/src/app/projects/[name]/sessions/new/page.tsx">
"use client";

import { useEffect, useState } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import Link from "next/link";
import { Loader2 } from "lucide-react";
import { useForm, useFieldArray } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";

import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Form, FormControl, FormDescription, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Textarea } from "@/components/ui/textarea";
import type { CreateAgenticSessionRequest } from "@/types/agentic-session";
import { Checkbox } from "@/components/ui/checkbox";
import { successToast, errorToast } from "@/hooks/use-toast";
import { Breadcrumbs } from "@/components/breadcrumbs";
import { RepositoryDialog } from "./repository-dialog";
import { RepositoryList } from "./repository-list";
import { ModelConfiguration } from "./model-configuration";
import { useCreateSession } from "@/services/queries/use-sessions";

const formSchema = z
  .object({
    prompt: z.string(),
    model: z.string().min(1, "Please select a model"),
    temperature: z.number().min(0).max(2),
    maxTokens: z.number().min(100).max(8000),
    timeout: z.number().min(60).max(1800),
    interactive: z.boolean().default(false),
    // Unified multi-repo array
    repos: z
      .array(z.object({
        input: z.object({ url: z.string().url(), branch: z.string().optional() }),
        output: z.object({ url: z.string().url().optional().or(z.literal("")), branch: z.string().optional() }).optional(),
      }))
      .optional()
      .default([]),
    mainRepoIndex: z.number().optional().default(0),
    // Runner behavior
    autoPushOnComplete: z.boolean().default(false),
    // storage paths are not user-configurable anymore
    agentPersona: z.string().optional(),
  })
  .superRefine((data, ctx) => {
    const isInteractive = Boolean(data.interactive);
    const promptLength = (data.prompt || "").trim().length;
    if (!isInteractive && promptLength < 10) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        path: ["prompt"],
        message: "Prompt must be at least 10 characters long",
      });
    }
  });

type FormValues = z.input<typeof formSchema>;

export default function NewProjectSessionPage({ params }: { params: Promise<{ name: string }> }) {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [projectName, setProjectName] = useState<string>("");
  const [prefillWorkspacePath, setPrefillWorkspacePath] = useState<string | undefined>(undefined);
  const [editingRepoIndex, setEditingRepoIndex] = useState<number | null>(null);
  const [repoDialogOpen, setRepoDialogOpen] = useState(false);
  const [tempRepo, setTempRepo] = useState<{ input: { url: string; branch: string }; output?: { url: string; branch: string } }>({ input: { url: "", branch: "main" } });

  // React Query hooks
  const createSessionMutation = useCreateSession();

  useEffect(() => {
    params.then(({ name }) => setProjectName(name));
  }, [params]);

  useEffect(() => {
    const ws = searchParams?.get("workspacePath");
    if (ws) setPrefillWorkspacePath(ws);
  }, [searchParams]);

  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      prompt: "",
      model: "claude-sonnet-4-5",
      temperature: 0.7,
      maxTokens: 4000,
      timeout: 300,
      interactive: false,
      autoPushOnComplete: false,
      agentPersona: "",
      repos: [],
      mainRepoIndex: 0,
    },
  });

  // Field arrays for multi-repo configuration
  const { fields: reposFields, append: appendRepo, remove: removeRepo, update: updateRepo } = useFieldArray({ control: form.control, name: "repos" });

  // Watch interactive to adjust prompt field hints
  const isInteractive = form.watch("interactive");



  

  const onSubmit = async (values: FormValues) => {
    if (!projectName) return;

    const promptToSend = values.interactive && !values.prompt.trim()
      ? "Greet the user and briefly explain the workspace capabilities: they can select workflows, add code repositories for context, use commands, and you'll help with software engineering tasks. Keep it friendly and concise."
      : values.prompt;
    const request: CreateAgenticSessionRequest = {
      prompt: promptToSend,
      llmSettings: {
        model: values.model,
        temperature: values.temperature,
        maxTokens: values.maxTokens,
      },
      timeout: values.timeout,
      interactive: values.interactive,
      autoPushOnComplete: values.autoPushOnComplete,
      };

      if (prefillWorkspacePath) {
        request.workspacePath = prefillWorkspacePath;
      }

      // Apply labels if projectName is present
      if (projectName) {
        request.labels = {
          ...(request.labels || {}),
          project: projectName,
        };
      }


      // Multi-repo configuration
      type RepoConfig = { input: { url: string; branch?: string }; output?: { url: string; branch?: string } };
      const repos = (values.repos as RepoConfig[] | undefined) || [];
      if (Array.isArray(repos) && repos.length > 0) {
        const filteredRepos = repos.filter(r => r && r.input && r.input.url);
        (request as CreateAgenticSessionRequest & { repos?: RepoConfig[]; mainRepoIndex?: number }).repos = filteredRepos;
        (request as CreateAgenticSessionRequest & { repos?: RepoConfig[]; mainRepoIndex?: number }).mainRepoIndex = values.mainRepoIndex || 0;

        // Ensure runner env receives repos JSON + main repo index for immediate compatibility
        request.environmentVariables = {
          ...(request.environmentVariables || {}),
          REPOS_JSON: JSON.stringify(filteredRepos),
          MAIN_REPO_INDEX: String(values.mainRepoIndex || 0),
        };
      }

    createSessionMutation.mutate(
      { projectName, data: request },
      {
        onSuccess: (session) => {
          const sessionName = session.metadata.name;
          successToast(`Session "${sessionName}" created successfully`);
          router.push(`/projects/${encodeURIComponent(projectName)}/sessions/${sessionName}`);
        },
        onError: (error) => {
          errorToast(error.message || "Failed to create session");
        },
      }
    );
  };

  return (
    <div className="container mx-auto p-6">
      <Breadcrumbs
        items={[
          { label: 'Projects', href: '/projects' },
          { label: projectName, href: `/projects/${projectName}` },
          { label: 'Sessions', href: `/projects/${projectName}/sessions` },
          { label: 'New Session' },
        ]}
        className="mb-4"
      />

      <Card>
        <CardHeader>
          <CardTitle>New Agentic Session</CardTitle>
          <CardDescription>Create a new agentic session that will analyze a website</CardDescription>
        </CardHeader>
        <CardContent>
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              <FormField
                control={form.control}
                name="interactive"
                render={({ field }) => (
                  <FormItem className="flex flex-row items-start space-x-3 space-y-0 rounded-md border p-3">
                    <FormControl>
                      <Checkbox checked={field.value} onCheckedChange={(v) => field.onChange(Boolean(v))} />
                    </FormControl>
                    <div className="space-y-1 leading-none">
                      <FormLabel>Interactive chat</FormLabel>
                      <FormDescription>
                        When enabled, the session runs in chat mode. You can send messages and receive streamed responses.
                      </FormDescription>
                    </div>
                    <FormMessage />
                  </FormItem>
                )}
              />

              {!isInteractive && (
                <FormField
                  control={form.control}
                  name="prompt"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Agentic Prompt</FormLabel>
                      <FormControl>
                        <Textarea placeholder="Describe what you want Claude to analyze on the website..." className="min-h-[100px]" {...field} />
                      </FormControl>
                      <FormDescription>Provide a detailed prompt about what you want Claude to analyze on the website</FormDescription>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              )}


              <ModelConfiguration control={form.control} />

              {/* Multi-agent selection */}
              <div className="space-y-2">
                <FormLabel>Select Agents (optional)</FormLabel>
                <FormDescription>
                  Choose one or more agents to inject their knowledge into the session at start.
                </FormDescription>
              </div>

              {/* Repositories (Optional) */}
              <RepositoryList
                repos={(form.watch("repos") || []) as Array<{ input: { url: string; branch: string }; output?: { url: string; branch: string } }>}
                mainRepoIndex={form.watch("mainRepoIndex") || 0}
                onAddRepo={() => {
                  setTempRepo({ input: { url: "", branch: "main" } });
                  setEditingRepoIndex(null);
                  setRepoDialogOpen(true);
                }}
                onEditRepo={(index) => {
                  const repo = form.getValues(`repos.${index}`) as { input: { url: string; branch: string }; output?: { url: string; branch: string } } | undefined;
                  if (repo) {
                    setTempRepo(repo);
                    setEditingRepoIndex(index);
                    setRepoDialogOpen(true);
                  }
                }}
                onRemoveRepo={(index) => {
                  removeRepo(index);
                  const currentMain = form.getValues("mainRepoIndex") || 0;
                  if (currentMain >= reposFields.length - 1) {
                    form.setValue("mainRepoIndex", Math.max(0, reposFields.length - 2));
                  }
                }}
                onSetMainRepo={(index) => form.setValue("mainRepoIndex", index)}
              />

              <RepositoryDialog
                open={repoDialogOpen}
                onOpenChange={setRepoDialogOpen}
                repo={tempRepo}
                onRepoChange={setTempRepo}
                onSave={() => {
                  if (!tempRepo.input.url) return;
                  if (editingRepoIndex !== null) {
                    updateRepo(editingRepoIndex, tempRepo);
                  } else {
                    appendRepo(tempRepo);
                  }
                }}
                isEditing={editingRepoIndex !== null}
                projectName={projectName}
              />

              {/* Runner behavior */}
              <FormField
                control={form.control}
                name="autoPushOnComplete"
                render={({ field }) => (
                  <FormItem className="flex flex-row items-start space-x-3 space-y-0 rounded-md border p-3">
                    <FormControl>
                      <Checkbox checked={field.value} onCheckedChange={(v) => field.onChange(Boolean(v))} />
                    </FormControl>
                    <div className="space-y-1 leading-none">
                      <FormLabel>Auto-push to Git on completion</FormLabel>
                      <FormDescription>
                        When enabled, the runner will commit and push changes automatically after it finishes.
                      </FormDescription>
                    </div>
                    <FormMessage />
                  </FormItem>
                )}
              />

              {/* Storage paths are managed automatically by the backend/operator */}

              {createSessionMutation.isError && (
                <div className="bg-red-50 border border-red-200 rounded-md p-3">
                  <p className="text-red-700 text-sm">{createSessionMutation.error?.message || "Failed to create session"}</p>
                </div>
              )}

              <div className="flex gap-4">
                <Button type="submit" disabled={createSessionMutation.isPending}>
                  {createSessionMutation.isPending && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                  {createSessionMutation.isPending ? "Creating Session..." : "Create Agentic Session"}
                </Button>
                <Link href={`/projects/${encodeURIComponent(projectName)}/sessions`}>
                  <Button type="button" variant="link" disabled={createSessionMutation.isPending}>Cancel</Button>
                </Link>
              </div>
            </form>
          </Form>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="components/frontend/src/components/navigation.tsx">
"use client";

import Link from "next/link";
import { useRouter } from "next/navigation";
import { UserBubble } from "@/components/user-bubble";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu";
import { Plug, LogOut } from "lucide-react";
import { useVersion } from "@/services/queries/use-version";

type NavigationProps = {
  feedbackUrl?: string;
};

export function Navigation({ feedbackUrl }: NavigationProps) {
  // const pathname = usePathname();
  // const segments = pathname?.split("/").filter(Boolean) || [];
  const router = useRouter();
  const { data: version } = useVersion();

  const handleLogout = () => {
    // Redirect to oauth-proxy logout endpoint  
    // This clears the OpenShift OAuth session and redirects back to login  
    window.location.href = '/oauth/sign_out';  
  };

  return (
    <nav className="sticky top-0 z-50 border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
      <div className="container mx-auto px-6">
        <div className="flex h-16 items-center justify-between gap-4">
          <div className="flex items-end gap-2">
            <Link href="/" className="text-xl font-bold">
              Ambient Code Platform
            </Link>
            {version && (
              <a 
                href="https://github.com/ambient-code/platform/releases"
                target="_blank"
                rel="noopener noreferrer"
                className="text-[0.65rem] text-gray-400 pb-0.75 hover:text-gray-600 transition-colors"
              >
                {version}
              </a>
            )}
          </div>
          <div className="flex items-center gap-3">
            {feedbackUrl && (
              <a 
                href={feedbackUrl}
                target="_blank"
                rel="noopener noreferrer"
                className="text-sm text-muted-foreground hover:text-foreground transition-colors"
              >
                Share feedback
              </a>
            )}
            <DropdownMenu>
              <DropdownMenuTrigger className="outline-none">
                <UserBubble />
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                <DropdownMenuItem onSelect={() => router.push('/integrations')}>
                  <Plug className="w-4 h-4 mr-2" />
                  Integrations
                </DropdownMenuItem>
                <DropdownMenuItem onSelect={handleLogout}>
                  <LogOut className="w-4 h-4 mr-2" />
                  Logout
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        </div>
      </div>
    </nav>
  );
}
</file>

<file path="components/frontend/src/app/projects/[name]/settings/page.tsx">
'use client';

import { useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';

export default function ProjectSettingsPage() {
  const params = useParams();
  const router = useRouter();
  const projectName = params?.name as string;

  // Redirect to main workspace page
  useEffect(() => {
    if (projectName) {
      router.replace(`/projects/${projectName}?section=settings`);
    }
  }, [projectName, router]);

  return null;
}
</file>

<file path="components/frontend/src/app/layout.tsx">
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import { Navigation } from "@/components/navigation";
import { QueryProvider } from "@/components/providers/query-provider";
import { Toaster } from "@/components/ui/toaster";
import { env } from "@/lib/env";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Ambient Code Platform",
  description:
    "ACP is an AI-native agentic-powered enterprise software development platform",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const wsBase = env.BACKEND_URL.replace(/^http:/, 'ws:').replace(/^https:/, 'wss:')
  const feedbackUrl = env.FEEDBACK_URL
  return (
    <html lang="en" suppressHydrationWarning>
      <head>
        <meta name="backend-ws-base" content={wsBase} />
      </head>
      <body className={`${inter.className} min-h-screen flex flex-col`} suppressHydrationWarning>
        <QueryProvider>
          <Navigation feedbackUrl={feedbackUrl} />
          <main className="flex-1 bg-background overflow-auto">{children}</main>
          <Toaster />
        </QueryProvider>
      </body>
    </html>
  );
}
</file>

<file path="components/frontend/src/types/agentic-session.ts">
export type AgenticSessionPhase = "Pending" | "Creating" | "Running" | "Completed" | "Failed" | "Stopped" | "Error";

export type LLMSettings = {
	model: string;
	temperature: number;
	maxTokens: number;
};

// Generic repo type used by RFE workflows (retains optional clonePath)
export type GitRepository = {
    url: string;
    branch?: string;
};

// Unified multi-repo session mapping
export type SessionRepoInput = {
    url: string;
    branch?: string;
};
export type SessionRepoOutput = {
    url: string;
    branch?: string;
};
export type SessionRepo = {
    input: SessionRepoInput;
    output?: SessionRepoOutput;
    status?: "pushed" | "abandoned";
};

export type AgenticSessionSpec = {
	prompt: string;
	llmSettings: LLMSettings;
	timeout: number;
	displayName?: string;
	project?: string;
	interactive?: boolean;
	// Multi-repo support
	repos?: SessionRepo[];
	mainRepoIndex?: number;
	// Active workflow for dynamic workflow switching
	activeWorkflow?: {
		gitUrl: string;
		branch: string;
		path?: string;
	};
};

// -----------------------------
// Content Block Types
// -----------------------------
export type TextBlock = {
	type: "text_block";
	text: string;
}
export type ThinkingBlock = {
	type: "thinking_block";
	thinking: string;
	signature: string;
}
export type ToolUseBlock = {
	type: "tool_use_block";
	id: string;
	name: string;
	input: Record<string, unknown>;
}
export type ToolResultBlock = {
	type: "tool_result_block";
	tool_use_id: string;
	content?: string | Array<Record<string, unknown>> | null;
	is_error?: boolean | null;
};

export type ContentBlock = TextBlock | ThinkingBlock | ToolUseBlock | ToolResultBlock;

export type ToolUseMessages = {
	type: "tool_use_messages";
	toolUseBlock: ToolUseBlock;
	resultBlock: ToolResultBlock;
	timestamp: string;
}
	
// -----------------------------
// Message Types
// -----------------------------
export type Message = UserMessage | AgentMessage | SystemMessage | ResultMessage | ToolUseMessages | AgentRunningMessage | AgentWaitingMessage;

export type AgentRunningMessage = {
	type: "agent_running";
	timestamp: string;
}
export type AgentWaitingMessage = {
	type: "agent_waiting";
	timestamp: string;
}

export type UserMessage = {
	type: "user_message";
	content: ContentBlock | string;
	timestamp: string;
}
export type AgentMessage = {
	type: "agent_message";
	content: ContentBlock;
	model: string;
	timestamp: string;
}
export type SystemMessage = {
	type: "system_message";
	subtype: string;
	data: Record<string, unknown>;
	timestamp: string;
}
export type ResultMessage = {
	type: "result_message";
	subtype: string;
	duration_ms: number;
	duration_api_ms: number;
	is_error: boolean;
	num_turns: number;
	session_id: string;
	total_cost_usd?: number | null;
	usage?: Record<string, unknown> | null;
	result?: string | null;
	timestamp: string;
}

// Backwards-compatible message type consumed by frontend components.
// Prefer using StreamMessage going forward.
export type MessageObject = Message;

export type AgenticSessionStatus = {
	phase: AgenticSessionPhase;
	message?: string;
	startTime?: string;
	completionTime?: string;
	jobName?: string;
  	// Storage & counts (align with CRD)
  	stateDir?: string;
	// Runner result summary fields
	subtype?: string;
	is_error?: boolean;
	num_turns?: number;
	session_id?: string;
	total_cost_usd?: number | null;
	usage?: Record<string, unknown> | null;
	result?: string | null;
};

export type AgenticSession = {
	metadata: {
		name: string;
		namespace: string;
		creationTimestamp: string;
		uid: string;
		labels?: Record<string, string>;
		annotations?: Record<string, string>;
	};
	spec: AgenticSessionSpec;
	status?: AgenticSessionStatus;
};

export type CreateAgenticSessionRequest = {
	prompt: string;
	llmSettings?: Partial<LLMSettings>;
	displayName?: string;
	timeout?: number;
	project?: string;
	parent_session_id?: string;
  	environmentVariables?: Record<string, string>;
	interactive?: boolean;
	workspacePath?: string;
	// Multi-repo support
	repos?: SessionRepo[];
	mainRepoIndex?: number;
	autoPushOnComplete?: boolean;
	labels?: Record<string, string>;
	annotations?: Record<string, string>;
};

export type AgentPersona = {
	persona: string;
	name: string;
	role: string;
	description: string;
};

export type { Project } from "@/types/project";
</file>

<file path="README.md">
# Ambient Code Platform

> Kubernetes-native AI automation platform for intelligent agentic sessions with multi-agent collaboration

**Note:** This project was formerly known as "vTeam". While the project has been rebranded to **Ambient Code Platform**, the name "vTeam" still appears in various technical artifacts for backward compatibility (see [Legacy vTeam References](#legacy-vteam-references) below).

## Overview

The **Ambient Code Platform** is an AI automation platform that combines Claude Code CLI with multi-agent collaboration capabilities. The platform enables teams to create and manage intelligent agentic sessions through a modern web interface.

### Key Capabilities

- **Intelligent Agentic Sessions**: AI-powered automation for analysis, research, content creation, and development tasks
- **Multi-Agent Workflows**: Specialized AI agents model realistic software team dynamics
- **Kubernetes Native**: Built with Custom Resources, Operators, and proper RBAC for enterprise deployment
- **Real-time Monitoring**: Live status updates and job execution tracking

## Architecture

The platform consists of containerized microservices orchestrated via Kubernetes:

| Component | Technology | Description |
|-----------|------------|-------------|
| **Frontend** | NextJS + Shadcn | User interface for managing agentic sessions |
| **Backend API** | Go + Gin | REST API for managing Kubernetes Custom Resources (multi-tenant: projects, sessions, access control) |
| **Agentic Operator** | Go | Kubernetes operator that watches CRs and creates Jobs |
| **Claude Code Runner** | Python + Claude Code CLI | Pod that executes AI with multi-agent collaboration capabilities |

### Agentic Session Flow

1. **Create Session**: User creates agentic session via web UI with task description
2. **API Processing**: Backend creates `AgenticSession` Custom Resource in Kubernetes
3. **Job Scheduling**: Operator detects CR and creates Kubernetes Job with runner pod
4. **AI Execution**: Pod runs Claude Code CLI with multi-agent collaboration for intelligent analysis
5. **Result Storage**: Analysis results stored back in Custom Resource status
6. **UI Updates**: Frontend displays real-time progress and completed results

## Prerequisites

### Required Tools
- **OpenShift Local (CRC)** for local development or OpenShift cluster for production
- **oc** (OpenShift CLI) or **kubectl** v1.28+ configured to access your cluster
- **Docker or Podman** for building container images
- **Container registry access** (Docker Hub, Quay.io, ECR, etc.) for production
- **Go 1.24+** for building backend services (if building from source)
- **Node.js 20+** and **npm** for the frontend (if building from source)

### Required API Keys
- **Anthropic API Key** - Get from [Anthropic Console](https://console.anthropic.com/)
  - Configure via web UI: Settings  Runner Secrets after deployment

## Quick Start

### 1. Deploy to OpenShift

Deploy using the default images from `quay.io/ambient_code`:

```bash
# From repo root, prepare env for deploy script (required once)
cp components/manifests/env.example components/manifests/.env
# Edit .env and set at least ANTHROPIC_API_KEY

# Deploy to ambient-code namespace (default)
make deploy

# Or deploy to custom namespace
make deploy NAMESPACE=my-namespace
```

### 2. Verify Deployment

```bash
# Check pod status
oc get pods -n ambient-code

# Check services and routes
oc get services,routes -n ambient-code
```

### 3. Access the Web Interface

```bash
# Get the route URL
oc get route frontend-route -n ambient-code

# Or use port forwarding as fallback
kubectl port-forward svc/frontend-service 3000:3000 -n ambient-code
```

### 4. Configure API Keys

1. Access the web interface
2. Navigate to Settings  Runner Secrets
3. Add your Anthropic API key

## Usage

### Creating an Agentic Session

1. **Access Web Interface**: Navigate to your deployed route URL
2. **Create New Session**:
   - **Prompt**: Task description (e.g., "Review this codebase for security vulnerabilities and suggest improvements")
   - **Model**: Choose AI model (Claude Sonnet/Haiku)
   - **Settings**: Adjust temperature, token limits, timeout (default: 300s)
3. **Monitor Progress**: View real-time status updates and execution logs
4. **Review Results**: Download analysis results and structured output

### Example Use Cases

- **Code Analysis**: Security reviews, code quality assessments, architecture analysis
- **Technical Documentation**: API documentation, user guides, technical specifications
- **Project Planning**: Feature specifications, implementation plans, task breakdowns
- **Research & Analysis**: Technology research, competitive analysis, requirement gathering
- **Development Workflows**: Code reviews, testing strategies, deployment planning

## Advanced Configuration

### Building Custom Images

To build and deploy your own container images:

```bash
# Set your container registry
export REGISTRY="quay.io/your-username"

# Build all images
make build-all

# Push to registry (requires authentication)
make push-all REGISTRY=$REGISTRY

# Deploy with custom images
cd components/manifests
REGISTRY=$REGISTRY ./deploy.sh
```

### Container Engine Options

```bash
# Use Podman instead of Docker
make build-all CONTAINER_ENGINE=podman

# Build for specific platform
# Default is linux/amd64
make build-all PLATFORM=linux/arm64

# Build with additional flags
make build-all BUILD_FLAGS="--no-cache --pull"
```

### OpenShift OAuth Integration

For cluster-based authentication and authorization, the deployment script can configure the Route host, create an `OAuthClient`, and set the frontend secret when provided a `.env` file. See the guide for details and a manual alternative:

- [docs/OPENSHIFT_OAUTH.md](docs/OPENSHIFT_OAUTH.md)

## Configuration & Secrets

### Operator Configuration (Vertex AI vs Direct API)

The operator supports two modes for accessing Claude AI:

#### Direct Anthropic API (Default)
Use `operator-config.yaml` or `operator-config-crc.yaml` for standard deployments:

```bash
# Apply the standard config (Vertex AI disabled)
kubectl apply -f components/manifests/operator-config.yaml -n ambient-code
```

**When to use:**
- Standard cloud deployments without Google Cloud integration
- Local development with CRC/Minikube
- Any environment using direct Anthropic API access

**Configuration:** Sets `CLAUDE_CODE_USE_VERTEX=0`

#### Google Cloud Vertex AI
Use `operator-config-openshift.yaml` for production OpenShift deployments with Vertex AI:

```bash
# Apply the Vertex AI config
kubectl apply -f components/manifests/operator-config-openshift.yaml -n ambient-code
```

**When to use:**
- Production deployments on Google Cloud
- Environments requiring Vertex AI integration
- Enterprise deployments with Google Cloud service accounts

**Configuration:** Sets `CLAUDE_CODE_USE_VERTEX=1` and configures:
- `CLOUD_ML_REGION`: Google Cloud region (default: "global")
- `ANTHROPIC_VERTEX_PROJECT_ID`: Your GCP project ID
- `GOOGLE_APPLICATION_CREDENTIALS`: Path to service account key file

**Creating the Vertex AI Secret:**

When using Vertex AI, you must create a secret containing your Google Cloud service account key:

```bash
# The key file MUST be named ambient-code-key.json
kubectl create secret generic ambient-vertex \
  --from-file=ambient-code-key.json=ambient-code-key.json \
  -n ambient-code
```

**Important Requirements:**
-  Secret name must be `ambient-vertex`
-  Key file must be named `ambient-code-key.json`
-  Service account must have Vertex AI API access
-  Project ID in config must match the service account's project


### Session Timeout Configuration

Sessions have a configurable timeout (default: 300 seconds):

- **Environment Variable**: Set `TIMEOUT=1800` for 30-minute sessions
- **CRD Default**: Modify `components/manifests/crds/agenticsessions-crd.yaml`
- **Interactive Mode**: Set `interactive: true` for unlimited chat-based sessions

### Runner Secrets Management

Configure AI API keys and integrations via the web interface:

- **Settings  Runner Secrets**: Add Anthropic API keys
- **Project-scoped**: Each project namespace has isolated secret management
- **Security**: All secrets stored as Kubernetes Secrets with proper RBAC

## Troubleshooting

### Common Issues

**Pods Not Starting:**
```bash
oc describe pod <pod-name> -n ambient-code
oc logs <pod-name> -n ambient-code
```

**API Connection Issues:**
```bash
oc get endpoints -n ambient-code
oc exec -it <pod-name> -- curl http://backend-service:8080/health
```

**Job Failures:**
```bash
oc get jobs -n ambient-code
oc describe job <job-name> -n ambient-code
oc logs <failed-pod-name> -n ambient-code
```

### Verification Commands

```bash
# Check all resources
oc get all -l app=ambient-code -n ambient-code

# View recent events
oc get events --sort-by='.lastTimestamp' -n ambient-code

# Test frontend access
curl -f http://localhost:3000 || echo "Frontend not accessible"

# Test backend API
kubectl port-forward svc/backend-service 8080:8080 -n ambient-code &
curl http://localhost:8080/health
```

## Production Considerations

### Security
- **API Key Management**: Store Anthropic API keys securely in Kubernetes secrets
- **RBAC**: Configure appropriate role-based access controls
- **Network Policies**: Implement network isolation between components
- **Image Scanning**: Scan container images for vulnerabilities before deployment

### Monitoring
- **Prometheus Metrics**: Configure metrics collection for all components
- **Log Aggregation**: Set up centralized logging (ELK, Loki, etc.)
- **Alerting**: Configure alerts for pod failures, resource exhaustion
- **Health Checks**: Implement comprehensive health endpoints

### Scaling
- **Horizontal Pod Autoscaling**: Configure HPA based on CPU/memory usage
- **Resource Limits**: Set appropriate resource requests and limits
- **Node Affinity**: Configure pod placement for optimal resource usage

## Development

### Local Development with OpenShift Local (CRC)

**Single Command Setup:**
```bash
# Start complete local development environment
make dev-start
```

**What this provides:**
-  Full OpenShift cluster with CRC
-  Real OpenShift authentication and RBAC
-  Production-like environment
-  Automatic image builds and deployments
-  Working frontend-backend integration

**Prerequisites:**
```bash
# Install CRC (macOS)
brew install crc

# Get Red Hat pull secret (free):
# 1. Visit: https://console.redhat.com/openshift/create/local
# 2. Download pull secret to ~/.crc/pull-secret.json
# 3. Run: crc setup

# Then start development
make dev-start
```

**Hot Reloading (optional):**
```bash
# Terminal 1: Start with development images
DEV_MODE=true make dev-start

# Terminal 2: Enable file sync for hot-reloading
make dev-sync
```

**Access URLs:**
- Frontend: `https://vteam-frontend-vteam-dev.apps-crc.testing`
- Backend: `https://vteam-backend-vteam-dev.apps-crc.testing/health`
- Console: `https://console-openshift-console.apps-crc.testing`

### Building from Source
```bash
# Build all images locally
make build-all

# Build specific components
make build-frontend
make build-backend
make build-operator
make build-runner
```

## File Structure

```
vTeam/
 components/                     #  Ambient Code Platform Components
    frontend/                   # NextJS web interface
    backend/                    # Go API service
    operator/                   # Kubernetes operator
    runners/                   # AI runner services
       claude-code-runner/    # Python Claude Code CLI service
    manifests/                  # Kubernetes deployment manifests
 docs/                           # Documentation
    OPENSHIFT_DEPLOY.md        # Detailed deployment guide
    OPENSHIFT_OAUTH.md         # OAuth configuration
 tools/                          # Supporting development tools
    vteam_shared_configs/       # Team configuration management
    mcp_client_integration/     # MCP client library
 Makefile                        # Build and deployment automation
```

## Production Considerations

### Security
- **RBAC**: Comprehensive role-based access controls
- **Network Policies**: Component isolation and secure communication
- **Secret Management**: Kubernetes-native secret storage with encryption
- **Image Scanning**: Vulnerability scanning for all container images

### Monitoring & Observability
- **Health Checks**: Comprehensive health endpoints for all services
- **Metrics**: Prometheus-compatible metrics collection
- **Logging**: Structured logging with OpenShift logging integration
- **Alerting**: Integration with OpenShift monitoring and alerting

### Scaling & Performance
- **Horizontal Pod Autoscaling**: Auto-scaling based on CPU/memory metrics
- **Resource Management**: Proper requests/limits for optimal resource usage
- **Job Queuing**: Intelligent job scheduling and resource allocation
- **Multi-tenancy**: Project-based isolation with shared infrastructure

## Contributing

We welcome contributions! Please follow these guidelines to ensure code quality and consistency.

### Development Workflow

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Make your changes following the existing patterns
4. Run code quality checks (see below)
5. Add tests if applicable
6. Commit with conventional commit messages
7. Push to the branch (`git push origin feature/amazing-feature`)
8. Open a Pull Request

### Code Quality Standards

#### Go Code (Backend & Operator)

Before committing Go code, run these checks locally:

```bash
# Backend
cd components/backend
gofmt -l .                    # Check formatting
go vet ./...                  # Run go vet
golangci-lint run            # Run full linting suite

# Operator
cd components/operator
gofmt -l .                    # Check formatting
go vet ./...                  # Run go vet
golangci-lint run            # Run full linting suite
```

**Install golangci-lint:**
```bash
go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
```

**Auto-format your code:**
```bash
# Format all Go files
gofmt -w components/backend components/operator
```

**CI/CD:** All pull requests automatically run these checks via GitHub Actions. Your PR must pass all linting checks before merging.

#### Frontend Code

```bash
cd components/frontend
npm run lint                  # ESLint checks
npm run type-check            # TypeScript checks (if available)
npm run format                # Prettier formatting
```

### Testing

```bash
# Backend tests
cd components/backend
make test                     # Run all tests
make test-unit                # Unit tests only
make test-integration         # Integration tests

# Operator tests
cd components/operator
go test ./... -v              # Run all tests

# Frontend tests
cd components/frontend
npm test                      # Run test suite
```

### E2E Testing

Run automated end-to-end tests in a local kind cluster:

```bash
make e2e-test                # Full test suite (setup, deploy, test, cleanup)
```

Or run steps individually:

```bash
cd e2e
./scripts/setup-kind.sh      # Create kind cluster
./scripts/deploy.sh          # Deploy vTeam
./scripts/run-tests.sh       # Run Cypress tests
./scripts/cleanup.sh         # Clean up
```

The e2e tests deploy the complete vTeam stack to a kind (Kubernetes in Docker) cluster and verify core functionality including project creation and UI navigation. Tests run automatically in GitHub Actions on every PR.

See [e2e/README.md](e2e/README.md) for detailed documentation, troubleshooting, and development guide.

## Agent Strategy for Pilot
- To ensure maximum focus and efficiency for the current RFE (Request for Enhancement) pilot, we are temporarily streamlining the active agent pool.
- Active Agents (Focused Scope): The 5 agents required for this specific RFE workflow are currently located in the agents folder.
- Agent Bullpen (Holding Pattern): All remaining agent definitions have been relocated to the "agent bullpen" folder. This transition does not signify the deprecation of any roles.
- Future Planning: Agents in the "agent bullpen" are designated for future reintegration and will be actively utilized as we expand to address subsequent processes and workflows across the organization.


### Documentation

- Update relevant documentation when changing functionality
- Follow existing documentation style (Markdown)
- Add code comments for complex logic
- Update CLAUDE.md if adding new patterns or standards

## Support & Documentation

- **Deployment Guide**: [docs/OPENSHIFT_DEPLOY.md](docs/OPENSHIFT_DEPLOY.md)
- **OAuth Setup**: [docs/OPENSHIFT_OAUTH.md](docs/OPENSHIFT_OAUTH.md)
- **Architecture Details**: [diagrams/](diagrams/)
- **API Documentation**: Available in web interface after deployment

## Legacy vTeam References

While the project is now branded as **Ambient Code Platform**, the name "vTeam" still appears in various technical components for backward compatibility and to avoid breaking changes. You will encounter "vTeam" or "vteam" in:

### Infrastructure & Deployment
- **GitHub Repository**: `github.com/ambient-code/vTeam` (repository name unchanged)
- **Container Images**: `vteam_frontend`, `vteam_backend`, `vteam_operator`, `vteam_claude_runner`
- **Kubernetes API Group**: `vteam.ambient-code` (used in Custom Resource Definitions)
- **Development Namespace**: `vteam-dev` (local development environment)

### URLs & Routes
- **Local Development Routes**:
  - `https://vteam-frontend-vteam-dev.apps-crc.testing`
  - `https://vteam-backend-vteam-dev.apps-crc.testing`

### Code & Configuration
- **File paths**: Repository directory structure (`/path/to/vTeam/...`)
- **Go package references**: Internal Kubernetes resource types
- **RBAC resources**: ClusterRole and RoleBinding names
- **Makefile targets**: Development commands reference `vteam-dev` namespace
- **Kubernetes resources**: Deployment names (`vteam-frontend`, `vteam-backend`, `vteam-operator`)
- **Environment variables**: `VTEAM_VERSION` in frontend deployment

These technical references remain unchanged to maintain compatibility with existing deployments and to avoid requiring migration for current users. Future major versions may fully transition these artifacts to use "Ambient Code Platform" or "ambient-code" naming.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
</file>

<file path="components/frontend/src/components/session/MessagesTab.tsx">
"use client";

import React, { useState, useRef, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { MessageSquare, Loader2, Settings, Terminal, Users } from "lucide-react";
import { StreamMessage } from "@/components/ui/stream-message";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuCheckboxItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import type { AgenticSession, MessageObject, ToolUseMessages } from "@/types/agentic-session";
import type { WorkflowMetadata } from "@/app/projects/[name]/sessions/[sessionName]/lib/types";

export type MessagesTabProps = {
  session: AgenticSession;
  streamMessages: Array<MessageObject | ToolUseMessages>;
  chatInput: string;
  setChatInput: (v: string) => void;
  onSendChat: () => Promise<void>;
  onInterrupt: () => Promise<void>;
  onEndSession: () => Promise<void>;
  onGoToResults?: () => void;
  onContinue: () => void;
  workflowMetadata?: WorkflowMetadata;
  onCommandClick?: (slashCommand: string) => void;
};


const MessagesTab: React.FC<MessagesTabProps> = ({ session, streamMessages, chatInput, setChatInput, onSendChat, onInterrupt, onEndSession, onGoToResults, onContinue, workflowMetadata, onCommandClick }) => {
  const [sendingChat, setSendingChat] = useState(false);
  const [interrupting, setInterrupting] = useState(false);
  const [ending, setEnding] = useState(false);
  const [showSystemMessages, setShowSystemMessages] = useState(false);
  const [agentsPopoverOpen, setAgentsPopoverOpen] = useState(false);
  const [commandsPopoverOpen, setCommandsPopoverOpen] = useState(false);
  
  // Autocomplete state
  const [autocompleteOpen, setAutocompleteOpen] = useState(false);
  const [autocompleteType, setAutocompleteType] = useState<'agent' | 'command' | null>(null);
  const [autocompleteFilter, setAutocompleteFilter] = useState('');
  const [autocompleteTriggerPos, setAutocompleteTriggerPos] = useState(0);
  const [autocompleteSelectedIndex, setAutocompleteSelectedIndex] = useState(0);
  
  const messagesContainerRef = useRef<HTMLDivElement>(null);
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const autocompleteRef = useRef<HTMLDivElement>(null);
  const [isAtBottom, setIsAtBottom] = useState(true);

  const phase = session?.status?.phase || "";
  const isInteractive = session?.spec?.interactive;
  
  // Only show chat interface when session is interactive AND in Running state
  const showChatInterface = isInteractive && phase === "Running";
  
  // Determine if session is in a terminal state
  const isTerminalState = ["Completed", "Failed", "Stopped"].includes(phase);
  const isCreating = ["Creating", "Pending"].includes(phase);

  // Filter out system messages unless showSystemMessages is true
  const filteredMessages = streamMessages.filter((msg) => {
    if (showSystemMessages) return true;
    
    // Hide system_message type by default
    // Check if msg has a type property and if it's a system_message
    if ('type' in msg && msg.type === "system_message") {
      return false;
    }
    
    return true;
  });

  // Check if user is scrolled to the bottom
  const checkIfAtBottom = () => {
    const container = messagesContainerRef.current;
    if (!container) return true;
    
    // For normal scroll (not reversed), we check if scrollTop + clientHeight >= scrollHeight
    const threshold = 50; // pixels from bottom to still consider "at bottom"
    const isBottom = container.scrollHeight - container.scrollTop - container.clientHeight < threshold;
    return isBottom;
  };

  // Handle scroll event to track if user is at bottom
  const handleScroll = () => {
    setIsAtBottom(checkIfAtBottom());
  };

  // Scroll to bottom function - only scrolls the messages container, not the whole page
  const scrollToBottom = () => {
    const container = messagesContainerRef.current;
    if (container) {
      container.scrollTop = container.scrollHeight;
    }
  };

  // Auto-scroll to bottom when new messages arrive, but only if user was already at bottom
  useEffect(() => {
    if (isAtBottom) {
      scrollToBottom();
    }
  }, [filteredMessages, isAtBottom]);

  // Initial scroll to bottom on mount
  useEffect(() => {
    scrollToBottom();
  }, []);

  // Click outside to close autocomplete
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (autocompleteOpen && 
          autocompleteRef.current && 
          !autocompleteRef.current.contains(event.target as Node) &&
          textareaRef.current &&
          !textareaRef.current.contains(event.target as Node)) {
        setAutocompleteOpen(false);
        setAutocompleteType(null);
        setAutocompleteFilter('');
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [autocompleteOpen]);

  const handleSendChat = async () => {
    setSendingChat(true);
    try {
      await onSendChat();
    } finally {
      setSendingChat(false);
    }
  };

  const handleInterrupt = async () => {
    setInterrupting(true);
    try {
      await onInterrupt();
    } finally {
      setInterrupting(false);
    }
  };

  const handleEndSession = async () => {
    setEnding(true);
    try {
      await onEndSession();
    } finally {
      setEnding(false);
    }
  };

  // Get filtered autocomplete items
  const getFilteredItems = () => {
    if (!autocompleteType) return [];
    
    if (autocompleteType === 'agent' && workflowMetadata?.agents) {
      const filter = autocompleteFilter.toLowerCase();
      return workflowMetadata.agents.filter(agent => 
        agent.name.toLowerCase().includes(filter)
      );
    }
    
    if (autocompleteType === 'command' && workflowMetadata?.commands) {
      const filter = autocompleteFilter.toLowerCase();
      return workflowMetadata.commands.filter(cmd => 
        cmd.name.toLowerCase().includes(filter) || 
        cmd.slashCommand.toLowerCase().includes(filter)
      );
    }
    
    return [];
  };

  const filteredAutocompleteItems = getFilteredItems();

  // Handle autocomplete selection
  const handleAutocompleteSelect = (item: { id: string; name: string; slashCommand?: string; description?: string }) => {
    if (!textareaRef.current) return;
    
    const cursorPos = textareaRef.current.selectionStart;
    const textBefore = chatInput.substring(0, autocompleteTriggerPos);
    const textAfter = chatInput.substring(cursorPos);
    
    let insertText = '';
    if (autocompleteType === 'agent') {
      const agentNameShort = item.name.split(' - ')[0];
      insertText = `@${agentNameShort} `;
    } else if (autocompleteType === 'command') {
      insertText = `${item.slashCommand} `;
    }
    
    const newText = textBefore + insertText + textAfter;
    setChatInput(newText);
    
    // Reset autocomplete
    setAutocompleteOpen(false);
    setAutocompleteType(null);
    setAutocompleteFilter('');
    setAutocompleteSelectedIndex(0);
    
    // Set cursor position after insert
    setTimeout(() => {
      if (textareaRef.current) {
        const newCursorPos = textBefore.length + insertText.length;
        textareaRef.current.selectionStart = newCursorPos;
        textareaRef.current.selectionEnd = newCursorPos;
        textareaRef.current.focus();
      }
    }, 0);
  };

  // Handle input change to detect @ or /
  const handleChatInputChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const newValue = e.target.value;
    const cursorPos = e.target.selectionStart;
    
    setChatInput(newValue);
    
    // Check if we should show autocomplete
    if (cursorPos > 0) {
      const charBeforeCursor = newValue[cursorPos - 1];
      const textBeforeCursor = newValue.substring(0, cursorPos);
      
      // Check for @ or / trigger
      if (charBeforeCursor === '@' || charBeforeCursor === '/') {
        // Make sure it's at the start or after whitespace
        if (cursorPos === 1 || /\s/.test(newValue[cursorPos - 2])) {
          setAutocompleteTriggerPos(cursorPos - 1);
          setAutocompleteType(charBeforeCursor === '@' ? 'agent' : 'command');
          setAutocompleteFilter('');
          setAutocompleteSelectedIndex(0);
          setAutocompleteOpen(true);
          return;
        }
      }
      
      // Update filter if autocomplete is open
      if (autocompleteOpen) {
        const filterText = textBeforeCursor.substring(autocompleteTriggerPos + 1);
        
        // Close if we've moved past the trigger or hit whitespace
        if (cursorPos <= autocompleteTriggerPos || /\s/.test(filterText)) {
          setAutocompleteOpen(false);
          setAutocompleteType(null);
          setAutocompleteFilter('');
        } else {
          setAutocompleteFilter(filterText);
          setAutocompleteSelectedIndex(0);
        }
      }
    } else {
      // Cursor at start, close autocomplete
      if (autocompleteOpen) {
        setAutocompleteOpen(false);
        setAutocompleteType(null);
        setAutocompleteFilter('');
      }
    }
  };

  return (
    <div className="flex flex-col h-full">
      <div 
        ref={messagesContainerRef}
        onScroll={handleScroll}
        className="flex-1 flex flex-col gap-2 overflow-y-auto px-3 pb-2 scrollbar-thin"
      >
        {filteredMessages.map((m, idx) => (
          <StreamMessage key={`sm-${idx}`} message={m} isNewest={idx === filteredMessages.length - 1} onGoToResults={onGoToResults} />
        ))}

        {filteredMessages.length === 0 && !isCreating && (
          <div className="flex flex-col items-center justify-center py-12 text-center text-muted-foreground">
            <MessageSquare className="w-8 h-8 mx-auto mb-2 opacity-50" />
            <p className="text-sm">No messages yet</p>
            <p className="text-xs mt-1">
              {isInteractive 
                ? isTerminalState
                  ? `Session has ${phase.toLowerCase()}.`
                  : "Start by sending a message below."
                : "This session is not interactive."}
            </p>
          </div>
        )}
      </div>

      {/* Settings for non-interactive sessions with messages */}
      {!isInteractive && filteredMessages.length > 0 && (
        <div className="sticky bottom-0 border-t bg-gray-50">
          <div className="p-3">
            <div className="flex items-center gap-2">
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="ghost" size="sm" className="h-7 w-7 p-0">
                    <Settings className="h-4 w-4" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="start">
                  <DropdownMenuCheckboxItem
                    checked={showSystemMessages}
                    onCheckedChange={setShowSystemMessages}
                  >
                    {showSystemMessages ? 'Hide' : 'Show'} system messages
                  </DropdownMenuCheckboxItem>
                </DropdownMenuContent>
              </DropdownMenu>
              <p className="text-sm text-muted-foreground">Non-interactive session</p>
            </div>
          </div>
        </div>
      )}

      {showChatInterface && (
        <div className="sticky bottom-0 bg-white">
          <div className="px-2 pt-2 pb-0 space-y-1.5">
              <div className="relative">
                <textarea
                  ref={textareaRef}
                  className="w-full border rounded p-2 text-sm"
                  placeholder="Type a message to the agent... (Press Enter to send, Shift+Enter for new line)"
                  value={chatInput}
                  onChange={handleChatInputChange}
                  onKeyDown={(e) => {
                    // Handle autocomplete navigation
                    if (autocompleteOpen && filteredAutocompleteItems.length > 0) {
                      if (e.key === "ArrowDown") {
                        e.preventDefault();
                        setAutocompleteSelectedIndex(prev => 
                          prev < filteredAutocompleteItems.length - 1 ? prev + 1 : prev
                        );
                        return;
                      }
                      if (e.key === "ArrowUp") {
                        e.preventDefault();
                        setAutocompleteSelectedIndex(prev => prev > 0 ? prev - 1 : 0);
                        return;
                      }
                      if (e.key === "Enter" || e.key === "Tab") {
                        e.preventDefault();
                        handleAutocompleteSelect(filteredAutocompleteItems[autocompleteSelectedIndex]);
                        return;
                      }
                      if (e.key === "Escape") {
                        e.preventDefault();
                        setAutocompleteOpen(false);
                        setAutocompleteType(null);
                        setAutocompleteFilter('');
                        return;
                      }
                    }
                    
                    // Regular enter to send
                    if (e.key === "Enter" && !e.shiftKey) {
                      e.preventDefault();
                      if (chatInput.trim() && !sendingChat) {
                        handleSendChat();
                      }
                    }
                  }}
                  rows={3}
                  disabled={sendingChat}
                />
                
                {/* Autocomplete popup */}
                {autocompleteOpen && (
                  <div 
                    ref={autocompleteRef}
                    className="absolute z-[100] bg-white border-2 border-blue-500 rounded-md shadow-lg max-h-60 overflow-y-auto w-80"
                    style={{
                      bottom: '100%',
                      left: '0px',
                      marginBottom: '5px',
                    }}
                  >
                    {filteredAutocompleteItems.length === 0 ? (
                      <div className="px-3 py-2 text-sm text-muted-foreground">
                        No {autocompleteType === 'agent' ? 'agents' : 'commands'} found
                      </div>
                    ) : (
                      <>
                    {filteredAutocompleteItems.map((item, index) => {
                      if (autocompleteType === 'agent') {
                        const agent = item as { id: string; name: string; description?: string };
                        const agentNameShort = agent.name.split(' - ')[0];
                        
                        return (
                          <div
                            key={agent.id}
                            className={`px-3 py-2 cursor-pointer border-b last:border-b-0 ${
                              index === autocompleteSelectedIndex
                                ? 'bg-blue-50'
                                : 'hover:bg-gray-50'
                            }`}
                            onClick={() => handleAutocompleteSelect(agent)}
                            onMouseEnter={() => setAutocompleteSelectedIndex(index)}
                          >
                            <div className="font-medium text-sm">@{agentNameShort}</div>
                            <div className="text-xs text-muted-foreground truncate">
                              {agent.name}
                            </div>
                          </div>
                        );
                      } else {
                        const cmd = item as { id: string; name: string; slashCommand: string; description?: string };
                        const commandTitle = cmd.name.includes('.') 
                          ? cmd.name.split('.').pop() 
                          : cmd.name;
                        
                        return (
                          <div
                            key={cmd.id}
                            className={`px-3 py-2 cursor-pointer border-b last:border-b-0 ${
                              index === autocompleteSelectedIndex
                                ? 'bg-blue-50'
                                : 'hover:bg-gray-50'
                            }`}
                            onClick={() => handleAutocompleteSelect(cmd)}
                            onMouseEnter={() => setAutocompleteSelectedIndex(index)}
                          >
                            <div className="font-medium text-sm">{cmd.slashCommand}</div>
                            <div className="text-xs text-muted-foreground truncate capitalize">
                              {commandTitle}
                            </div>
                          </div>
                        );
                      }
                    })}
                    </>
                    )}
                  </div>
                )}
              </div>
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                      <Button variant="ghost" size="sm" className="h-7 w-7 p-0">
                        <Settings className="h-4 w-4" />
                      </Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="start">
                      <DropdownMenuCheckboxItem
                        checked={showSystemMessages}
                        onCheckedChange={setShowSystemMessages}
                      >
                        {showSystemMessages ? 'Hide' : 'Show'} system messages
                      </DropdownMenuCheckboxItem>
                    </DropdownMenuContent>
                  </DropdownMenu>

                  {/* Agents Button with Popover */}
                  {workflowMetadata?.agents && workflowMetadata.agents.length > 0 && (
                    <Popover open={agentsPopoverOpen} onOpenChange={setAgentsPopoverOpen}>
                      <PopoverTrigger asChild>
                        <Button variant="outline" size="sm" className="h-7 gap-1.5">
                          <Users className="h-3.5 w-3.5" />
                          Agents
                          <Badge variant="secondary" className="ml-0.5 h-4 px-1.5 text-[10px] font-medium">
                            {workflowMetadata.agents.length}
                          </Badge>
                        </Button>
                      </PopoverTrigger>
                      <PopoverContent
                        align="start"
                        side="top"
                        className="w-[500px]"
                      >
                        <div className="space-y-3">
                          <div className="space-y-2">
                            <h4 className="font-medium text-sm">Available Agents</h4>
                            <p className="text-xs text-muted-foreground">
                              Mention agents in your message to collaborate with them
                            </p>
                          </div>

                          {/* Agents list */}
                          <div
                            className="max-h-[400px] overflow-y-scroll space-y-2 pr-2 scrollbar-thin"
                          >
                            {workflowMetadata.agents.map((agent) => {
                              const agentNameShort = agent.name.split(' - ')[0];

                              return (
                                <div
                                  key={agent.id}
                                  className="p-3 rounded-md border bg-muted/30"
                                >
                                  <div className="flex items-center justify-between mb-1">
                                    <h3 className="text-sm font-bold">
                                      {agent.name}
                                    </h3>
                                    <Button
                                      variant="outline"
                                      size="sm"
                                      className="flex-shrink-0 h-7 text-xs"
                                      onClick={(e) => {
                                        e.stopPropagation();
                                        setChatInput(chatInput + `@${agentNameShort} `);
                                        setAgentsPopoverOpen(false);
                                      }}
                                    >
                                      @{agentNameShort}
                                    </Button>
                                  </div>
                                  {agent.description && (
                                    <p className="text-xs text-muted-foreground">
                                      {agent.description}
                                    </p>
                                  )}
                                </div>
                              );
                            })}
                          </div>
                        </div>
                      </PopoverContent>
                    </Popover>
                  )}

                  {/* Commands Button with Popover */}
                  {workflowMetadata?.commands && workflowMetadata.commands.length > 0 && (
                    <Popover open={commandsPopoverOpen} onOpenChange={setCommandsPopoverOpen}>
                      <PopoverTrigger asChild>
                        <Button variant="outline" size="sm" className="h-7 gap-1.5">
                          <Terminal className="h-3.5 w-3.5" />
                          Commands
                          <Badge variant="secondary" className="ml-0.5 h-4 px-1.5 text-[10px] font-medium">
                            {workflowMetadata.commands.length}
                          </Badge>
                        </Button>
                      </PopoverTrigger>
                      <PopoverContent 
                        align="start" 
                        side="top" 
                        className="w-[500px]"
                      >
                        <div className="space-y-3">
                          <div className="space-y-2">
                            <h4 className="font-medium text-sm">Available Commands</h4>
                            <p className="text-xs text-muted-foreground">
                              Run workflow commands to perform specific actions
                            </p>
                          </div>
                          
                          {/* Commands list */}
                          <div 
                            className="max-h-[400px] overflow-y-scroll space-y-2 pr-2 scrollbar-thin"
                          >
                            {workflowMetadata.commands.map((cmd) => {
                              const commandTitle = cmd.name.includes('.') 
                                ? cmd.name.split('.').pop() 
                                : cmd.name;
                              
                              return (
                                <div
                                  key={cmd.id}
                                  className="p-3 rounded-md border bg-muted/30"
                                >
                                  <div className="flex items-center justify-between mb-1">
                                    <h3 className="text-sm font-bold capitalize">
                                      {commandTitle}
                                    </h3>
                                    <Button
                                      variant="outline"
                                      size="sm"
                                      className="flex-shrink-0 h-7 text-xs"
                                      onClick={() => {
                                        if (onCommandClick) {
                                          onCommandClick(cmd.slashCommand);
                                          setCommandsPopoverOpen(false);
                                        }
                                      }}
                                    >
                                      Run {cmd.slashCommand.replace(/^\/speckit\./, '/')}
                                    </Button>
                                  </div>
                                  {cmd.description && (
                                    <p className="text-xs text-muted-foreground">
                                      {cmd.description}
                                    </p>
                                  )}
                                </div>
                              );
                            })}
                          </div>
                        </div>
                      </PopoverContent>
                    </Popover>
                  )}
                </div>
                <div className="flex gap-2">
                  <Button 
                    variant="outline" 
                    size="sm" 
                    onClick={handleInterrupt}
                    disabled={interrupting || sendingChat || ending}
                  >
                    {interrupting && <Loader2 className="w-3 h-3 mr-1 animate-spin" />}
                    Interrupt agent
                  </Button>
                  <Button 
                    variant="secondary" 
                    size="sm" 
                    onClick={handleEndSession}
                    disabled={ending || sendingChat || interrupting}
                  >
                    {ending && <Loader2 className="w-3 h-3 mr-1 animate-spin" />}
                    End session
                  </Button>
                  <Button 
                    size="sm" 
                    onClick={handleSendChat} 
                    disabled={!chatInput.trim() || sendingChat || interrupting || ending}
                  >
                    {sendingChat && <Loader2 className="w-3 h-3 mr-1 animate-spin" />}
                    Send
                  </Button>
                </div>
              </div>
          </div>
        </div>
      )}

      {isInteractive && !showChatInterface && streamMessages.length > 0 && (
        <div className="sticky bottom-0 border-t bg-gray-50">
          <div className="p-3">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-2">
                <DropdownMenu>
                  <DropdownMenuTrigger asChild>
                    <Button variant="ghost" size="sm" className="h-7 w-7 p-0">
                      <Settings className="h-4 w-4" />
                    </Button>
                  </DropdownMenuTrigger>
                  <DropdownMenuContent align="start">
                    <DropdownMenuCheckboxItem
                      checked={showSystemMessages}
                      onCheckedChange={setShowSystemMessages}
                    >
                      {showSystemMessages ? 'Hide' : 'Show'} system messages
                    </DropdownMenuCheckboxItem>
                  </DropdownMenuContent>
                </DropdownMenu>
                <p className="text-sm text-muted-foreground">
                  {isCreating && "Chat will be available once the session is running..."}
                  {isTerminalState && (
                    <>
                      This session has {phase.toLowerCase()}. Chat is no longer available.
                      {onContinue && (
                        <>
                          {" "}
                          <button
                            onClick={onContinue}
                            className="text-blue-600 hover:underline font-medium"
                          >
                            Resume this session
                          </button>
                          {" "}to restart it.
                        </>
                      )}
                    </>
                  )}
                </p>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default MessagesTab;
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

The **Ambient Code Platform** is a Kubernetes-native AI automation platform that orchestrates intelligent agentic sessions through containerized microservices. The platform enables AI-powered automation for analysis, research, development, and content creation tasks via a modern web interface.

> **Note:** This project was formerly known as "vTeam". Technical artifacts (image names, namespaces, API groups) still use "vteam" for backward compatibility.

### Core Architecture

The system follows a Kubernetes-native pattern with Custom Resources, Operators, and Job execution:

1. **Frontend** (NextJS + Shadcn): Web UI for session management and monitoring
2. **Backend API** (Go + Gin): REST API managing Kubernetes Custom Resources with multi-tenant project isolation
3. **Agentic Operator** (Go): Kubernetes controller watching CRs and creating Jobs
4. **Claude Code Runner** (Python): Job pods executing Claude Code CLI with multi-agent collaboration

### Agentic Session Flow

```
User Creates Session  Backend Creates CR  Operator Spawns Job 
Pod Runs Claude CLI  Results Stored in CR  UI Displays Progress
```

## Development Commands

### Quick Start - Local Development

**Single command setup with OpenShift Local (CRC):**

```bash
# Prerequisites: brew install crc
# Get free Red Hat pull secret from console.redhat.com/openshift/create/local
make dev-start

# Access at https://vteam-frontend-vteam-dev.apps-crc.testing
```

**Hot-reloading development:**

```bash
# Terminal 1
DEV_MODE=true make dev-start

# Terminal 2 (separate terminal)
make dev-sync
```

### Building Components

```bash
# Build all container images (default: docker, linux/amd64)
make build-all

# Build with podman
make build-all CONTAINER_ENGINE=podman

# Build for ARM64
make build-all PLATFORM=linux/arm64

# Build individual components
make build-frontend
make build-backend
make build-operator
make build-runner

# Push to registry
make push-all REGISTRY=quay.io/your-username
```

### Deployment

```bash
# Deploy with default images from quay.io/ambient_code
make deploy

# Deploy to custom namespace
make deploy NAMESPACE=my-namespace

# Deploy with custom images
cd components/manifests
cp env.example .env
# Edit .env with ANTHROPIC_API_KEY and CONTAINER_REGISTRY
./deploy.sh

# Clean up deployment
make clean
```

### Component Development

See component-specific documentation for detailed development commands:

- **Backend** (`components/backend/README.md`): Go API development, testing, linting
- **Frontend** (`components/frontend/README.md`): NextJS development, see also `DESIGN_GUIDELINES.md`
- **Operator** (`components/operator/README.md`): Operator development, watch patterns
- **Claude Code Runner** (`components/runners/claude-code-runner/README.md`): Python runner development

**Common commands**:

```bash
make build-all         # Build all components
make deploy            # Deploy to cluster
make test              # Run tests
make lint              # Lint code
```

### Documentation

```bash
# Install documentation dependencies
pip install -r requirements-docs.txt

# Serve locally at http://127.0.0.1:8000
mkdocs serve

# Build static site
mkdocs build

# Deploy to GitHub Pages
mkdocs gh-deploy

# Markdown linting
markdownlint docs/**/*.md
```

### Local Development Helpers

```bash
# View logs
make dev-logs              # Both backend and frontend
make dev-logs-backend      # Backend only
make dev-logs-frontend     # Frontend only
make dev-logs-operator     # Operator only

# Operator management
make dev-restart-operator  # Restart operator deployment
make dev-operator-status   # Show operator status and events

# Cleanup
make dev-stop              # Stop processes, keep CRC running
make dev-stop-cluster      # Stop processes and shutdown CRC
make dev-clean             # Stop and delete OpenShift project

# Testing
make dev-test              # Run smoke tests
make dev-test-operator     # Test operator only
```

## Key Architecture Patterns

### Custom Resource Definitions (CRDs)

The platform defines three primary CRDs:

1. **AgenticSession** (`agenticsessions.vteam.ambient-code`): Represents an AI execution session
   - Spec: prompt, repos (multi-repo support), interactive mode, timeout, model selection
   - Status: phase, startTime, completionTime, results, error messages, per-repo push status

2. **ProjectSettings** (`projectsettings.vteam.ambient-code`): Project-scoped configuration
   - Manages API keys, default models, timeout settings
   - Namespace-isolated for multi-tenancy

3. **RFEWorkflow** (`rfeworkflows.vteam.ambient-code`): RFE (Request For Enhancement) workflows
   - 7-step agent council process for engineering refinement
   - Agent roles: PM, Architect, Staff Engineer, PO, Team Lead, Team Member, Delivery Owner

### Multi-Repo Support

AgenticSessions support operating on multiple repositories simultaneously:

- Each repo has required `input` (URL, branch) and optional `output` (fork/target) configuration
- `mainRepoIndex` specifies which repo is the Claude working directory (default: 0)
- Per-repo status tracking: `pushed` or `abandoned`

### Interactive vs Batch Mode

- **Batch Mode** (default): Single prompt execution with timeout
- **Interactive Mode** (`interactive: true`): Long-running chat sessions using inbox/outbox files

### Backend API Structure

The Go backend (`components/backend/`) implements:

- **Project-scoped endpoints**: `/api/projects/:project/*` for namespaced resources
- **Multi-tenant isolation**: Each project maps to a Kubernetes namespace
- **WebSocket support**: Real-time session updates via `websocket_messaging.go`
- **Git operations**: Repository cloning, forking, PR creation via `git.go`
- **RBAC integration**: OpenShift OAuth for authentication

Main handler logic in `handlers.go` (3906 lines) manages:

- Project CRUD operations
- AgenticSession lifecycle
- ProjectSettings management
- RFE workflow orchestration

### Operator Reconciliation Loop

The Kubernetes operator (`components/operator/`) watches for:

- AgenticSession creation/updates  spawns Jobs with runner pods
- Job completion  updates CR status with results
- Timeout handling and cleanup

### Runner Execution

The Claude Code runner (`components/runners/claude-code-runner/`) provides:

- Claude Code SDK integration (`claude-code-sdk>=0.0.23`)
- Workspace synchronization via PVC proxy
- Multi-agent collaboration capabilities
- Anthropic API streaming (`anthropic>=0.68.0`)

## Configuration Standards

### Python

- **Virtual environments**: Always use `python -m venv venv` or `uv venv`
- **Package manager**: Prefer `uv` over `pip`
- **Formatting**: black (double quotes)
- **Import sorting**: isort with black profile
- **Linting**: flake8 (ignore E203, W503)

### Go

- **Formatting**: `go fmt ./...` (enforced)
- **Linting**: golangci-lint (install via `make install-tools`)
- **Testing**: Table-driven tests with subtests
- **Error handling**: Explicit error returns, no panic in production code

### Container Images

- **Default registry**: `quay.io/ambient_code`
- **Image tags**: Component-specific (vteam_frontend, vteam_backend, vteam_operator, vteam_claude_runner)
- **Platform**: Default `linux/amd64`, ARM64 supported via `PLATFORM=linux/arm64`
- **Build tool**: Docker or Podman (`CONTAINER_ENGINE=podman`)

### Git Workflow

- **Default branch**: `main`
- **Feature branches**: Required for development
- **Commit style**: Conventional commits (squashed on merge)
- **Branch verification**: Always check current branch before file modifications

### Kubernetes/OpenShift

- **Default namespace**: `ambient-code` (production), `vteam-dev` (local dev)
- **CRD group**: `vteam.ambient-code`
- **API version**: `v1alpha1` (current)
- **RBAC**: Namespace-scoped service accounts with minimal permissions

## Backend and Operator Development Standards

**IMPORTANT**: When working on backend (`components/backend/`) or operator (`components/operator/`) code, you MUST follow these strict guidelines based on established patterns in the codebase.

### Critical Rules (Never Violate)

1. **User Token Authentication Required**
   - FORBIDDEN: Using backend service account for user-initiated API operations
   - REQUIRED: Always use `GetK8sClientsForRequest(c)` to get user-scoped K8s clients
   - REQUIRED: Return `401 Unauthorized` if user token is missing or invalid
   - Exception: Backend service account ONLY for CR writes and token minting (handlers/sessions.go:227, handlers/sessions.go:449)

2. **Never Panic in Production Code**
   - FORBIDDEN: `panic()` in handlers, reconcilers, or any production path
   - REQUIRED: Return explicit errors with context: `return fmt.Errorf("failed to X: %w", err)`
   - REQUIRED: Log errors before returning: `log.Printf("Operation failed: %v", err)`

3. **Token Security and Redaction**
   - FORBIDDEN: Logging tokens, API keys, or sensitive headers
   - REQUIRED: Redact tokens in logs using custom formatters (server/server.go:22-34)
   - REQUIRED: Use `log.Printf("tokenLen=%d", len(token))` instead of logging token content
   - Example: `path = strings.Split(path, "?")[0] + "?token=[REDACTED]"`

4. **Type-Safe Unstructured Access**
   - FORBIDDEN: Direct type assertions without checking: `obj.Object["spec"].(map[string]interface{})`
   - REQUIRED: Use `unstructured.Nested*` helpers with three-value returns
   - Example: `spec, found, err := unstructured.NestedMap(obj.Object, "spec")`
   - REQUIRED: Check `found` before using values; handle type mismatches gracefully

5. **OwnerReferences for Resource Lifecycle**
   - REQUIRED: Set OwnerReferences on all child resources (Jobs, Secrets, PVCs, Services)
   - REQUIRED: Use `Controller: boolPtr(true)` for primary owner
   - FORBIDDEN: `BlockOwnerDeletion` (causes permission issues in multi-tenant environments)
   - Pattern: (operator/internal/handlers/sessions.go:125-134, handlers/sessions.go:470-476)

### Package Organization

**Backend Structure** (`components/backend/`):

```
backend/
 handlers/          # HTTP handlers grouped by resource
    sessions.go    # AgenticSession CRUD + lifecycle
    projects.go    # Project management
    rfe.go         # RFE workflows
    helpers.go     # Shared utilities (StringPtr, etc.)
    middleware.go  # Auth, validation, RBAC
 types/             # Type definitions (no business logic)
    session.go
    project.go
    common.go
 server/            # Server setup, CORS, middleware
 k8s/               # K8s resource templates
 git/, github/      # External integrations
 websocket/         # Real-time messaging
 routes.go          # HTTP route registration
 main.go            # Wiring, dependency injection
```

**Operator Structure** (`components/operator/`):

```
operator/
 internal/
    config/        # K8s client init, config loading
    types/         # GVR definitions, resource helpers
    handlers/      # Watch handlers (sessions, namespaces, projectsettings)
    services/      # Reusable services (PVC provisioning, etc.)
 main.go            # Watch coordination
```

**Rules**:

- Handlers contain HTTP/watch logic ONLY
- Types are pure data structures
- Business logic in separate service packages
- No cyclic dependencies between packages

### Kubernetes Client Patterns

**User-Scoped Clients** (for API operations):

```go
// ALWAYS use for user-initiated operations (list, get, create, update, delete)
reqK8s, reqDyn := GetK8sClientsForRequest(c)
if reqK8s == nil {
    c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid or missing token"})
    c.Abort()
    return
}
// Use reqDyn for CR operations in user's authorized namespaces
list, err := reqDyn.Resource(gvr).Namespace(project).List(ctx, v1.ListOptions{})
```

**Backend Service Account Clients** (limited use cases):

```go
// ONLY use for:
// 1. Writing CRs after validation (handlers/sessions.go:417)
// 2. Minting tokens/secrets for runners (handlers/sessions.go:449)
// 3. Cross-namespace operations backend is authorized for
// Available as: DynamicClient, K8sClient (package-level in handlers/)
created, err := DynamicClient.Resource(gvr).Namespace(project).Create(ctx, obj, v1.CreateOptions{})
```

**Never**:

-  Fall back to service account when user token is invalid
-  Use service account for list/get operations on behalf of users
-  Skip RBAC checks by using elevated permissions

### Error Handling Patterns

**Handler Errors**:

```go
// Pattern 1: Resource not found
if errors.IsNotFound(err) {
    c.JSON(http.StatusNotFound, gin.H{"error": "Session not found"})
    return
}

// Pattern 2: Log + return error
if err != nil {
    log.Printf("Failed to create session %s in project %s: %v", name, project, err)
    c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create session"})
    return
}

// Pattern 3: Non-fatal errors (continue operation)
if err := updateStatus(...); err != nil {
    log.Printf("Warning: status update failed: %v", err)
    // Continue - session was created successfully
}
```

**Operator Errors**:

```go
// Pattern 1: Resource deleted during processing (non-fatal)
if errors.IsNotFound(err) {
    log.Printf("AgenticSession %s no longer exists, skipping", name)
    return nil  // Don't treat as error
}

// Pattern 2: Retriable errors in watch loop
if err != nil {
    log.Printf("Failed to create job: %v", err)
    updateAgenticSessionStatus(ns, name, map[string]interface{}{
        "phase": "Error",
        "message": fmt.Sprintf("Failed to create job: %v", err),
    })
    return fmt.Errorf("failed to create job: %v", err)
}
```

**Never**:

-  Silent failures (always log errors)
-  Generic error messages ("operation failed")
-  Retrying indefinitely without backoff

### Resource Management

**OwnerReferences Pattern**:

```go
// Always set owner when creating child resources
ownerRef := v1.OwnerReference{
    APIVersion: obj.GetAPIVersion(),  // e.g., "vteam.ambient-code/v1alpha1"
    Kind:       obj.GetKind(),        // e.g., "AgenticSession"
    Name:       obj.GetName(),
    UID:        obj.GetUID(),
    Controller: boolPtr(true),        // Only one controller per resource
    // BlockOwnerDeletion: intentionally omitted (permission issues)
}

// Apply to child resources
job := &batchv1.Job{
    ObjectMeta: v1.ObjectMeta{
        Name: jobName,
        Namespace: namespace,
        OwnerReferences: []v1.OwnerReference{ownerRef},
    },
    // ...
}
```

**Cleanup Patterns**:

```go
// Rely on OwnerReferences for automatic cleanup, but delete explicitly when needed
policy := v1.DeletePropagationBackground
err := K8sClient.BatchV1().Jobs(ns).Delete(ctx, jobName, v1.DeleteOptions{
    PropagationPolicy: &policy,
})
if err != nil && !errors.IsNotFound(err) {
    log.Printf("Failed to delete job: %v", err)
    return err
}
```

### Security Patterns

**Token Handling**:

```go
// Extract token from Authorization header
rawAuth := c.GetHeader("Authorization")
parts := strings.SplitN(rawAuth, " ", 2)
if len(parts) != 2 || !strings.EqualFold(parts[0], "Bearer") {
    c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid Authorization header"})
    return
}
token := strings.TrimSpace(parts[1])

// NEVER log the token itself
log.Printf("Processing request with token (len=%d)", len(token))
```

**RBAC Enforcement**:

```go
// Always check permissions before operations
ssar := &authv1.SelfSubjectAccessReview{
    Spec: authv1.SelfSubjectAccessReviewSpec{
        ResourceAttributes: &authv1.ResourceAttributes{
            Group:     "vteam.ambient-code",
            Resource:  "agenticsessions",
            Verb:      "list",
            Namespace: project,
        },
    },
}
res, err := reqK8s.AuthorizationV1().SelfSubjectAccessReviews().Create(ctx, ssar, v1.CreateOptions{})
if err != nil || !res.Status.Allowed {
    c.JSON(http.StatusForbidden, gin.H{"error": "Unauthorized"})
    return
}
```

**Container Security**:

```go
// Always set SecurityContext for Job pods
SecurityContext: &corev1.SecurityContext{
    AllowPrivilegeEscalation: boolPtr(false),
    ReadOnlyRootFilesystem:   boolPtr(false),  // Only if temp files needed
    Capabilities: &corev1.Capabilities{
        Drop: []corev1.Capability{"ALL"},  // Drop all by default
    },
},
```

### API Design Patterns

**Project-Scoped Endpoints**:

```go
// Standard pattern: /api/projects/:projectName/resource
r.GET("/api/projects/:projectName/agentic-sessions", ValidateProjectContext(), ListSessions)
r.POST("/api/projects/:projectName/agentic-sessions", ValidateProjectContext(), CreateSession)
r.GET("/api/projects/:projectName/agentic-sessions/:sessionName", ValidateProjectContext(), GetSession)

// ValidateProjectContext middleware:
// 1. Extracts project from route param
// 2. Validates user has access via RBAC check
// 3. Sets project in context: c.Set("project", projectName)
```

**Middleware Chain**:

```go
// Order matters: Recovery  Logging  CORS  Identity  Validation  Handler
r.Use(gin.Recovery())
r.Use(gin.LoggerWithFormatter(customRedactingFormatter))
r.Use(cors.New(corsConfig))
r.Use(forwardedIdentityMiddleware())  // Extracts X-Forwarded-User, etc.
r.Use(ValidateProjectContext())       // RBAC check
```

**Response Patterns**:

```go
// Success with data
c.JSON(http.StatusOK, gin.H{"items": sessions})

// Success with created resource
c.JSON(http.StatusCreated, gin.H{"message": "Session created", "name": name, "uid": uid})

// Success with no content
c.Status(http.StatusNoContent)

// Errors with structured messages
c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
```

### Operator Patterns

**Watch Loop with Reconnection**:

```go
func WatchAgenticSessions() {
    gvr := types.GetAgenticSessionResource()

    for {  // Infinite loop with reconnection
        watcher, err := config.DynamicClient.Resource(gvr).Watch(ctx, v1.ListOptions{})
        if err != nil {
            log.Printf("Failed to create watcher: %v", err)
            time.Sleep(5 * time.Second)  // Backoff before retry
            continue
        }

        log.Println("Watching for events...")

        for event := range watcher.ResultChan() {
            switch event.Type {
            case watch.Added, watch.Modified:
                obj := event.Object.(*unstructured.Unstructured)
                handleEvent(obj)
            case watch.Deleted:
                // Handle cleanup
            }
        }

        log.Println("Watch channel closed, restarting...")
        watcher.Stop()
        time.Sleep(2 * time.Second)
    }
}
```

**Reconciliation Pattern**:

```go
func handleEvent(obj *unstructured.Unstructured) error {
    name := obj.GetName()
    namespace := obj.GetNamespace()

    // 1. Verify resource still exists (avoid race conditions)
    currentObj, err := getDynamicClient().Get(ctx, name, namespace)
    if errors.IsNotFound(err) {
        log.Printf("Resource %s no longer exists, skipping", name)
        return nil  // Not an error
    }

    // 2. Get current phase/status
    status, found, _ := unstructured.NestedMap(currentObj.Object, "status")
    phase := getPhaseOrDefault(status, "Pending")

    // 3. Only reconcile if in expected state
    if phase != "Pending" {
        return nil  // Already processed
    }

    // 4. Create resources idempotently (check existence first)
    if _, err := getResource(name); err == nil {
        log.Printf("Resource %s already exists", name)
        return nil
    }

    // 5. Create and update status
    createResource(...)
    updateStatus(namespace, name, map[string]interface{}{"phase": "Creating"})

    return nil
}
```

**Status Updates** (use UpdateStatus subresource):

```go
func updateAgenticSessionStatus(namespace, name string, updates map[string]interface{}) error {
    gvr := types.GetAgenticSessionResource()

    obj, err := config.DynamicClient.Resource(gvr).Namespace(namespace).Get(ctx, name, v1.GetOptions{})
    if errors.IsNotFound(err) {
        log.Printf("Resource deleted, skipping status update")
        return nil  // Not an error
    }

    if obj.Object["status"] == nil {
        obj.Object["status"] = make(map[string]interface{})
    }

    status := obj.Object["status"].(map[string]interface{})
    for k, v := range updates {
        status[k] = v
    }

    // Use UpdateStatus subresource (requires /status permission)
    _, err = config.DynamicClient.Resource(gvr).Namespace(namespace).UpdateStatus(ctx, obj, v1.UpdateOptions{})
    if errors.IsNotFound(err) {
        return nil  // Resource deleted during update
    }
    return err
}
```

**Goroutine Monitoring**:

```go
// Start background monitoring (operator/internal/handlers/sessions.go:477)
go monitorJob(jobName, sessionName, namespace)

// Monitoring loop checks both K8s Job status AND custom container status
func monitorJob(jobName, sessionName, namespace string) {
    for {
        time.Sleep(5 * time.Second)

        // 1. Check if parent resource still exists (exit if deleted)
        if _, err := getSession(namespace, sessionName); errors.IsNotFound(err) {
            log.Printf("Session deleted, stopping monitoring")
            return
        }

        // 2. Check Job status
        job, err := K8sClient.BatchV1().Jobs(namespace).Get(ctx, jobName, v1.GetOptions{})
        if errors.IsNotFound(err) {
            return
        }

        // 3. Update status based on Job conditions
        if job.Status.Succeeded > 0 {
            updateStatus(namespace, sessionName, map[string]interface{}{
                "phase": "Completed",
                "completionTime": time.Now().Format(time.RFC3339),
            })
            cleanup(namespace, jobName)
            return
        }
    }
}
```

### Pre-Commit Checklist for Backend/Operator

Before committing backend or operator code, verify:

- [ ] **Authentication**: All user-facing endpoints use `GetK8sClientsForRequest(c)`
- [ ] **Authorization**: RBAC checks performed before resource access
- [ ] **Error Handling**: All errors logged with context, appropriate HTTP status codes
- [ ] **Token Security**: No tokens or sensitive data in logs
- [ ] **Type Safety**: Used `unstructured.Nested*` helpers, checked `found` before using values
- [ ] **Resource Cleanup**: OwnerReferences set on all child resources
- [ ] **Status Updates**: Used `UpdateStatus` subresource, handled IsNotFound gracefully
- [ ] **Tests**: Added/updated tests for new functionality
- [ ] **Logging**: Structured logs with relevant context (namespace, resource name, etc.)
- [ ] **Code Quality**: Ran all linting checks locally (see below)

**Run these commands before committing:**

```bash
# Backend
cd components/backend
gofmt -l .                    # Check formatting (should output nothing)
go vet ./...                  # Detect suspicious constructs
golangci-lint run            # Run comprehensive linting

# Operator
cd components/operator
gofmt -l .
go vet ./...
golangci-lint run
```

**Auto-format code:**

```bash
gofmt -w components/backend components/operator
```

**Note**: GitHub Actions will automatically run these checks on your PR. Fix any issues locally before pushing.

### Common Mistakes to Avoid

**Backend**:

-  Using service account client for user operations (always use user token)
-  Not checking if user-scoped client creation succeeded
-  Logging full token values (use `len(token)` instead)
-  Not validating project access in middleware
-  Type assertions without checking: `val := obj["key"].(string)` (use `val, ok := ...`)
-  Not setting OwnerReferences (causes resource leaks)
-  Treating IsNotFound as fatal error during cleanup
-  Exposing internal error details to API responses (use generic messages)

**Operator**:

-  Not reconnecting watch on channel close
-  Processing events without verifying resource still exists
-  Updating status on main object instead of /status subresource
-  Not checking current phase before reconciliation (causes duplicate resources)
-  Creating resources without idempotency checks
-  Goroutine leaks (not exiting monitor when resource deleted)
-  Using `panic()` in watch/reconciliation loops
-  Not setting SecurityContext on Job pods

### Reference Files

Study these files to understand established patterns:

**Backend**:

- `components/backend/handlers/sessions.go` - Complete session lifecycle, user/SA client usage
- `components/backend/handlers/middleware.go` - Auth patterns, token extraction, RBAC
- `components/backend/handlers/helpers.go` - Utility functions (StringPtr, BoolPtr)
- `components/backend/types/common.go` - Type definitions
- `components/backend/server/server.go` - Server setup, middleware chain, token redaction
- `components/backend/routes.go` - HTTP route definitions and registration

**Operator**:

- `components/operator/internal/handlers/sessions.go` - Watch loop, reconciliation, status updates
- `components/operator/internal/config/config.go` - K8s client initialization
- `components/operator/internal/types/resources.go` - GVR definitions
- `components/operator/internal/services/infrastructure.go` - Reusable services

## GitHub Actions CI/CD

### Component Build Pipeline (`.github/workflows/components-build-deploy.yml`)

- **Change detection**: Only builds modified components (frontend, backend, operator, claude-runner)
- **Multi-platform builds**: linux/amd64 and linux/arm64
- **Registry**: Pushes to `quay.io/ambient_code` on main branch
- **PR builds**: Build-only, no push on pull requests

### Other Workflows

- **claude.yml**: Claude Code integration
- **test-local-dev.yml**: Local development environment validation
- **dependabot-auto-merge.yml**: Automated dependency updates
- **project-automation.yml**: GitHub project board automation

## Testing Strategy

### E2E Tests (Cypress + Kind)

**Purpose**: Automated end-to-end testing of the complete vTeam stack in a Kubernetes environment.

**Location**: `e2e/`

**Quick Start**:

```bash
make e2e-test CONTAINER_ENGINE=podman  # Or docker
```

**What Gets Tested**:

-  Full vTeam deployment in kind (Kubernetes in Docker)
-  Frontend UI rendering and navigation
-  Backend API connectivity
-  Project creation workflow (main user journey)
-  Authentication with ServiceAccount tokens
-  Ingress routing
-  All pods deploy and become ready

**What Doesn't Get Tested**:

-  OAuth proxy flow (uses direct token auth for simplicity)
-  Session pod execution (requires Anthropic API key)
-  Multi-user scenarios

**Test Suite** (`e2e/cypress/e2e/vteam.cy.ts`):

1. UI loads with token authentication
2. Navigate to new project page
3. Create a new project
4. List created projects
5. Backend API cluster-info endpoint

**CI Integration**: Tests run automatically on all PRs via GitHub Actions (`.github/workflows/e2e.yml`)

**Key Implementation Details**:

- **Architecture**: Frontend without oauth-proxy, direct token injection via environment variables
- **Authentication**: Test user ServiceAccount with cluster-admin permissions
- **Token Handling**: Frontend deployment includes `OC_TOKEN`, `OC_USER`, `OC_EMAIL` env vars
- **Podman Support**: Auto-detects runtime, uses ports 8080/8443 for rootless Podman
- **Ingress**: Standard nginx-ingress with path-based routing

**Adding New Tests**:

```typescript
it('should test new feature', () => {
  cy.visit('/some-page')
  cy.contains('Expected Content').should('be.visible')
  cy.get('#button').click()
  // Auth header automatically injected via beforeEach interceptor
})
```

**Debugging Tests**:

```bash
cd e2e
source .env.test
CYPRESS_TEST_TOKEN="$TEST_TOKEN" CYPRESS_BASE_URL="http://vteam.local:8080" npm run test:headed
```

**Documentation**: See `e2e/README.md` and `docs/testing/e2e-guide.md` for comprehensive testing guide.

### Backend Tests (Go)

- **Unit tests** (`tests/unit/`): Isolated component logic
- **Contract tests** (`tests/contract/`): API contract validation
- **Integration tests** (`tests/integration/`): End-to-end with real k8s cluster
  - Requires `TEST_NAMESPACE` environment variable
  - Set `CLEANUP_RESOURCES=true` for automatic cleanup
  - Permission tests validate RBAC boundaries

### Frontend Tests (NextJS)

- Jest for component testing (when configured)
- Cypress for e2e testing (see E2E Tests section above)

### Operator Tests (Go)

- Controller reconciliation logic tests
- CRD validation tests

## Documentation Structure

The MkDocs site (`mkdocs.yml`) provides:

- **User Guide**: Getting started, RFE creation, agent framework, configuration
- **Developer Guide**: Setup, architecture, plugin development, API reference, testing
- **Labs**: Hands-on exercises (basic  advanced  production)
  - Basic: First RFE, agent interaction, workflow basics
  - Advanced: Custom agents, workflow modification, integration testing
  - Production: Jira integration, OpenShift deployment, scaling
- **Reference**: Agent personas, API endpoints, configuration schema, glossary

### Director Training Labs

Special lab track for leadership training located in `docs/labs/director-training/`:

- Structured exercises for understanding the vTeam system from a strategic perspective
- Validation reports for tracking completion and understanding

## Production Considerations

### Security

- **API keys**: Store in Kubernetes Secrets, managed via ProjectSettings CR
- **RBAC**: Namespace-scoped isolation prevents cross-project access
- **OAuth integration**: OpenShift OAuth for cluster-based authentication (see `docs/OPENSHIFT_OAUTH.md`)
- **Network policies**: Component isolation and secure communication

### Monitoring

- **Health endpoints**: `/health` on backend API
- **Logs**: Structured logging with OpenShift integration
- **Metrics**: Prometheus-compatible (when configured)
- **Events**: Kubernetes events for operator actions

### Scaling

- **Horizontal Pod Autoscaling**: Configure based on CPU/memory
- **Job concurrency**: Operator manages concurrent session execution
- **Resource limits**: Set appropriate requests/limits per component
- **Multi-tenancy**: Project-based isolation with shared infrastructure

---

## Frontend Development Standards

**See `components/frontend/DESIGN_GUIDELINES.md` for complete frontend development patterns.**

### Critical Rules (Quick Reference)

1. **Zero `any` Types** - Use proper types, `unknown`, or generic constraints
2. **Shadcn UI Components Only** - Use `@/components/ui/*` components, no custom UI from scratch
3. **React Query for ALL Data Operations** - Use hooks from `@/services/queries/*`, no manual `fetch()`
4. **Use `type` over `interface`** - Always prefer `type` for type definitions
5. **Colocate Single-Use Components** - Keep page-specific components with their pages

### Pre-Commit Checklist for Frontend

Before committing frontend code:

- [ ] Zero `any` types (or justified with eslint-disable)
- [ ] All UI uses Shadcn components
- [ ] All data operations use React Query
- [ ] Components under 200 lines
- [ ] Single-use components colocated with their pages
- [ ] All buttons have loading states
- [ ] All lists have empty states
- [ ] All nested pages have breadcrumbs
- [ ] All routes have loading.tsx, error.tsx
- [ ] `npm run build` passes with 0 errors, 0 warnings
- [ ] All types use `type` instead of `interface`

### Reference Files

- `components/frontend/DESIGN_GUIDELINES.md` - Detailed patterns and examples
- `components/frontend/COMPONENT_PATTERNS.md` - Architecture patterns
- `components/frontend/src/components/ui/` - Available Shadcn components
- `components/frontend/src/services/` - API service layer examples
</file>

<file path="components/frontend/src/app/projects/[name]/sessions/[sessionName]/page.tsx">
"use client";

import { useState, useEffect, useMemo, useRef } from "react";
import { Loader2, FolderTree, GitBranch, Edit, RefreshCw, Folder, Sparkles, X, CloudUpload, CloudDownload, MoreVertical, Cloud, FolderSync, Download, LibraryBig, MessageSquare } from "lucide-react";
import { useRouter } from "next/navigation";

// Custom components
import MessagesTab from "@/components/session/MessagesTab";
import { FileTree, type FileTreeNode } from "@/components/file-tree";

import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger, DropdownMenuSeparator } from "@/components/ui/dropdown-menu";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { Label } from "@/components/ui/label";
import { Breadcrumbs } from "@/components/breadcrumbs";
import { SessionHeader } from "./session-header";

// Extracted components
import { AddContextModal } from "./components/modals/add-context-modal";
import { CustomWorkflowDialog } from "./components/modals/custom-workflow-dialog";
import { ManageRemoteDialog } from "./components/modals/manage-remote-dialog";
import { CommitChangesDialog } from "./components/modals/commit-changes-dialog";
import { WorkflowsAccordion } from "./components/accordions/workflows-accordion";
import { RepositoriesAccordion } from "./components/accordions/repositories-accordion";
import { ArtifactsAccordion } from "./components/accordions/artifacts-accordion";

// Extracted hooks and utilities
import { useGitOperations } from "./hooks/use-git-operations";
import { useWorkflowManagement } from "./hooks/use-workflow-management";
import { useFileOperations } from "./hooks/use-file-operations";
import { adaptSessionMessages } from "./lib/message-adapter";
import type { DirectoryOption, DirectoryRemote } from "./lib/types";

import type { SessionMessage } from "@/types";
import type { MessageObject, ToolUseMessages } from "@/types/agentic-session";

// React Query hooks
import {
  useSession,
  useSessionMessages,
  useStopSession,
  useDeleteSession,
  useSendChatMessage,
  useSendControlMessage,
  useSessionK8sResources,
  useContinueSession,
} from "@/services/queries";
import { useWorkspaceList, useGitMergeStatus, useGitListBranches } from "@/services/queries/use-workspace";
import { successToast, errorToast } from "@/hooks/use-toast";
import { useOOTBWorkflows, useWorkflowMetadata } from "@/services/queries/use-workflows";
import { useMutation } from "@tanstack/react-query";

export default function ProjectSessionDetailPage({
  params,
}: {
  params: Promise<{ name: string; sessionName: string }>;
}) {
  const router = useRouter();
  const [projectName, setProjectName] = useState<string>("");
  const [sessionName, setSessionName] = useState<string>("");
  const [chatInput, setChatInput] = useState("");
  const [backHref, setBackHref] = useState<string | null>(null);
  const [contentPodSpawning, setContentPodSpawning] = useState(false);
  const [contentPodReady, setContentPodReady] = useState(false);
  const [contentPodError, setContentPodError] = useState<string | null>(null);
  const [openAccordionItems, setOpenAccordionItems] = useState<string[]>(["workflows"]);
  const [contextModalOpen, setContextModalOpen] = useState(false);
  const [repoChanging, setRepoChanging] = useState(false);
  const [firstMessageLoaded, setFirstMessageLoaded] = useState(false);
  
  // Directory browser state (unified for artifacts, repos, and workflow)
  const [selectedDirectory, setSelectedDirectory] = useState<DirectoryOption>({
    type: 'artifacts',
    name: 'Shared Artifacts',
    path: 'artifacts'
  });
  const [directoryRemotes, setDirectoryRemotes] = useState<Record<string, DirectoryRemote>>({});
  const [remoteDialogOpen, setRemoteDialogOpen] = useState(false);
  const [commitModalOpen, setCommitModalOpen] = useState(false);
  const [customWorkflowDialogOpen, setCustomWorkflowDialogOpen] = useState(false);

  // Extract params
  useEffect(() => {
    params.then(({ name, sessionName: sName }) => {
      setProjectName(name);
      setSessionName(sName);
      try {
        const url = new URL(window.location.href);
        setBackHref(url.searchParams.get("backHref"));
      } catch {}
    });
  }, [params]);

  // React Query hooks
  const { data: session, isLoading, error, refetch: refetchSession } = useSession(projectName, sessionName);
  const { data: messages = [] } = useSessionMessages(projectName, sessionName, session?.status?.phase);
  const { data: k8sResources } = useSessionK8sResources(projectName, sessionName);
  const stopMutation = useStopSession();
  const deleteMutation = useDeleteSession();
  const continueMutation = useContinueSession();
  const sendChatMutation = useSendChatMessage();
  const sendControlMutation = useSendControlMessage();
  
  // Workflow management hook
  const workflowManagement = useWorkflowManagement({
    projectName,
    sessionName,
    onWorkflowActivated: refetchSession,
  });
  
  // Repo management mutations
  const addRepoMutation = useMutation({
    mutationFn: async (repo: { url: string; branch: string; output?: { url: string; branch: string } }) => {
      setRepoChanging(true);
      const response = await fetch(
        `/api/projects/${projectName}/agentic-sessions/${sessionName}/repos`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(repo),
        }
      );
      if (!response.ok) throw new Error('Failed to add repository');
      const result = await response.json();
      return { ...result, inputRepo: repo };
    },
    onSuccess: async (data) => {
      successToast('Repository cloning...');
      await new Promise(resolve => setTimeout(resolve, 3000));
      await refetchSession();
      
      if (data.name && data.inputRepo) {
        try {
          await fetch(
            `/api/projects/${projectName}/agentic-sessions/${sessionName}/git/configure-remote`,
            {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                path: data.name,
                remoteUrl: data.inputRepo.url,
                branch: data.inputRepo.branch || 'main',
              }),
            }
          );
          
          const newRemotes = {...directoryRemotes};
          newRemotes[data.name] = {
            url: data.inputRepo.url,
            branch: data.inputRepo.branch || 'main'
          };
          setDirectoryRemotes(newRemotes);
        } catch (err) {
          console.error('Failed to configure remote:', err);
        }
      }
      
      setRepoChanging(false);
      successToast('Repository added successfully');
    },
    onError: (error: Error) => {
      setRepoChanging(false);
      errorToast(error.message || 'Failed to add repository');
    },
  });

  const removeRepoMutation = useMutation({
    mutationFn: async (repoName: string) => {
      setRepoChanging(true);
      const response = await fetch(
        `/api/projects/${projectName}/agentic-sessions/${sessionName}/repos/${repoName}`,
        { method: 'DELETE' }
      );
      if (!response.ok) throw new Error('Failed to remove repository');
      return response.json();
    },
    onSuccess: async () => {
      successToast('Repository removing...');
      await new Promise(resolve => setTimeout(resolve, 2000));
      await refetchSession();
      setRepoChanging(false);
      successToast('Repository removed successfully');
    },
    onError: (error: Error) => {
      setRepoChanging(false);
      errorToast(error.message || 'Failed to remove repository');
    },
  });
  
  // Fetch OOTB workflows
  const { data: ootbWorkflows = [] } = useOOTBWorkflows(projectName);
  
  // Fetch workflow metadata
  const { data: workflowMetadata } = useWorkflowMetadata(
    projectName,
    sessionName,
    !!workflowManagement.activeWorkflow && !workflowManagement.workflowActivating
  );
  
  // Git operations for selected directory
  const currentRemote = directoryRemotes[selectedDirectory.path];
  const { data: mergeStatus, refetch: refetchMergeStatus } = useGitMergeStatus(
    projectName,
    sessionName,
    selectedDirectory.path,
    currentRemote?.branch || 'main',
    !!currentRemote
  );
  const { data: remoteBranches = [] } = useGitListBranches(
    projectName,
    sessionName,
    selectedDirectory.path,
    !!currentRemote
  );
  
  // Git operations hook
  const gitOps = useGitOperations({
    projectName,
    sessionName,
    directoryPath: selectedDirectory.path,
    remoteBranch: currentRemote?.branch || 'main',
  });
  
  // File operations for directory explorer
  const fileOps = useFileOperations({
    projectName,
    sessionName,
    basePath: selectedDirectory.path,
  });
  
  const { data: directoryFiles = [], refetch: refetchDirectoryFiles } = useWorkspaceList(
    projectName,
    sessionName,
    fileOps.currentSubPath ? `${selectedDirectory.path}/${fileOps.currentSubPath}` : selectedDirectory.path,
    { enabled: openAccordionItems.includes("directories") }
  );
  
  // Artifacts file operations
  const artifactsOps = useFileOperations({
    projectName,
    sessionName,
    basePath: 'artifacts',
  });
  
  const { data: artifactsFiles = [], refetch: refetchArtifactsFiles } = useWorkspaceList(
    projectName,
    sessionName,
    artifactsOps.currentSubPath ? `artifacts/${artifactsOps.currentSubPath}` : 'artifacts',
    { enabled: openAccordionItems.includes("artifacts") }
  );
  
  // Track if we've already initialized from session
  const initializedFromSessionRef = useRef(false);
  
  // Track when first message loads
  useEffect(() => {
    if (messages && messages.length > 0 && !firstMessageLoaded) {
      setFirstMessageLoaded(true);
    }
  }, [messages, firstMessageLoaded]);
  
  // Load active workflow and remotes from session
  useEffect(() => {
    if (initializedFromSessionRef.current || !session) return;
    
    if (session.spec?.activeWorkflow && ootbWorkflows.length === 0) {
      return;
    }
    
    if (session.spec?.activeWorkflow) {
      const gitUrl = session.spec.activeWorkflow.gitUrl;
      const matchingWorkflow = ootbWorkflows.find(w => w.gitUrl === gitUrl);
      if (matchingWorkflow) {
        workflowManagement.setActiveWorkflow(matchingWorkflow.id);
        workflowManagement.setSelectedWorkflow(matchingWorkflow.id);
      } else {
        workflowManagement.setActiveWorkflow("custom");
        workflowManagement.setSelectedWorkflow("custom");
      }
    }
    
    // Load remotes from annotations
    const annotations = session.metadata?.annotations || {};
    const remotes: Record<string, DirectoryRemote> = {};
    
    Object.keys(annotations).forEach(key => {
      if (key.startsWith('ambient-code.io/remote-') && key.endsWith('-url')) {
        const path = key.replace('ambient-code.io/remote-', '').replace('-url', '').replace(/::/g, '/');
        const branchKey = key.replace('-url', '-branch');
        remotes[path] = {
          url: annotations[key],
          branch: annotations[branchKey] || 'main'
        };
      }
    });
    
    setDirectoryRemotes(remotes);
    initializedFromSessionRef.current = true;
  }, [session, ootbWorkflows, workflowManagement]);

  // Compute directory options
  const directoryOptions = useMemo<DirectoryOption[]>(() => {
    const options: DirectoryOption[] = [
      { type: 'artifacts', name: 'Shared Artifacts', path: 'artifacts' }
    ];
    
    if (session?.spec?.repos) {
      session.spec.repos.forEach((repo, idx) => {
        const repoName = repo.input.url.split('/').pop()?.replace('.git', '') || `repo-${idx}`;
        options.push({
          type: 'repo',
          name: repoName,
          path: repoName
        });
      });
    }
    
    if (workflowManagement.activeWorkflow && session?.spec?.activeWorkflow) {
      const workflowName = session.spec.activeWorkflow.gitUrl.split('/').pop()?.replace('.git', '') || 'workflow';
      options.push({
        type: 'workflow',
        name: `Workflow: ${workflowName}`,
        path: `workflows/${workflowName}`
      });
    }
    
    return options;
  }, [session, workflowManagement.activeWorkflow]);

  // Workflow change handler
  const handleWorkflowChange = (value: string) => {
    workflowManagement.handleWorkflowChange(
      value,
      ootbWorkflows,
      () => setCustomWorkflowDialogOpen(true)
    );
  };

  // Convert messages using extracted adapter
  const streamMessages: Array<MessageObject | ToolUseMessages> = useMemo(() => {
    return adaptSessionMessages(messages as SessionMessage[], session?.spec?.interactive || false);
  }, [messages, session?.spec?.interactive]);

  // Session action handlers
  const handleStop = () => {
    stopMutation.mutate(
      { projectName, sessionName },
      {
        onSuccess: () => successToast("Session stopped successfully"),
        onError: (err) => errorToast(err instanceof Error ? err.message : "Failed to stop session"),
      }
    );
  };

  const handleDelete = () => {
    const displayName = session?.spec.displayName || session?.metadata.name;
    if (!confirm(`Are you sure you want to delete agentic session "${displayName}"? This action cannot be undone.`)) {
      return;
    }

    deleteMutation.mutate(
      { projectName, sessionName },
      {
        onSuccess: () => {
          router.push(backHref || `/projects/${encodeURIComponent(projectName)}/sessions`);
        },
        onError: (err) => errorToast(err instanceof Error ? err.message : "Failed to delete session"),
      }
    );
  };

  const handleContinue = () => {
    continueMutation.mutate(
      { projectName, parentSessionName: sessionName },
      {
        onSuccess: () => {
          successToast("Session restarted successfully");
        },
        onError: (err) => errorToast(err instanceof Error ? err.message : "Failed to restart session"),
      }
    );
  };

  const sendChat = () => {
    if (!chatInput.trim()) return;

    const finalMessage = chatInput.trim();

    sendChatMutation.mutate(
      { projectName, sessionName, content: finalMessage },
      {
        onSuccess: () => {
          setChatInput("");
        },
        onError: (err) => errorToast(err instanceof Error ? err.message : "Failed to send message"),
      }
    );
  };

  const handleCommandClick = (slashCommand: string) => {
    const finalMessage = slashCommand;

    sendChatMutation.mutate(
      { projectName, sessionName, content: finalMessage },
      {
        onSuccess: () => {
          successToast(`Command ${slashCommand} sent`);
        },
        onError: (err) => errorToast(err instanceof Error ? err.message : "Failed to send command"),
      }
    );
  };

  const handleInterrupt = () => {
    sendControlMutation.mutate(
      { projectName, sessionName, type: 'interrupt' },
      {
        onSuccess: () => successToast("Agent interrupted"),
        onError: (err) => errorToast(err instanceof Error ? err.message : "Failed to interrupt agent"),
      }
    );
  };

  const handleEndSession = () => {
    sendControlMutation.mutate(
      { projectName, sessionName, type: 'end_session' },
      {
        onSuccess: () => successToast("Session ended successfully"),
        onError: (err) => errorToast(err instanceof Error ? err.message : "Failed to end session"),
      }
    );
  };

  // Auto-spawn content pod on completed session
  const sessionCompleted = (
    session?.status?.phase === 'Completed' ||
    session?.status?.phase === 'Failed' ||
    session?.status?.phase === 'Stopped'
  );

  useEffect(() => {
    if (sessionCompleted && !contentPodReady && !contentPodSpawning && !contentPodError) {
      spawnContentPodAsync();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [sessionCompleted, contentPodReady, contentPodSpawning, contentPodError]);

  const spawnContentPodAsync = async () => {
    if (!projectName || !sessionName) return;
    
    setContentPodSpawning(true);
    setContentPodError(null);
    
    try {
      const { spawnContentPod, getContentPodStatus } = await import('@/services/api/sessions');
      
      const spawnResult = await spawnContentPod(projectName, sessionName);
      
      if (spawnResult.status === 'exists' && spawnResult.ready) {
        setContentPodReady(true);
        setContentPodSpawning(false);
        setContentPodError(null);
        return;
      }
      
      let attempts = 0;
      const maxAttempts = 30;
      
      const pollInterval = setInterval(async () => {
        attempts++;
        
        try {
          const status = await getContentPodStatus(projectName, sessionName);
          
          if (status.ready) {
            clearInterval(pollInterval);
            setContentPodReady(true);
            setContentPodSpawning(false);
            setContentPodError(null);
            successToast('Workspace viewer ready');
          }
          
          if (attempts >= maxAttempts) {
            clearInterval(pollInterval);
            setContentPodSpawning(false);
            const errorMsg = 'Workspace viewer failed to start within 30 seconds';
            setContentPodError(errorMsg);
            errorToast(errorMsg);
          }
        } catch {
          if (attempts >= maxAttempts) {
            clearInterval(pollInterval);
            setContentPodSpawning(false);
            const errorMsg = 'Workspace viewer failed to start';
            setContentPodError(errorMsg);
            errorToast(errorMsg);
          }
        }
      }, 1000);
      
    } catch (error) {
      setContentPodSpawning(false);
      const errorMsg = error instanceof Error ? error.message : 'Failed to spawn workspace viewer';
      setContentPodError(errorMsg);
      errorToast(errorMsg);
    }
  };

  const durationMs = useMemo(() => {
    const start = session?.status?.startTime ? new Date(session.status.startTime).getTime() : undefined;
    const end = session?.status?.completionTime ? new Date(session.status.completionTime).getTime() : Date.now();
    return start ? Math.max(0, end - start) : undefined;
  }, [session?.status?.startTime, session?.status?.completionTime]);

  // Loading state
  if (isLoading || !projectName || !sessionName) {
    return (
      <div className="absolute inset-0 top-16 overflow-hidden bg-[#f8fafc] flex items-center justify-center">
        <div className="flex items-center">
          <div className="animate-spin h-8 w-8 border-4 border-primary border-t-transparent rounded-full" />
          <span className="ml-2">Loading session...</span>
        </div>
      </div>
    );
  }

  // Error state
  if (error || !session) {
    return (
      <div className="absolute inset-0 top-16 overflow-hidden bg-[#f8fafc] flex flex-col">
        <div className="flex-shrink-0 bg-white border-b">
          <div className="container mx-auto px-6 py-4">
            <Breadcrumbs
              items={[
                { label: 'Workspaces', href: '/projects' },
                { label: projectName, href: `/projects/${projectName}` },
                { label: 'Sessions', href: `/projects/${projectName}/sessions` },
                { label: 'Error' },
              ]}
              className="mb-4"
            />
          </div>
        </div>
        <div className="flex-grow overflow-hidden">
          <div className="h-full container mx-auto px-6 py-6">
            <Card className="border-red-200 bg-red-50">
              <CardContent className="pt-6">
                <p className="text-red-700">Error: {error instanceof Error ? error.message : "Session not found"}</p>
              </CardContent>
            </Card>
          </div>
        </div>
      </div>
    );
  }

  return (
    <>
      <div className="absolute inset-0 top-16 overflow-hidden bg-[#f8fafc] flex flex-col">
        {/* Fixed header */}
        <div className="flex-shrink-0 bg-white border-b">
          <div className="container mx-auto px-6 py-4">
            <Breadcrumbs
              items={[
                { label: 'Workspaces', href: '/projects' },
                { label: projectName, href: `/projects/${projectName}` },
                { label: 'Sessions', href: `/projects/${projectName}/sessions` },
                { label: session.spec.displayName || session.metadata.name },
              ]}
              className="mb-4"
            />
            <SessionHeader
              session={session}
              projectName={projectName}
              actionLoading={
                stopMutation.isPending ? "stopping" :
                deleteMutation.isPending ? "deleting" :
                continueMutation.isPending ? "resuming" :
                null
              }
              onRefresh={refetchSession}
              onStop={handleStop}
              onContinue={handleContinue}
              onDelete={handleDelete}
              durationMs={durationMs}
              k8sResources={k8sResources}
              messageCount={messages.length}
            />
          </div>
        </div>

        {/* Main content area */}
        <div className="flex-grow overflow-hidden">
          <div className="h-full container mx-auto px-6 py-6">
            <div className="h-full flex gap-6">
              {/* Left Column - Accordions */}
              <div className="w-2/5 flex flex-col min-w-0 relative">
                {/* Blocking overlay when first message hasn't loaded and session is pending */}
                {!firstMessageLoaded && session?.status?.phase === 'Pending' && (
                  <div className="absolute inset-0 bg-white/60 backdrop-blur-sm rounded-lg z-20 flex items-center justify-center">
                    <div className="flex flex-col items-center justify-center text-center text-muted-foreground">
                      <LibraryBig className="w-8 h-8 mx-auto mb-2 opacity-50" />
                      <div className="flex items-center gap-2">
                        <Loader2 className="h-4 w-4 animate-spin text-blue-600" />
                        <p className="text-sm">No context yet</p>
                      </div>
                      <p className="text-xs mt-1">Context will appear once the session starts...</p>
                    </div>
                  </div>
                )}
                <div className={`overflow-y-auto flex-grow pb-6 ${!firstMessageLoaded && session?.status?.phase === 'Pending' ? 'pointer-events-none opacity-50' : ''}`}>
                  <Accordion type="multiple" value={openAccordionItems} onValueChange={setOpenAccordionItems} className="w-full space-y-3">
                    <WorkflowsAccordion
                      sessionPhase={session?.status?.phase}
                      activeWorkflow={workflowManagement.activeWorkflow}
                      selectedWorkflow={workflowManagement.selectedWorkflow}
                      pendingWorkflow={workflowManagement.pendingWorkflow}
                      workflowActivating={workflowManagement.workflowActivating}
                      workflowMetadata={workflowMetadata}
                      ootbWorkflows={ootbWorkflows}
                      isExpanded={openAccordionItems.includes("workflows")}
                      onWorkflowChange={handleWorkflowChange}
                      onActivateWorkflow={workflowManagement.activateWorkflow}
                      onCommandClick={handleCommandClick}
                      onResume={handleContinue}
                    />

                    <RepositoriesAccordion
                      repositories={session?.spec?.repos || []}
                      onAddRepository={() => setContextModalOpen(true)}
                      onRemoveRepository={(repoName) => removeRepoMutation.mutate(repoName)}
                    />

                    <ArtifactsAccordion
                      files={artifactsFiles}
                      currentSubPath={artifactsOps.currentSubPath}
                      viewingFile={artifactsOps.viewingFile}
                      isLoadingFile={artifactsOps.loadingFile}
                      onFileOrFolderSelect={artifactsOps.handleFileOrFolderSelect}
                      onRefresh={refetchArtifactsFiles}
                      onDownloadFile={artifactsOps.handleDownloadFile}
                      onNavigateBack={artifactsOps.navigateBack}
                    />

                    {/* Experimental - File Explorer */}
                    <AccordionItem value="experimental" className="border rounded-lg px-3 bg-white">
                      <AccordionTrigger className="text-base font-semibold hover:no-underline py-3">
                        <div className="flex items-center gap-2">
                          <Sparkles className="h-4 w-4" />
                          <span>Experimental</span>
                        </div>
                      </AccordionTrigger>
                      <AccordionContent className="pt-2 pb-3">
                        <div className="space-y-3">
                          <Accordion 
                            type="multiple" 
                            value={openAccordionItems} 
                            onValueChange={setOpenAccordionItems}
                          >
                            <AccordionItem value="directories" className="border rounded-lg px-3 bg-muted/10">
                              <AccordionTrigger className="text-base font-semibold hover:no-underline py-3">
                                <div className="flex items-center gap-2 w-full">
                                  <Folder className="h-4 w-4" />
                                  <span>File Explorer</span>
                                  {gitOps.gitStatus?.hasChanges && (
                                    <div className="flex gap-1 ml-auto mr-2">
                                      {(gitOps.gitStatus?.totalAdded ?? 0) > 0 && (
                                        <Badge variant="outline" className="bg-green-50 text-green-700 border-green-200">
                                          +{gitOps.gitStatus.totalAdded}
                                        </Badge>
                                      )}
                                      {(gitOps.gitStatus?.totalRemoved ?? 0) > 0 && (
                                        <Badge variant="outline" className="bg-red-50 text-red-700 border-red-200">
                                          -{gitOps.gitStatus.totalRemoved}
                                        </Badge>
                                      )}
                                    </div>
                                  )}
                                </div>
                              </AccordionTrigger>
                              <AccordionContent className="pt-2 pb-3">
                                <div className="space-y-3">
                                  <p className="text-sm text-muted-foreground">
                                    Browse, view, and manage files in your workspace directories. Track changes and sync with Git for version control.
                                  </p>
                                  
                                  {/* Directory Selector */}
                                  <div className="flex items-center justify-between gap-2">
                                    <Label className="text-xs text-muted-foreground">Directory:</Label>
                                    <Select
                                      value={`${selectedDirectory.type}:${selectedDirectory.path}`}
                                      onValueChange={(value) => {
                                        const [type, ...pathParts] = value.split(':');
                                        const path = pathParts.join(':');
                                        const option = directoryOptions.find(
                                          opt => opt.type === type && opt.path === path
                                        );
                                        if (option) setSelectedDirectory(option);
                                      }}
                                    >
                                      <SelectTrigger className="w-[250px] h-8">
                                        <SelectValue />
                                      </SelectTrigger>
                                      <SelectContent>
                                        {directoryOptions.map(opt => (
                                          <SelectItem key={`${opt.type}:${opt.path}`} value={`${opt.type}:${opt.path}`}>
                                            <div className="flex items-center gap-2">
                                              {opt.type === 'artifacts' && <Folder className="h-3 w-3" />}
                                              {opt.type === 'repo' && <GitBranch className="h-3 w-3" />}
                                              {opt.type === 'workflow' && <Sparkles className="h-3 w-3" />}
                                              <span className="text-xs">{opt.name}</span>
                                            </div>
                                          </SelectItem>
                                        ))}
                                      </SelectContent>
                                    </Select>
                                  </div>
                                  
                                  {/* File Browser */}
                                  <div className="border rounded-lg overflow-hidden">
                                    <div className="px-2 py-1.5 border-b flex items-center justify-between bg-muted/30">
                                      <div className="flex items-center gap-1 text-xs text-muted-foreground min-w-0 flex-1">
                                        {(fileOps.currentSubPath || fileOps.viewingFile) && (
                                          <Button 
                                            variant="ghost" 
                                            size="sm" 
                                            onClick={fileOps.navigateBack}
                                            className="h-6 px-1.5 mr-1"
                                          >
                                             Back
                                          </Button>
                                        )}
                                        
                                        <Folder className="inline h-3 w-3 mr-1 flex-shrink-0" />
                                        <code className="bg-muted px-1 py-0.5 rounded text-xs truncate">
                                          {selectedDirectory.path}
                                          {fileOps.currentSubPath && `/${fileOps.currentSubPath}`}
                                          {fileOps.viewingFile && `/${fileOps.viewingFile.path}`}
                                        </code>
                                      </div>

                                      {fileOps.viewingFile ? (
                                        <div className="flex items-center gap-1">
                                          <Button
                                            variant="ghost"
                                            size="sm"
                                            onClick={fileOps.handleDownloadFile}
                                            className="h-6 px-2 flex-shrink-0"
                                            title="Download file"
                                          >
                                            <Download className="h-3 w-3" />
                                          </Button>
                                          <DropdownMenu>
                                            <DropdownMenuTrigger asChild>
                                              <Button variant="ghost" size="sm" className="h-6 px-2 flex-shrink-0">
                                                <MoreVertical className="h-3 w-3" />
                                              </Button>
                                            </DropdownMenuTrigger>
                                            <DropdownMenuContent align="end">
                                              <DropdownMenuItem disabled className="text-xs text-muted-foreground">
                                                Sync to Jira - Coming soon
                                              </DropdownMenuItem>
                                              <DropdownMenuItem disabled className="text-xs text-muted-foreground">
                                                Sync to GDrive - Coming soon
                                              </DropdownMenuItem>
                                            </DropdownMenuContent>
                                          </DropdownMenu>
                                        </div>
                                      ) : (
                                        <Button variant="ghost" size="sm" onClick={() => refetchDirectoryFiles()} className="h-6 px-2 flex-shrink-0">
                                          <FolderSync className="h-3 w-3" />
                                        </Button>
                                      )}
                                    </div>
                                    
                                    <div className="p-2 max-h-64 overflow-y-auto">
                                      {fileOps.loadingFile ? (
                                        <div className="flex items-center justify-center py-8">
                                          <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
                                        </div>
                                      ) : fileOps.viewingFile ? (
                                        <div className="text-xs">
                                          <pre className="bg-muted/50 p-2 rounded overflow-x-auto">
                                            <code>{fileOps.viewingFile.content}</code>
                                          </pre>
                                        </div>
                                      ) : directoryFiles.length === 0 ? (
                                        <div className="text-center py-4 text-sm text-muted-foreground">
                                          <FolderTree className="h-8 w-8 mx-auto mb-2 opacity-30" />
                                          <p>No files yet</p>
                                          <p className="text-xs mt-1">Files will appear here</p>
                                        </div>
                                      ) : (
                                        <FileTree 
                                          nodes={directoryFiles.map((item): FileTreeNode => ({
                                            name: item.name,
                                            path: item.path,
                                            type: item.isDir ? 'folder' : 'file',
                                            sizeKb: item.size ? item.size / 1024 : undefined,
                                          }))}
                                          onSelect={fileOps.handleFileOrFolderSelect}
                                        />
                                      )}
                                    </div>
                                  </div>
                                  
                                  {/* Remote Configuration */}
                                  {!currentRemote ? (
                                    <div className="border border-blue-200 bg-blue-50 rounded-md px-3 py-2 flex items-center justify-between">
                                      <span className="text-sm text-blue-800">Set up Git remote for version control</span>
                                      <Button onClick={() => setRemoteDialogOpen(true)} size="sm" variant="outline">
                                        <GitBranch className="mr-2 h-3 w-3" />
                                        Configure
                                      </Button>
                                    </div>
                                  ) : (
                                    <div className="border rounded-md px-2 py-1.5">
                                      <div className="flex items-center gap-2 text-xs">
                                        <div className="flex items-center gap-1.5 text-muted-foreground">
                                          <Cloud className="h-3 w-3" />
                                          <span className="truncate max-w-[200px]">
                                            {currentRemote?.url?.split('/').slice(-2).join('/').replace('.git', '') || ''}/{currentRemote?.branch || 'main'}
                                          </span>
                                        </div>
                                        
                                        <div className="flex-1" />
                                        
                                        {mergeStatus && !mergeStatus.canMergeClean ? (
                                          <div className="flex items-center gap-1 text-red-600">
                                            <X className="h-3 w-3" />
                                            <span className="font-medium">conflict</span>
                                          </div>
                                        ) : (gitOps.gitStatus?.hasChanges || mergeStatus?.remoteCommitsAhead) ? (
                                          <div className="flex items-center gap-1.5 text-muted-foreground text-xs">
                                            {mergeStatus?.remoteCommitsAhead ? (
                                              <span>{mergeStatus.remoteCommitsAhead}</span>
                                            ) : null}
                                            {gitOps.gitStatus?.hasChanges ? (
                                              <span className="font-normal">{gitOps.gitStatus?.uncommittedFiles ?? 0} uncommitted</span>
                                            ) : null}
                                          </div>
                                        ) : null}
                                        
                                        <TooltipProvider>
                                          <Tooltip>
                                            <TooltipTrigger asChild>
                                              <Button 
                                                size="sm"
                                                variant="ghost"
                                                onClick={() => gitOps.handleGitSynchronize(refetchMergeStatus)}
                                                disabled={!mergeStatus?.canMergeClean || gitOps.synchronizing || gitOps.gitStatus?.hasChanges}
                                                className="h-6 w-6 p-0"
                                              >
                                                {gitOps.synchronizing ? (
                                                  <Loader2 className="h-3 w-3 animate-spin" />
                                                ) : (
                                                  <RefreshCw className="h-3 w-3" />
                                                )}
                                              </Button>
                                            </TooltipTrigger>
                                            <TooltipContent>
                                              <p>{gitOps.gitStatus?.hasChanges ? 'Commit changes first' : `Sync with origin/${currentRemote?.branch || 'main'}`}</p>
                                            </TooltipContent>
                                          </Tooltip>
                                        </TooltipProvider>

                                        <DropdownMenu>
                                          <DropdownMenuTrigger asChild>
                                            <Button size="sm" variant="ghost" className="h-6 w-6 p-0">
                                              <MoreVertical className="h-3 w-3" />
                                            </Button>
                                          </DropdownMenuTrigger>
                                          <DropdownMenuContent align="end">
                                            <DropdownMenuItem onClick={() => setRemoteDialogOpen(true)}>
                                              <Edit className="mr-2 h-3 w-3" />
                                              Manage Remote
                                            </DropdownMenuItem>
                                            <DropdownMenuSeparator />
                                            <DropdownMenuItem
                                              onClick={() => setCommitModalOpen(true)}
                                              disabled={!gitOps.gitStatus?.hasChanges}
                                            >
                                              <Edit className="mr-2 h-3 w-3" />
                                              Commit Changes
                                            </DropdownMenuItem>
                                            <DropdownMenuItem
                                              onClick={() => gitOps.handleGitPull(refetchMergeStatus)}
                                              disabled={!mergeStatus?.canMergeClean || gitOps.isPulling}
                                            >
                                              <CloudDownload className="mr-2 h-3 w-3" />
                                              Pull
                                            </DropdownMenuItem>
                                            <DropdownMenuItem
                                              onClick={() => gitOps.handleGitPush(refetchMergeStatus)}
                                              disabled={!mergeStatus?.canMergeClean || gitOps.isPushing || gitOps.gitStatus?.hasChanges}
                                            >
                                              <CloudUpload className="mr-2 h-3 w-3" />
                                              Push
                                            </DropdownMenuItem>
                                            <DropdownMenuSeparator />
                                            <DropdownMenuItem
                                              onClick={() => {
                                                const newRemotes = {...directoryRemotes};
                                                delete newRemotes[selectedDirectory.path];
                                                setDirectoryRemotes(newRemotes);
                                                successToast("Git remote disconnected");
                                              }}
                                            >
                                              <X className="mr-2 h-3 w-3 text-red-600" />
                                              Disconnect
                                            </DropdownMenuItem>
                                          </DropdownMenuContent>
                                        </DropdownMenu>
                                      </div>
                                    </div>
                                  )}
                                </div>
                              </AccordionContent>
                            </AccordionItem>
                          </Accordion>
                        </div>
                      </AccordionContent>
                    </AccordionItem>
                  </Accordion>
                </div>
              </div>

              {/* Right Column - Messages */}
              <div className="flex-1 flex flex-col min-w-0">
                <Card className="relative flex-1 flex flex-col overflow-hidden py-4">
                  <CardContent className="px-3 pt-3 pb-0 flex-1 flex flex-col overflow-hidden">
                    {/* Workflow activation overlay */}
                    {workflowManagement.workflowActivating && (
                      <div className="absolute inset-0 bg-white/90 backdrop-blur-sm z-10 flex items-center justify-center rounded-lg">
                        <Alert className="max-w-md mx-4">
                          <Loader2 className="h-4 w-4 animate-spin" />
                          <AlertTitle>Activating Workflow...</AlertTitle>
                          <AlertDescription>
                            <p>The new workflow is being loaded. Please wait...</p>
                          </AlertDescription>
                        </Alert>
                      </div>
                    )}
                    
                    {/* Repository change overlay */}
                    {repoChanging && (
                      <div className="absolute inset-0 bg-white/90 backdrop-blur-sm z-10 flex items-center justify-center rounded-lg">
                        <Alert className="max-w-md mx-4">
                          <Loader2 className="h-4 w-4 animate-spin" />
                          <AlertTitle>Updating Repositories...</AlertTitle>
                          <AlertDescription>
                            <div className="space-y-2">
                              <p>Please wait while repositories are being updated. This may take 10-20 seconds...</p>
                            </div>
                          </AlertDescription>
                        </Alert>
                      </div>
                    )}
                    
                    {/* Session starting overlay */}
                    {!firstMessageLoaded && session?.status?.phase === 'Pending' && (
                      <div className="absolute inset-0 bg-white/60 backdrop-blur-sm rounded-lg z-20 flex items-center justify-center">
                        <div className="flex flex-col items-center justify-center text-center text-muted-foreground">
                          <MessageSquare className="w-8 h-8 mx-auto mb-2 opacity-50" />
                          <div className="flex items-center gap-2">
                            <Loader2 className="h-4 w-4 animate-spin text-blue-600" />
                            <p className="text-sm">No messages yet</p>
                          </div>
                          <p className="text-xs mt-1">Messages will appear once the session starts...</p>
                        </div>
                      </div>
                    )}
                    
                    <div className={`flex flex-col flex-1 overflow-hidden ${!firstMessageLoaded && session?.status?.phase === 'Pending' ? 'pointer-events-none opacity-50' : ''}`}>
                      <MessagesTab
                        session={session}
                        streamMessages={streamMessages}
                        chatInput={chatInput}
                        setChatInput={setChatInput}
                        onSendChat={() => Promise.resolve(sendChat())}
                        onInterrupt={() => Promise.resolve(handleInterrupt())}
                        onEndSession={() => Promise.resolve(handleEndSession())}
                        onGoToResults={() => {}}
                        onContinue={handleContinue}
                        workflowMetadata={workflowMetadata}
                        onCommandClick={handleCommandClick}
                      />
                    </div>
                  </CardContent>
                </Card>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Modals */}
      <AddContextModal
        open={contextModalOpen}
        onOpenChange={setContextModalOpen}
        onAddRepository={async (url, branch) => {
          await addRepoMutation.mutateAsync({ url, branch });
          setContextModalOpen(false);
        }}
        isLoading={addRepoMutation.isPending}
      />

      <CustomWorkflowDialog
        open={customWorkflowDialogOpen}
        onOpenChange={setCustomWorkflowDialogOpen}
        onSubmit={(url, branch, path) => {
          workflowManagement.setCustomWorkflow(url, branch, path);
          setCustomWorkflowDialogOpen(false);
        }}
        isActivating={workflowManagement.workflowActivating}
      />

      <ManageRemoteDialog
        open={remoteDialogOpen}
        onOpenChange={setRemoteDialogOpen}
        onSave={async (url, branch) => {
          const success = await gitOps.configureRemote(url, branch);
          if (success) {
            const newRemotes = {...directoryRemotes};
            newRemotes[selectedDirectory.path] = { url, branch };
            setDirectoryRemotes(newRemotes);
            setRemoteDialogOpen(false);
            refetchMergeStatus();
          }
        }}
        directoryName={selectedDirectory.name}
        currentUrl={currentRemote?.url}
        currentBranch={currentRemote?.branch}
        remoteBranches={remoteBranches}
        mergeStatus={mergeStatus}
        isLoading={gitOps.isConfiguringRemote}
      />

      <CommitChangesDialog
        open={commitModalOpen}
        onOpenChange={setCommitModalOpen}
        onCommit={async (message) => {
          const success = await gitOps.handleCommit(message);
          if (success) {
            setCommitModalOpen(false);
            refetchMergeStatus();
          }
        }}
        gitStatus={gitOps.gitStatus ?? null}
        directoryName={selectedDirectory.name}
        isCommitting={gitOps.committing}
      />
    </>
  );
}
</file>

</files>
