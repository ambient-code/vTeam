This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: CLAUDE.md, README.md, components/backend/**, components/manifests/base/*backend*, components/manifests/base/crds/**, docs/developer-guide/backend-api.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
components/
  backend/
    git/
      operations.go
    github/
      app.go
      token.go
    handlers/
      content.go
      github_auth.go
      health.go
      helpers.go
      middleware.go
      permissions.go
      projects.go
      repo.go
      secrets.go
      sessions.go
    jira/
      integration.go
    k8s/
      resources.go
    server/
      k8s.go
      server.go
    types/
      common.go
      project.go
      session.go
    websocket/
      handlers.go
      hub.go
    .env.example
    .gitignore
    .golangci.yml
    Dockerfile
    Dockerfile.dev
    go.mod
    main.go
    Makefile
    README.md
    routes.go
  manifests/
    base/
      crds/
        agenticsessions-crd.yaml
        kustomization.yaml
        projectsettings-crd.yaml
      backend-deployment.yaml
CLAUDE.md
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="components/backend/handlers/health.go">
package handlers

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

// Health returns a simple health check handler
func Health(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{"status": "healthy"})
}
</file>

<file path="components/backend/handlers/middleware.go">
package handlers

import (
	"encoding/base64"
	"encoding/json"
	"log"
	"net/http"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	authv1 "k8s.io/api/authorization/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/dynamic"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
)

// Dependencies injected from main package
var (
	BaseKubeConfig *rest.Config
	K8sClientMw    *kubernetes.Clientset
)

// Helper functions and types
var (
	BoolPtr   = func(b bool) *bool { return &b }
	StringPtr = func(s string) *string { return &s }
)

// ContentListItem represents a content list item for file browsing
type ContentListItem struct {
	Name       string `json:"name"`
	Path       string `json:"path"`
	IsDir      bool   `json:"isDir"`
	Size       int64  `json:"size"`
	ModifiedAt string `json:"modifiedAt"`
}

// GetK8sClientsForRequest returns K8s typed and dynamic clients using the caller's token when provided.
// It supports both Authorization: Bearer and X-Forwarded-Access-Token and NEVER falls back to the backend service account.
// Returns nil, nil if no valid user token is provided - all API operations require user authentication.
func GetK8sClientsForRequest(c *gin.Context) (*kubernetes.Clientset, dynamic.Interface) {
	// Prefer Authorization header (Bearer <token>)
	rawAuth := c.GetHeader("Authorization")
	rawFwd := c.GetHeader("X-Forwarded-Access-Token")
	tokenSource := "none"
	token := rawAuth

	if token != "" {
		tokenSource = "authorization"
		parts := strings.SplitN(token, " ", 2)
		if len(parts) == 2 && strings.ToLower(parts[0]) == "bearer" {
			token = strings.TrimSpace(parts[1])
		} else {
			token = strings.TrimSpace(token)
		}
	}
	// Fallback to X-Forwarded-Access-Token
	if token == "" {
		if rawFwd != "" {
			tokenSource = "x-forwarded-access-token"
		}
		token = rawFwd
	}

	// Debug: basic auth header state (do not log token)
	hasAuthHeader := strings.TrimSpace(rawAuth) != ""
	hasFwdToken := strings.TrimSpace(rawFwd) != ""

	if token != "" && BaseKubeConfig != nil {
		cfg := *BaseKubeConfig
		cfg.BearerToken = token
		// Ensure we do NOT fall back to the in-cluster SA token or other auth providers
		cfg.BearerTokenFile = ""
		cfg.AuthProvider = nil
		cfg.ExecProvider = nil
		cfg.Username = ""
		cfg.Password = ""

		kc, err1 := kubernetes.NewForConfig(&cfg)
		dc, err2 := dynamic.NewForConfig(&cfg)

		if err1 == nil && err2 == nil {

			// Best-effort update last-used for service account tokens
			updateAccessKeyLastUsedAnnotation(c)
			return kc, dc
		}
		// Token provided but client build failed – treat as invalid token
		log.Printf("Failed to build user-scoped k8s clients (source=%s tokenLen=%d) typedErr=%v dynamicErr=%v for %s", tokenSource, len(token), err1, err2, c.FullPath())
		return nil, nil
	} else {
		// No token provided
		log.Printf("No user token found for %s (hasAuthHeader=%t hasFwdToken=%t)", c.FullPath(), hasAuthHeader, hasFwdToken)
		return nil, nil
	}
}

// updateAccessKeyLastUsedAnnotation attempts to update the ServiceAccount's last-used annotation
// when the incoming token is a ServiceAccount JWT. Uses the backend service account client strictly
// for this telemetry update and only for SAs labeled app=ambient-access-key. Best-effort; errors ignored.
func updateAccessKeyLastUsedAnnotation(c *gin.Context) {
	// Parse Authorization header
	rawAuth := c.GetHeader("Authorization")
	parts := strings.SplitN(rawAuth, " ", 2)
	if len(parts) != 2 || !strings.EqualFold(parts[0], "Bearer") {
		return
	}
	token := strings.TrimSpace(parts[1])
	if token == "" {
		return
	}

	// Decode JWT payload (second segment)
	segs := strings.Split(token, ".")
	if len(segs) < 2 {
		return
	}
	payloadB64 := segs[1]
	// JWT uses base64url without padding; add padding if necessary
	if m := len(payloadB64) % 4; m != 0 {
		payloadB64 += strings.Repeat("=", 4-m)
	}
	data, err := base64.URLEncoding.DecodeString(payloadB64)
	if err != nil {
		return
	}
	var payload map[string]interface{}
	if err := json.Unmarshal(data, &payload); err != nil {
		return
	}
	// Expect sub like: system:serviceaccount:<namespace>:<sa-name>
	sub, _ := payload["sub"].(string)
	const prefix = "system:serviceaccount:"
	if !strings.HasPrefix(sub, prefix) {
		return
	}
	rest := strings.TrimPrefix(sub, prefix)
	parts2 := strings.SplitN(rest, ":", 2)
	if len(parts2) != 2 {
		return
	}
	ns := parts2[0]
	saName := parts2[1]

	// Backend client must exist
	if K8sClientMw == nil {
		return
	}

	// Ensure the SA is an Ambient access key (label check) before writing
	saObj, err := K8sClientMw.CoreV1().ServiceAccounts(ns).Get(c.Request.Context(), saName, v1.GetOptions{})
	if err != nil {
		return
	}
	if saObj.Labels == nil || saObj.Labels["app"] != "ambient-access-key" {
		return
	}

	// Patch the annotation
	now := time.Now().Format(time.RFC3339)
	patch := map[string]interface{}{
		"metadata": map[string]interface{}{
			"annotations": map[string]string{
				"ambient-code.io/last-used-at": now,
			},
		},
	}
	b, err := json.Marshal(patch)
	if err != nil {
		return
	}
	_, err = K8sClientMw.CoreV1().ServiceAccounts(ns).Patch(c.Request.Context(), saName, types.MergePatchType, b, v1.PatchOptions{})
	if err != nil && !errors.IsNotFound(err) {
		log.Printf("Failed to update last-used annotation for SA %s/%s: %v", ns, saName, err)
	}
}

// ExtractServiceAccountFromAuth extracts namespace and ServiceAccount name from the Authorization Bearer JWT 'sub' claim
// Returns (namespace, saName, true) when a SA subject is present, otherwise ("","",false)
func ExtractServiceAccountFromAuth(c *gin.Context) (string, string, bool) {
	rawAuth := c.GetHeader("Authorization")
	parts := strings.SplitN(rawAuth, " ", 2)
	if len(parts) != 2 || !strings.EqualFold(parts[0], "Bearer") {
		return "", "", false
	}
	token := strings.TrimSpace(parts[1])
	if token == "" {
		return "", "", false
	}
	segs := strings.Split(token, ".")
	if len(segs) < 2 {
		return "", "", false
	}
	payloadB64 := segs[1]
	if m := len(payloadB64) % 4; m != 0 {
		payloadB64 += strings.Repeat("=", 4-m)
	}
	data, err := base64.URLEncoding.DecodeString(payloadB64)
	if err != nil {
		return "", "", false
	}
	var payload map[string]interface{}
	if err := json.Unmarshal(data, &payload); err != nil {
		return "", "", false
	}
	sub, _ := payload["sub"].(string)
	const prefix = "system:serviceaccount:"
	if !strings.HasPrefix(sub, prefix) {
		return "", "", false
	}
	rest := strings.TrimPrefix(sub, prefix)
	parts2 := strings.SplitN(rest, ":", 2)
	if len(parts2) != 2 {
		return "", "", false
	}
	return parts2[0], parts2[1], true
}

// ValidateProjectContext is middleware for project context validation
func ValidateProjectContext() gin.HandlerFunc {
	return func(c *gin.Context) {
		// Allow token via query parameter for websocket/agent callers
		if c.GetHeader("Authorization") == "" && c.GetHeader("X-Forwarded-Access-Token") == "" {
			if qp := strings.TrimSpace(c.Query("token")); qp != "" {
				c.Request.Header.Set("Authorization", "Bearer "+qp)
			}
		}
		// Require user/API key token; do not fall back to service account
		if c.GetHeader("Authorization") == "" && c.GetHeader("X-Forwarded-Access-Token") == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "User token required"})
			c.Abort()
			return
		}
		reqK8s, _ := GetK8sClientsForRequest(c)
		if reqK8s == nil {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid or missing token"})
			c.Abort()
			return
		}
		// Prefer project from route param; fallback to header for backward compatibility
		projectHeader := c.Param("projectName")
		if projectHeader == "" {
			projectHeader = c.GetHeader("X-OpenShift-Project")
		}
		if projectHeader == "" {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Project is required in path /api/projects/:projectName or X-OpenShift-Project header"})
			c.Abort()
			return
		}

		// Ensure the caller has at least list permission on agenticsessions in the namespace
		ssar := &authv1.SelfSubjectAccessReview{
			Spec: authv1.SelfSubjectAccessReviewSpec{
				ResourceAttributes: &authv1.ResourceAttributes{
					Group:     "vteam.ambient-code",
					Resource:  "agenticsessions",
					Verb:      "list",
					Namespace: projectHeader,
				},
			},
		}
		res, err := reqK8s.AuthorizationV1().SelfSubjectAccessReviews().Create(c.Request.Context(), ssar, v1.CreateOptions{})
		if err != nil {
			log.Printf("validateProjectContext: SSAR failed for %s: %v", projectHeader, err)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to perform access review"})
			c.Abort()
			return
		}
		if !res.Status.Allowed {
			c.JSON(http.StatusForbidden, gin.H{"error": "Unauthorized to access project"})
			c.Abort()
			return
		}

		// Store project in context for handlers
		c.Set("project", projectHeader)
		c.Next()
	}
}
</file>

<file path="components/backend/server/k8s.go">
package server

import (
	"fmt"
	"os"

	"k8s.io/client-go/dynamic"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
)

var (
	K8sClient      *kubernetes.Clientset
	DynamicClient  dynamic.Interface
	Namespace      string
	StateBaseDir   string
	PvcBaseDir     string
	BaseKubeConfig *rest.Config
)

// InitK8sClients initializes Kubernetes clients and configuration
func InitK8sClients() error {
	var config *rest.Config
	var err error

	// Try in-cluster config first
	if config, err = rest.InClusterConfig(); err != nil {
		// If in-cluster config fails, try kubeconfig
		kubeconfig := os.Getenv("KUBECONFIG")
		if kubeconfig == "" {
			kubeconfig = fmt.Sprintf("%s/.kube/config", os.Getenv("HOME"))
		}

		if config, err = clientcmd.BuildConfigFromFlags("", kubeconfig); err != nil {
			return fmt.Errorf("failed to create Kubernetes config: %v", err)
		}
	}

	// Create standard Kubernetes client
	K8sClient, err = kubernetes.NewForConfig(config)
	if err != nil {
		return fmt.Errorf("failed to create Kubernetes client: %v", err)
	}

	// Create dynamic client for CRD operations
	DynamicClient, err = dynamic.NewForConfig(config)
	if err != nil {
		return fmt.Errorf("failed to create dynamic client: %v", err)
	}

	// Save base config for per-request impersonation/user-token clients
	BaseKubeConfig = config

	return nil
}

// InitConfig initializes configuration from environment variables
func InitConfig() {
	// Get namespace from environment or use default
	Namespace = os.Getenv("NAMESPACE")
	if Namespace == "" {
		Namespace = "default"
	}

	// Get state storage base directory
	StateBaseDir = os.Getenv("STATE_BASE_DIR")
	if StateBaseDir == "" {
		StateBaseDir = "/workspace"
	}

	// Get PVC base directory for RFE workspaces
	PvcBaseDir = os.Getenv("PVC_BASE_DIR")
	if PvcBaseDir == "" {
		PvcBaseDir = "/workspace"
	}
}
</file>

<file path="components/backend/.env.example">
# vTeam Backend - .env.example
# Copy this file to .env and adjust values as needed.

########################################
# Server & Runtime
########################################
# HTTP port for the backend server (default: 8080)
PORT=8080

# Kubernetes namespace the backend should consider as default (used for logs/metrics and fallbacks)
NAMESPACE=default

# Local state storage base directory (used for persisting minimal session state)
STATE_BASE_DIR=/data/state

# Base path where RFE workspace files are mounted (PVC)
PVC_BASE_DIR=/workspace

# Path to kubeconfig for out-of-cluster development. Leave empty for in-cluster.
# Example: /Users/you/.kube/config
KUBECONFIG=

########################################
# GitHub App Integration
########################################
# If set, enables GitHub App flows. If empty, GitHub App features are disabled.
GITHUB_APP_ID=

# Path to the GitHub App private key PEM file (default used in container image)
GITHUB_APP_PRIVATE_KEY_PATH=/etc/github-app/private-key.pem

########################################
# Runner / Jobs
########################################
# Optional: Explicit WebSocket URL for runners to connect back to the backend.
# If empty, a URL is constructed using BACKEND_SERVICE and project/session info.
BACKEND_WS_BASE=

# Kubernetes Service DNS name for the backend (used to build default WS URL for runners)
BACKEND_SERVICE=ambient-code-backend

# Container image for the runner job (required to launch sessions)
# Example: ghcr.io/your-org/runner-shell:latest
RUNNER_IMAGE=

########################################
# Spec Kit bootstrap (workspace initialization)
########################################
# Version tag of Spec Kit to download when initializing a workspace
SPEC_KIT_VERSION=v0.0.50

# Template name prefix used to construct the Spec Kit asset URL
SPEC_KIT_TEMPLATE_NAME=spec-kit-template-claude-sh
</file>

<file path="components/backend/.gitignore">
# Go build outputs
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary, built with `go test -c`
*.test

# Output of the go coverage tool, specifically when used with LiteIDE
*.out

# Go workspace file
go.work
go.work.sum

# Dependency directories  
vendor/


# Binary output
backend
main

# Profiling files
*.prof
*.cpu
*.mem

# Air live reload tool
tmp/

# Gin debug logs
gin-bin
gin.log

# Debug logs
debug.log

# Coverage reports
coverage.html
coverage.out

ambient-code-backend

.env
private-key.pem
</file>

<file path="components/backend/Dockerfile.dev">
# Development Dockerfile for Go backend (simplified, no Air)
FROM golang:1.24-alpine

WORKDIR /app

# Install git and build dependencies
RUN apk add --no-cache git build-base

# Set environment variables  
ENV AGENTS_DIR=/app/agents
ENV CGO_ENABLED=0
ENV GOOS=linux

# Expose port
EXPOSE 8080

# Simple development mode - just run the Go app directly
# Note: Source code will be mounted as volume at runtime
CMD ["sh", "-c", "while [ ! -f main.go ]; do echo 'Waiting for source sync...'; sleep 2; done && go run ."]
</file>

<file path="components/backend/Makefile">
# Makefile for ambient-code-backend

.PHONY: help build test test-unit test-contract test-integration clean run docker-build docker-run

# Default target
help: ## Show this help message
	@echo "Available targets:"
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "  %-20s %s\n", $$1, $$2}'

# Build targets
build: ## Build the backend binary
	go build -o backend .

clean: ## Clean build artifacts
	rm -f backend main
	go clean

# Test targets
test: test-unit test-contract ## Run all tests (excluding integration tests)

test-unit: ## Run unit tests
	go test ./tests/unit/... -v

test-contract: ## Run contract tests
	go test ./tests/contract/... -v

test-integration: ## Run integration tests (requires Kubernetes cluster)
	@echo "Running integration tests (requires Kubernetes cluster access)..."
	go test ./tests/integration/... -v -timeout=5m

test-integration-short: ## Run integration tests with short timeout
	go test ./tests/integration/... -v -short

test-all: test test-integration ## Run all tests including integration tests

# Test with specific configuration
test-integration-local: ## Run integration tests with local configuration
	@echo "Running integration tests with local configuration..."
	TEST_NAMESPACE=ambient-code-test \
	CLEANUP_RESOURCES=true \
	go test ./tests/integration/... -v -timeout=5m

test-integration-ci: ## Run integration tests for CI (no cleanup for debugging)
	@echo "Running integration tests for CI..."
	TEST_NAMESPACE=ambient-code-ci \
	CLEANUP_RESOURCES=false \
	go test ./tests/integration/... -v -timeout=10m -json

test-permissions: ## Run permission and RBAC integration tests specifically
	@echo "Running permission boundary and RBAC tests..."
	TEST_NAMESPACE=ambient-code-test \
	CLEANUP_RESOURCES=true \
	go test ./tests/integration/ -v -run TestPermission -timeout=5m

test-permissions-verbose: ## Run permission tests with detailed output
	@echo "Running permission tests with verbose output..."
	TEST_NAMESPACE=ambient-code-test \
	CLEANUP_RESOURCES=true \
	go test ./tests/integration/ -v -run TestPermission -timeout=5m -count=1

# Coverage targets
test-coverage: ## Run tests with coverage
	go test ./tests/unit/... ./tests/contract/... -coverprofile=coverage.out
	go tool cover -html=coverage.out -o coverage.html
	@echo "Coverage report generated: coverage.html"

# Development targets
run: ## Run the backend server locally
	go run .

dev: ## Run with live reload (requires air: go install github.com/cosmtrek/air@latest)
	air

# Docker targets
docker-build: ## Build Docker image
	docker build -t ambient-code-backend .

docker-run: ## Run Docker container
	docker run -p 8080:8080 ambient-code-backend

# Linting and formatting
fmt: ## Format Go code
	go fmt ./...

vet: ## Run go vet
	go vet ./...

lint: ## Run golangci-lint (requires golangci-lint to be installed)
	golangci-lint run

# Dependency management
deps: ## Download dependencies
	go mod download

deps-update: ## Update dependencies
	go get -u ./...
	go mod tidy

deps-verify: ## Verify dependencies
	go mod verify

# Installation targets for development tools
install-tools: ## Install development tools
	@echo "Installing development tools..."
	go install github.com/cosmtrek/air@latest
	go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest

# Kubernetes-specific targets for integration testing
k8s-setup: ## Setup local Kubernetes for testing (requires kubectl and kind)
	@echo "Setting up local Kubernetes cluster for testing..."
	kind create cluster --name ambient-test || true
	kubectl config use-context kind-ambient-test
	@echo "Installing test CRDs..."
	kubectl apply -f ../manifests/crds/ || echo "Warning: Could not install CRDs"

k8s-teardown: ## Teardown local Kubernetes test cluster
	@echo "Tearing down test cluster..."
	kind delete cluster --name ambient-test || true

# Pre-commit hooks
pre-commit: fmt vet test ## Run pre-commit checks

# Build information
version: ## Show version information
	@echo "Go version: $(shell go version)"
	@echo "Git commit: $(shell git rev-parse --short HEAD 2>/dev/null || echo 'unknown')"
	@echo "Build time: $(shell date)"

# Environment validation
check-env: ## Check environment setup for development
	@echo "Checking environment..."
	@go version >/dev/null 2>&1 || (echo "❌ Go not installed"; exit 1)
	@echo "✅ Go installed: $(shell go version)"
	@kubectl version --client >/dev/null 2>&1 || echo "⚠️  kubectl not found (needed for integration tests)"
	@docker version >/dev/null 2>&1 || echo "⚠️  Docker not found (needed for container builds)"
	@echo "Environment check complete"
</file>

<file path="components/backend/github/app.go">
// Package github implements GitHub App authentication and API integration.
package github

import (
	"context"
	"fmt"
	"time"

	"ambient-code-backend/handlers"
)

// Package-level variable for token manager
var (
	Manager *TokenManager
)

// InitializeTokenManager initializes the GitHub token manager after envs are loaded
func InitializeTokenManager() {
	var err error
	Manager, err = NewTokenManager()
	if err != nil {
		// Log error but don't fail - GitHub App might not be configured
		fmt.Printf("Warning: GitHub App not configured: %v\n", err)
	}
}

// GetInstallation retrieves GitHub App installation for a user (wrapper to handlers package)
func GetInstallation(ctx context.Context, userID string) (*handlers.GitHubAppInstallation, error) {
	return handlers.GetGitHubInstallation(ctx, userID)
}

// MintSessionToken creates a GitHub access token for a session
// Returns the token and expiry time to be injected as a Kubernetes Secret
func MintSessionToken(ctx context.Context, userID string) (string, time.Time, error) {
	if Manager == nil {
		return "", time.Time{}, fmt.Errorf("GitHub App not configured")
	}

	// Get user's GitHub installation
	installation, err := GetInstallation(ctx, userID)
	if err != nil {
		return "", time.Time{}, fmt.Errorf("failed to get GitHub installation: %w", err)
	}

	// Mint short-lived token for the installation's host
	token, expiresAt, err := Manager.MintInstallationTokenForHost(ctx, installation.InstallationID, installation.Host)
	if err != nil {
		return "", time.Time{}, fmt.Errorf("failed to mint installation token: %w", err)
	}

	return token, expiresAt, nil
}
</file>

<file path="components/backend/github/token.go">
package github

import (
	"bytes"
	"context"
	"crypto/rsa"
	"crypto/x509"
	"encoding/base64"
	"encoding/json"
	"encoding/pem"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/golang-jwt/jwt/v5"
)

// TokenManager manages GitHub App installation tokens
type TokenManager struct {
	AppID      string
	PrivateKey *rsa.PrivateKey
	cacheMu    *sync.Mutex
	cache      map[int64]cachedInstallationToken
}

type cachedInstallationToken struct {
	token     string
	expiresAt time.Time
}

// NewTokenManager creates a new token manager
func NewTokenManager() (*TokenManager, error) {
	appID := os.Getenv("GITHUB_APP_ID")
	if appID == "" {
		// Return nil if GitHub App is not configured
		return nil, nil
	}

	// Require private key via env var GITHUB_PRIVATE_KEY (raw PEM or base64-encoded)
	raw := strings.TrimSpace(os.Getenv("GITHUB_PRIVATE_KEY"))
	if raw == "" {
		return nil, fmt.Errorf("GITHUB_PRIVATE_KEY not set")
	}
	// Support both raw PEM and base64-encoded PEM
	pemBytes := []byte(raw)
	if !strings.Contains(raw, "-----BEGIN") {
		decoded, decErr := base64.StdEncoding.DecodeString(raw)
		if decErr != nil {
			return nil, fmt.Errorf("failed to base64-decode GITHUB_PRIVATE_KEY: %w", decErr)
		}
		pemBytes = decoded
	}
	privateKey, perr := parsePrivateKeyPEM(pemBytes)
	if perr != nil {
		return nil, fmt.Errorf("failed to parse GITHUB_PRIVATE_KEY: %w", perr)
	}

	return &TokenManager{
		AppID:      appID,
		PrivateKey: privateKey,
		cacheMu:    &sync.Mutex{},
		cache:      map[int64]cachedInstallationToken{},
	}, nil
}

// loadPrivateKey loads the RSA private key from a PEM file
func parsePrivateKeyPEM(keyData []byte) (*rsa.PrivateKey, error) {
	block, _ := pem.Decode(keyData)
	if block == nil {
		return nil, fmt.Errorf("failed to decode PEM block")
	}

	key, err := x509.ParsePKCS1PrivateKey(block.Bytes)
	if err != nil {
		// Try PKCS8 format
		keyInterface, err := x509.ParsePKCS8PrivateKey(block.Bytes)
		if err != nil {
			return nil, fmt.Errorf("failed to parse private key: %w", err)
		}
		var ok bool
		key, ok = keyInterface.(*rsa.PrivateKey)
		if !ok {
			return nil, fmt.Errorf("not an RSA private key")
		}
	}

	return key, nil
}

// GenerateJWT generates a JWT for GitHub App authentication
func (m *TokenManager) GenerateJWT() (string, error) {
	now := time.Now()
	claims := jwt.MapClaims{
		"iat": now.Unix(),
		"exp": now.Add(10 * time.Minute).Unix(),
		"iss": m.AppID,
	}

	token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
	return token.SignedString(m.PrivateKey)
}

// MintInstallationToken creates a short-lived installation access token
func (m *TokenManager) MintInstallationToken(ctx context.Context, installationID int64) (string, time.Time, error) {
	if m == nil {
		return "", time.Time{}, fmt.Errorf("GitHub App not configured")
	}
	return m.MintInstallationTokenForHost(ctx, installationID, "github.com")
}

// MintInstallationTokenForHost mints an installation token against the specified GitHub API host
func (m *TokenManager) MintInstallationTokenForHost(ctx context.Context, installationID int64, host string) (string, time.Time, error) {
	if m == nil {
		return "", time.Time{}, fmt.Errorf("GitHub App not configured")
	}
	// Serve from cache if still valid (>3 minutes left)
	m.cacheMu.Lock()
	if entry, ok := m.cache[installationID]; ok {
		if time.Until(entry.expiresAt) > 3*time.Minute {
			token := entry.token
			exp := entry.expiresAt
			m.cacheMu.Unlock()
			return token, exp, nil
		}
	}
	m.cacheMu.Unlock()

	jwtToken, err := m.GenerateJWT()
	if err != nil {
		return "", time.Time{}, fmt.Errorf("failed to generate JWT: %w", err)
	}

	apiBase := APIBaseURL(host)
	url := fmt.Sprintf("%s/app/installations/%d/access_tokens", apiBase, installationID)
	reqBody := bytes.NewBuffer([]byte("{}"))
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, reqBody)
	if err != nil {
		return "", time.Time{}, fmt.Errorf("failed to create request: %w", err)
	}
	req.Header.Set("Accept", "application/vnd.github+json")
	req.Header.Set("Authorization", "Bearer "+jwtToken)
	req.Header.Set("X-GitHub-Api-Version", "2022-11-28")
	req.Header.Set("User-Agent", "vTeam-Backend")

	client := &http.Client{Timeout: 15 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return "", time.Time{}, fmt.Errorf("failed to call GitHub: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		body, _ := io.ReadAll(resp.Body)
		return "", time.Time{}, fmt.Errorf("GitHub token mint failed: %s", string(body))
	}
	var parsed struct {
		Token     string    `json:"token"`
		ExpiresAt time.Time `json:"expires_at"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&parsed); err != nil {
		return "", time.Time{}, fmt.Errorf("failed to parse token response: %w", err)
	}
	m.cacheMu.Lock()
	m.cache[installationID] = cachedInstallationToken{token: parsed.Token, expiresAt: parsed.ExpiresAt}
	m.cacheMu.Unlock()
	return parsed.Token, parsed.ExpiresAt, nil
}

// ValidateInstallationAccess checks if the installation has access to a repository
func (m *TokenManager) ValidateInstallationAccess(ctx context.Context, installationID int64, repo string) error {
	if m == nil {
		return fmt.Errorf("GitHub App not configured")
	}
	// Mint installation token (default host github.com)
	token, _, err := m.MintInstallationTokenForHost(ctx, installationID, "github.com")
	if err != nil {
		return fmt.Errorf("failed to mint installation token: %w", err)
	}

	// repo should be in form "owner/repo"; tolerate full URL and trim
	ownerRepo := repo
	if strings.HasPrefix(ownerRepo, "http://") || strings.HasPrefix(ownerRepo, "https://") {
		// Trim protocol and host
		// Examples: https://github.com/owner/repo(.git)?
		// Split by "/" and take last two segments
		parts := strings.Split(strings.TrimSuffix(ownerRepo, ".git"), "/")
		if len(parts) >= 2 {
			ownerRepo = parts[len(parts)-2] + "/" + parts[len(parts)-1]
		}
	}
	parts := strings.Split(ownerRepo, "/")
	if len(parts) != 2 {
		return fmt.Errorf("invalid repo format: expected owner/repo")
	}
	owner := parts[0]
	name := parts[1]

	apiBase := APIBaseURL("github.com")
	url := fmt.Sprintf("%s/repos/%s/%s", apiBase, owner, name)
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	req.Header.Set("Accept", "application/vnd.github+json")
	req.Header.Set("Authorization", "token "+token)
	req.Header.Set("X-GitHub-Api-Version", "2022-11-28")
	req.Header.Set("User-Agent", "vTeam-Backend")

	client := &http.Client{Timeout: 15 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return fmt.Errorf("GitHub request failed: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode == http.StatusNotFound {
		return fmt.Errorf("installation does not have access to repository or repo not found")
	}
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		body, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("unexpected GitHub response: %s", string(body))
	}
	return nil
}

// APIBaseURL returns the GitHub API base URL for the given host
func APIBaseURL(host string) string {
	if host == "" || host == "github.com" {
		return "https://api.github.com"
	}
	return fmt.Sprintf("https://%s/api/v3", host)
}
</file>

<file path="components/backend/handlers/permissions.go">
package handlers

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	authnv1 "k8s.io/api/authentication/v1"
	corev1 "k8s.io/api/core/v1"
	rbacv1 "k8s.io/api/rbac/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// Role constants for Ambient RBAC
const (
	AmbientRoleAdmin = "ambient-project-admin"
	AmbientRoleEdit  = "ambient-project-edit"
	AmbientRoleView  = "ambient-project-view"
)

// sanitizeName converts input to a Kubernetes-safe name (lowercase alphanumeric with dashes, max 63 chars)
func sanitizeName(input string) string {
	s := strings.ToLower(input)
	var b strings.Builder
	prevDash := false
	for _, r := range s {
		if (r >= 'a' && r <= 'z') || (r >= '0' && r <= '9') {
			b.WriteRune(r)
			prevDash = false
		} else {
			if !prevDash {
				b.WriteByte('-')
				prevDash = true
			}
		}
		if b.Len() >= 63 {
			break
		}
	}
	out := b.String()
	out = strings.Trim(out, "-")
	if out == "" {
		out = "group"
	}
	return out
}

// PermissionAssignment represents a user or group permission
type PermissionAssignment struct {
	SubjectType string `json:"subjectType"`
	SubjectName string `json:"subjectName"`
	Role        string `json:"role"`
}

// ListProjectPermissions handles GET /api/projects/:projectName/permissions
func ListProjectPermissions(c *gin.Context) {
	projectName := c.Param("projectName")
	reqK8s, _ := GetK8sClientsForRequest(c)

	// Prefer new label, but also include legacy group-access for backward-compat listing
	rbsAll, err := reqK8s.RbacV1().RoleBindings(projectName).List(context.TODO(), v1.ListOptions{})
	if err != nil {
		log.Printf("Failed to list RoleBindings in %s: %v", projectName, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list permissions"})
		return
	}

	validRoles := map[string]string{
		AmbientRoleAdmin: "admin",
		AmbientRoleEdit:  "edit",
		AmbientRoleView:  "view",
	}

	type key struct{ kind, name, role string }
	seen := map[key]struct{}{}
	assignments := []PermissionAssignment{}

	for _, rb := range rbsAll.Items {
		// Filter to Ambient-managed permission rolebindings
		if rb.Labels["app"] != "ambient-permission" && rb.Labels["app"] != "ambient-group-access" {
			continue
		}

		// Determine role from RoleRef or annotation
		role := ""
		if r, ok := validRoles[rb.RoleRef.Name]; ok && rb.RoleRef.Kind == "ClusterRole" {
			role = r
		}
		if annRole := rb.Annotations["ambient-code.io/role"]; annRole != "" {
			role = strings.ToLower(annRole)
		}
		if role == "" {
			continue
		}

		for _, sub := range rb.Subjects {
			if !strings.EqualFold(sub.Kind, "Group") && !strings.EqualFold(sub.Kind, "User") {
				continue
			}
			subjectType := "group"
			if strings.EqualFold(sub.Kind, "User") {
				subjectType = "user"
			}
			subjectName := sub.Name
			if v := rb.Annotations["ambient-code.io/subject-name"]; v != "" {
				subjectName = v
			}
			if v := rb.Annotations["ambient-code.io/groupName"]; v != "" && subjectType == "group" {
				subjectName = v
			}

			k := key{kind: subjectType, name: subjectName, role: role}
			if _, exists := seen[k]; exists {
				continue
			}
			seen[k] = struct{}{}
			assignments = append(assignments, PermissionAssignment{SubjectType: subjectType, SubjectName: subjectName, Role: role})
		}
	}

	c.JSON(http.StatusOK, gin.H{"items": assignments})
}

// AddProjectPermission handles POST /api/projects/:projectName/permissions
func AddProjectPermission(c *gin.Context) {
	projectName := c.Param("projectName")
	reqK8s, _ := GetK8sClientsForRequest(c)

	var req struct {
		SubjectType string `json:"subjectType" binding:"required"`
		SubjectName string `json:"subjectName" binding:"required"`
		Role        string `json:"role" binding:"required"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	st := strings.ToLower(strings.TrimSpace(req.SubjectType))
	if st != "group" && st != "user" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "subjectType must be one of: group, user"})
		return
	}
	subjectKind := "Group"
	if st == "user" {
		subjectKind = "User"
	}

	roleRefName := ""
	switch strings.ToLower(req.Role) {
	case "admin":
		roleRefName = AmbientRoleAdmin
	case "edit":
		roleRefName = AmbientRoleEdit
	case "view":
		roleRefName = AmbientRoleView
	default:
		c.JSON(http.StatusBadRequest, gin.H{"error": "role must be one of: admin, edit, view"})
		return
	}

	rbName := "ambient-permission-" + strings.ToLower(req.Role) + "-" + sanitizeName(req.SubjectName) + "-" + st
	rb := &rbacv1.RoleBinding{
		ObjectMeta: v1.ObjectMeta{
			Name:      rbName,
			Namespace: projectName,
			Labels: map[string]string{
				"app": "ambient-permission",
			},
			Annotations: map[string]string{
				"ambient-code.io/subject-kind": subjectKind,
				"ambient-code.io/subject-name": req.SubjectName,
				"ambient-code.io/role":         strings.ToLower(req.Role),
			},
		},
		RoleRef:  rbacv1.RoleRef{APIGroup: "rbac.authorization.k8s.io", Kind: "ClusterRole", Name: roleRefName},
		Subjects: []rbacv1.Subject{{Kind: subjectKind, APIGroup: "rbac.authorization.k8s.io", Name: req.SubjectName}},
	}

	if _, err := reqK8s.RbacV1().RoleBindings(projectName).Create(context.TODO(), rb, v1.CreateOptions{}); err != nil {
		if errors.IsAlreadyExists(err) {
			c.JSON(http.StatusConflict, gin.H{"error": "permission already exists for this subject and role"})
			return
		}
		log.Printf("Failed to create RoleBinding in %s for %s %s: %v", projectName, st, req.SubjectName, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to grant permission"})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"message": "permission added"})
}

// RemoveProjectPermission handles DELETE /api/projects/:projectName/permissions/:subjectType/:subjectName
func RemoveProjectPermission(c *gin.Context) {
	projectName := c.Param("projectName")
	subjectType := strings.ToLower(c.Param("subjectType"))
	subjectName := c.Param("subjectName")
	reqK8s, _ := GetK8sClientsForRequest(c)

	if subjectType != "group" && subjectType != "user" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "subjectType must be one of: group, user"})
		return
	}
	if strings.TrimSpace(subjectName) == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "subjectName is required"})
		return
	}

	rbs, err := reqK8s.RbacV1().RoleBindings(projectName).List(context.TODO(), v1.ListOptions{LabelSelector: "app=ambient-permission"})
	if err != nil {
		log.Printf("Failed to list RoleBindings in %s: %v", projectName, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to remove permission"})
		return
	}

	for _, rb := range rbs.Items {
		for _, sub := range rb.Subjects {
			if strings.EqualFold(sub.Kind, "Group") && subjectType == "group" && sub.Name == subjectName {
				_ = reqK8s.RbacV1().RoleBindings(projectName).Delete(context.TODO(), rb.Name, v1.DeleteOptions{})
				break
			}
			if strings.EqualFold(sub.Kind, "User") && subjectType == "user" && sub.Name == subjectName {
				_ = reqK8s.RbacV1().RoleBindings(projectName).Delete(context.TODO(), rb.Name, v1.DeleteOptions{})
				break
			}
		}
	}

	c.Status(http.StatusNoContent)
}

// ListProjectKeys handles GET /api/projects/:projectName/keys
// Lists access keys (ServiceAccounts with label app=ambient-access-key)
func ListProjectKeys(c *gin.Context) {
	projectName := c.Param("projectName")
	reqK8s, _ := GetK8sClientsForRequest(c)

	// List ServiceAccounts with label app=ambient-access-key
	sas, err := reqK8s.CoreV1().ServiceAccounts(projectName).List(context.TODO(), v1.ListOptions{LabelSelector: "app=ambient-access-key"})
	if err != nil {
		log.Printf("Failed to list access keys in %s: %v", projectName, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list access keys"})
		return
	}

	// Map ServiceAccount -> role by scanning RoleBindings with the same label
	roleBySA := map[string]string{}
	if rbs, err := reqK8s.RbacV1().RoleBindings(projectName).List(context.TODO(), v1.ListOptions{LabelSelector: "app=ambient-access-key"}); err == nil {
		for _, rb := range rbs.Items {
			role := strings.ToLower(rb.Annotations["ambient-code.io/role"])
			if role == "" {
				switch rb.RoleRef.Name {
				case AmbientRoleAdmin:
					role = "admin"
				case AmbientRoleEdit:
					role = "edit"
				case AmbientRoleView:
					role = "view"
				}
			}
			for _, sub := range rb.Subjects {
				if strings.EqualFold(sub.Kind, "ServiceAccount") {
					roleBySA[sub.Name] = role
				}
			}
		}
	}

	type KeyInfo struct {
		ID          string `json:"id"`
		Name        string `json:"name"`
		CreatedAt   string `json:"createdAt"`
		LastUsedAt  string `json:"lastUsedAt"`
		Description string `json:"description,omitempty"`
		Role        string `json:"role,omitempty"`
	}

	items := []KeyInfo{}
	for _, sa := range sas.Items {
		ki := KeyInfo{ID: sa.Name, Name: sa.Annotations["ambient-code.io/key-name"], Description: sa.Annotations["ambient-code.io/description"], Role: roleBySA[sa.Name]}
		if t := sa.CreationTimestamp; !t.IsZero() {
			ki.CreatedAt = t.Format(time.RFC3339)
		}
		if lu := sa.Annotations["ambient-code.io/last-used-at"]; lu != "" {
			ki.LastUsedAt = lu
		}
		items = append(items, ki)
	}
	c.JSON(http.StatusOK, gin.H{"items": items})
}

// CreateProjectKey handles POST /api/projects/:projectName/keys
// Creates a new access key (ServiceAccount with token and RoleBinding)
func CreateProjectKey(c *gin.Context) {
	projectName := c.Param("projectName")
	reqK8s, _ := GetK8sClientsForRequest(c)

	var req struct {
		Name        string `json:"name" binding:"required"`
		Description string `json:"description"`
		Role        string `json:"role"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Determine role to bind; default edit
	role := strings.ToLower(strings.TrimSpace(req.Role))
	if role == "" {
		role = "edit"
	}
	var roleRefName string
	switch role {
	case "admin":
		roleRefName = AmbientRoleAdmin
	case "edit":
		roleRefName = AmbientRoleEdit
	case "view":
		roleRefName = AmbientRoleView
	default:
		c.JSON(http.StatusBadRequest, gin.H{"error": "role must be one of: admin, edit, view"})
		return
	}

	// Create a dedicated ServiceAccount per key
	ts := time.Now().Unix()
	saName := fmt.Sprintf("ambient-key-%s-%d", sanitizeName(req.Name), ts)
	sa := &corev1.ServiceAccount{
		ObjectMeta: v1.ObjectMeta{
			Name:      saName,
			Namespace: projectName,
			Labels:    map[string]string{"app": "ambient-access-key"},
			Annotations: map[string]string{
				"ambient-code.io/key-name":    req.Name,
				"ambient-code.io/description": req.Description,
				"ambient-code.io/created-at":  time.Now().Format(time.RFC3339),
				"ambient-code.io/role":        role,
			},
		},
	}
	if _, err := reqK8s.CoreV1().ServiceAccounts(projectName).Create(context.TODO(), sa, v1.CreateOptions{}); err != nil && !errors.IsAlreadyExists(err) {
		log.Printf("Failed to create ServiceAccount %s in %s: %v", saName, projectName, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create service account"})
		return
	}

	// Bind the SA to the selected role via RoleBinding
	rbName := fmt.Sprintf("ambient-key-%s-%s-%d", role, sanitizeName(req.Name), ts)
	rb := &rbacv1.RoleBinding{
		ObjectMeta: v1.ObjectMeta{
			Name:      rbName,
			Namespace: projectName,
			Labels:    map[string]string{"app": "ambient-access-key"},
			Annotations: map[string]string{
				"ambient-code.io/key-name": req.Name,
				"ambient-code.io/sa-name":  saName,
				"ambient-code.io/role":     role,
			},
		},
		RoleRef:  rbacv1.RoleRef{APIGroup: "rbac.authorization.k8s.io", Kind: "ClusterRole", Name: roleRefName},
		Subjects: []rbacv1.Subject{{Kind: "ServiceAccount", Name: saName, Namespace: projectName}},
	}
	if _, err := reqK8s.RbacV1().RoleBindings(projectName).Create(context.TODO(), rb, v1.CreateOptions{}); err != nil && !errors.IsAlreadyExists(err) {
		log.Printf("Failed to create RoleBinding %s in %s: %v", rbName, projectName, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to bind service account"})
		return
	}

	// Issue a one-time JWT token for this ServiceAccount (no audience; used as API key)
	tr := &authnv1.TokenRequest{Spec: authnv1.TokenRequestSpec{}}
	tok, err := reqK8s.CoreV1().ServiceAccounts(projectName).CreateToken(context.TODO(), saName, tr, v1.CreateOptions{})
	if err != nil {
		log.Printf("Failed to create token for SA %s/%s: %v", projectName, saName, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate access token"})
		return
	}

	c.JSON(http.StatusCreated, gin.H{
		"id":          saName,
		"name":        req.Name,
		"key":         tok.Status.Token,
		"description": req.Description,
		"role":        role,
		"lastUsedAt":  "",
	})
}

// DeleteProjectKey handles DELETE /api/projects/:projectName/keys/:keyId
// Deletes an access key (ServiceAccount and associated RoleBindings)
func DeleteProjectKey(c *gin.Context) {
	projectName := c.Param("projectName")
	keyID := c.Param("keyId")
	reqK8s, _ := GetK8sClientsForRequest(c)

	// Delete associated RoleBindings
	rbs, _ := reqK8s.RbacV1().RoleBindings(projectName).List(context.TODO(), v1.ListOptions{LabelSelector: "app=ambient-access-key"})
	for _, rb := range rbs.Items {
		if rb.Annotations["ambient-code.io/sa-name"] == keyID {
			_ = reqK8s.RbacV1().RoleBindings(projectName).Delete(context.TODO(), rb.Name, v1.DeleteOptions{})
		}
	}

	// Delete the ServiceAccount itself
	if err := reqK8s.CoreV1().ServiceAccounts(projectName).Delete(context.TODO(), keyID, v1.DeleteOptions{}); err != nil {
		if !errors.IsNotFound(err) {
			log.Printf("Failed to delete service account %s in %s: %v", keyID, projectName, err)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete access key"})
			return
		}
	}

	c.Status(http.StatusNoContent)
}
</file>

<file path="components/backend/server/server.go">
// Package server provides HTTP server setup, middleware, and routing configuration.
package server

import (
	"fmt"
	"log"
	"net/http"
	"os"
	"strings"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
)

// RouterFunc is a function that can register routes on a Gin router
type RouterFunc func(r *gin.Engine)

// Run starts the server with the provided route registration function
func Run(registerRoutes RouterFunc) error {
	// Setup Gin router with custom logger that redacts tokens
	r := gin.New()
	r.Use(gin.Recovery())
	r.Use(gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string {
		// Redact token from query string
		path := param.Path
		if strings.Contains(param.Request.URL.RawQuery, "token=") {
			path = strings.Split(path, "?")[0] + "?token=[REDACTED]"
		}
		return fmt.Sprintf("[GIN] %s | %3d | %s | %s\n",
			param.Method,
			param.StatusCode,
			param.ClientIP,
			path,
		)
	}))

	// Middleware to populate user context from forwarded headers
	r.Use(forwardedIdentityMiddleware())

	// Configure CORS
	config := cors.DefaultConfig()
	config.AllowAllOrigins = true
	config.AllowMethods = []string{"GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS"}
	config.AllowHeaders = []string{"Origin", "Content-Length", "Content-Type", "Authorization"}
	r.Use(cors.New(config))

	// Register routes
	registerRoutes(r)

	// Get port from environment
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}

	log.Printf("Server starting on port %s", port)
	log.Printf("Using namespace: %s", Namespace)

	if err := r.Run(":" + port); err != nil {
		return fmt.Errorf("failed to start server: %v", err)
	}

	return nil
}

// forwardedIdentityMiddleware populates Gin context from common OAuth proxy headers
func forwardedIdentityMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		if v := c.GetHeader("X-Forwarded-User"); v != "" {
			c.Set("userID", v)
		}
		// Prefer preferred username; fallback to user id
		name := c.GetHeader("X-Forwarded-Preferred-Username")
		if name == "" {
			name = c.GetHeader("X-Forwarded-User")
		}
		if name != "" {
			c.Set("userName", name)
		}
		if v := c.GetHeader("X-Forwarded-Email"); v != "" {
			c.Set("userEmail", v)
		}
		if v := c.GetHeader("X-Forwarded-Groups"); v != "" {
			c.Set("userGroups", strings.Split(v, ","))
		}
		// Also expose access token if present
		auth := c.GetHeader("Authorization")
		if auth != "" {
			c.Set("authorizationHeader", auth)
		}
		if v := c.GetHeader("X-Forwarded-Access-Token"); v != "" {
			c.Set("forwardedAccessToken", v)
		}
		c.Next()
	}
}

// RunContentService starts the server in content service mode
func RunContentService(registerContentRoutes RouterFunc) error {
	r := gin.New()
	r.Use(gin.Recovery())
	r.Use(gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string {
		path := param.Path
		if strings.Contains(param.Request.URL.RawQuery, "token=") {
			path = strings.Split(path, "?")[0] + "?token=[REDACTED]"
		}
		return fmt.Sprintf("[GIN] %s | %3d | %s | %s\n",
			param.Method,
			param.StatusCode,
			param.ClientIP,
			path,
		)
	}))

	// Register content service routes
	registerContentRoutes(r)

	// Health check endpoint
	r.GET("/health", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"status": "healthy"})
	})

	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}
	log.Printf("Content service starting on port %s", port)
	if err := r.Run(":" + port); err != nil {
		return fmt.Errorf("failed to start content service: %v", err)
	}
	return nil
}
</file>

<file path="components/backend/Dockerfile">
# Build stage
FROM registry.access.redhat.com/ubi9/go-toolset:1.24 AS builder

WORKDIR /app

USER 0

# Copy go mod and sum files
COPY go.mod go.sum ./

# Download dependencies
RUN go mod download

# Copy the source code
COPY . .

# Build the application (with flags to avoid segfault)
RUN CGO_ENABLED=0 GOOS=linux go build -ldflags="-s -w" -o main .

# Final stage
FROM registry.access.redhat.com/ubi9/ubi-minimal:latest

RUN microdnf install -y git && microdnf clean all
WORKDIR /app

# Copy the binary from builder stage
COPY --from=builder /app/main .

# Default agents directory
ENV AGENTS_DIR=/app/agents

# Set executable permissions and make accessible to any user
RUN chmod +x ./main && chmod 775 /app

USER 1001

# Expose port
EXPOSE 8080

# Command to run the executable
CMD ["./main"]
</file>

<file path="components/backend/go.mod">
module ambient-code-backend

go 1.24.0

toolchain go1.24.7

require (
	github.com/gin-contrib/cors v1.7.6
	github.com/gin-gonic/gin v1.10.1
	github.com/golang-jwt/jwt/v5 v5.3.0
	github.com/gorilla/websocket v1.5.4-0.20250319132907-e064f32e3674
	github.com/joho/godotenv v1.5.1
	k8s.io/api v0.34.0
	k8s.io/apimachinery v0.34.0
	k8s.io/client-go v0.34.0
)

require (
	github.com/bytedance/sonic v1.13.3 // indirect
	github.com/bytedance/sonic/loader v0.2.4 // indirect
	github.com/cloudwego/base64x v0.1.5 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/emicklei/go-restful/v3 v3.12.2 // indirect
	github.com/fxamacker/cbor/v2 v2.9.0 // indirect
	github.com/gabriel-vasile/mimetype v1.4.9 // indirect
	github.com/gin-contrib/sse v1.1.0 // indirect
	github.com/go-logr/logr v1.4.2 // indirect
	github.com/go-openapi/jsonpointer v0.21.0 // indirect
	github.com/go-openapi/jsonreference v0.20.2 // indirect
	github.com/go-openapi/swag v0.23.0 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-playground/validator/v10 v10.26.0 // indirect
	github.com/goccy/go-json v0.10.5 // indirect
	github.com/gogo/protobuf v1.3.2 // indirect
	github.com/google/gnostic-models v0.7.0 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/klauspost/cpuid/v2 v2.2.10 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/mailru/easyjson v0.7.7 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.3-0.20250322232337-35a7c28c31ee // indirect
	github.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822 // indirect
	github.com/pelletier/go-toml/v2 v2.2.4 // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/spf13/pflag v1.0.6 // indirect
	github.com/stretchr/testify v1.11.1 // indirect
	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
	github.com/ugorji/go/codec v1.3.0 // indirect
	github.com/x448/float16 v0.8.4 // indirect
	go.yaml.in/yaml/v2 v2.4.2 // indirect
	go.yaml.in/yaml/v3 v3.0.4 // indirect
	golang.org/x/arch v0.18.0 // indirect
	golang.org/x/crypto v0.39.0 // indirect
	golang.org/x/net v0.41.0 // indirect
	golang.org/x/oauth2 v0.27.0 // indirect
	golang.org/x/sys v0.33.0 // indirect
	golang.org/x/term v0.32.0 // indirect
	golang.org/x/text v0.26.0 // indirect
	golang.org/x/time v0.9.0 // indirect
	google.golang.org/protobuf v1.36.6 // indirect
	gopkg.in/evanphx/json-patch.v4 v4.12.0 // indirect
	gopkg.in/inf.v0 v0.9.1 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
	k8s.io/klog/v2 v2.130.1 // indirect
	k8s.io/kube-openapi v0.0.0-20250710124328-f3f2b991d03b // indirect
	k8s.io/utils v0.0.0-20250604170112-4c0f3b243397 // indirect
	sigs.k8s.io/json v0.0.0-20241014173422-cfa47c3a1cc8 // indirect
	sigs.k8s.io/randfill v1.0.0 // indirect
	sigs.k8s.io/structured-merge-diff/v6 v6.3.0 // indirect
	sigs.k8s.io/yaml v1.6.0 // indirect
)
</file>

<file path="components/backend/README.md">
# Backend API

Go-based REST API for the Ambient Code Platform, managing Kubernetes Custom Resources with multi-tenant project isolation.

## Features

- **Project-scoped endpoints**: `/api/projects/:project/*` for namespaced resources
- **Multi-tenant isolation**: Each project maps to a Kubernetes namespace
- **WebSocket support**: Real-time session updates
- **Git operations**: Repository cloning, forking, PR creation
- **RBAC integration**: OpenShift OAuth for authentication

## Development

### Prerequisites

- Go 1.21+
- kubectl
- Docker or Podman
- Access to Kubernetes cluster (for integration tests)

### Quick Start

```bash
cd components/backend

# Install dependencies
make deps

# Run locally
make run

# Run with hot-reload (requires: go install github.com/cosmtrek/air@latest)
make dev
```

### Build

```bash
# Build binary
make build

# Build container image
make build CONTAINER_ENGINE=docker  # or podman
```

### Testing

```bash
make test              # Unit + contract tests
make test-unit         # Unit tests only
make test-contract     # Contract tests only
make test-integration  # Integration tests (requires k8s cluster)
make test-permissions  # RBAC/permission tests
make test-coverage     # Generate coverage report
```

For integration tests, set environment variables:
```bash
export TEST_NAMESPACE=test-namespace
export CLEANUP_RESOURCES=true
make test-integration
```

### Linting

```bash
make fmt               # Format code
make vet               # Run go vet
make lint              # golangci-lint (install with make install-tools)
```

**Pre-commit checklist**:
```bash
# Run all linting checks
gofmt -l .             # Should output nothing
go vet ./...
golangci-lint run

# Auto-format code
gofmt -w .
```

### Dependencies

```bash
make deps              # Download dependencies
make deps-update       # Update dependencies
make deps-verify       # Verify dependencies
```

### Environment Check

```bash
make check-env         # Verify Go, kubectl, docker installed
```

## Architecture

See `CLAUDE.md` in project root for:
- Critical development rules
- Kubernetes client patterns
- Error handling patterns
- Security patterns
- API design patterns

## Reference Files

- `handlers/sessions.go` - AgenticSession lifecycle, user/SA client usage
- `handlers/middleware.go` - Auth patterns, token extraction, RBAC
- `handlers/helpers.go` - Utility functions (StringPtr, BoolPtr)
- `types/common.go` - Type definitions
- `server/server.go` - Server setup, middleware chain, token redaction
- `routes.go` - HTTP route definitions and registration
</file>

<file path="components/manifests/base/crds/projectsettings-crd.yaml">
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: projectsettings.vteam.ambient-code
spec:
  group: vteam.ambient-code
  versions:
  - name: v1alpha1
    served: true
    storage: true
    schema:
      openAPIV3Schema:
        type: object
        x-kubernetes-validations:
        - rule: "self.metadata.name == 'projectsettings'"
          message: "metadata.name must be 'projectsettings' (singleton per namespace)"
        properties:
          spec:
            type: object
            required:
            - groupAccess
            properties:
              groupAccess:
                type: array
                description: "Group access configuration creating RoleBindings"
                items:
                  type: object
                  required:
                  - groupName
                  - role
                  properties:
                    groupName:
                      type: string
                      description: "Name of the group to grant access"
                    role:
                      type: string
                      enum:
                      - "admin"
                      - "edit"
                      - "view"
                      description: "Role to assign to the group (admin/edit/view)"
              runnerSecretsName:
                type: string
                description: "Name of the Kubernetes Secret in this namespace that stores runner configuration key/value pairs"
          status:
            type: object
            properties:
              groupBindingsCreated:
                type: integer
                minimum: 0
                description: "Number of group RoleBindings successfully created"
    additionalPrinterColumns:
    - name: Age
      type: date
      jsonPath: .metadata.creationTimestamp
  scope: Namespaced
  names:
    plural: projectsettings
    singular: projectsetting
    kind: ProjectSettings
    shortNames:
    - ps
</file>

<file path="components/backend/types/common.go">
// Package types defines common type definitions for AgenticSession, ProjectSettings, and RFE workflows.
package types

// Common types used across the application

type GitRepository struct {
	URL    string  `json:"url"`
	Branch *string `json:"branch,omitempty"`
}

type UserContext struct {
	UserID      string   `json:"userId" binding:"required"`
	DisplayName string   `json:"displayName" binding:"required"`
	Groups      []string `json:"groups" binding:"required"`
}

type BotAccountRef struct {
	Name string `json:"name" binding:"required"`
}

type ResourceOverrides struct {
	CPU           string `json:"cpu,omitempty"`
	Memory        string `json:"memory,omitempty"`
	StorageClass  string `json:"storageClass,omitempty"`
	PriorityClass string `json:"priorityClass,omitempty"`
}

type LLMSettings struct {
	Model       string  `json:"model"`
	Temperature float64 `json:"temperature"`
	MaxTokens   int     `json:"maxTokens"`
}

type GitConfig struct {
	Repositories []GitRepository `json:"repositories,omitempty"`
}

type Paths struct {
	Workspace string `json:"workspace,omitempty"`
	Messages  string `json:"messages,omitempty"`
	Inbox     string `json:"inbox,omitempty"`
}

// BoolPtr returns a pointer to the given bool value.
func BoolPtr(b bool) *bool {
	return &b
}

func StringPtr(s string) *string {
	return &s
}

func IntPtr(i int) *int {
	return &i
}
</file>

<file path="components/backend/types/project.go">
package types

// AmbientProject represents project management types.
type AmbientProject struct {
	Name              string            `json:"name"`                  // Kubernetes namespace name
	DisplayName       string            `json:"displayName"`           // OpenShift display name (empty for k8s)
	Description       string            `json:"description,omitempty"` // OpenShift description (empty for k8s)
	Labels            map[string]string `json:"labels"`
	Annotations       map[string]string `json:"annotations"`
	CreationTimestamp string            `json:"creationTimestamp"`
	Status            string            `json:"status"`
	IsOpenShift       bool              `json:"isOpenShift"` // true if running on OpenShift cluster
}

type CreateProjectRequest struct {
	Name        string `json:"name" binding:"required"`
	DisplayName string `json:"displayName,omitempty"` // Optional: only used on OpenShift
	Description string `json:"description,omitempty"` // Optional: only used on OpenShift
}
</file>

<file path="components/backend/websocket/handlers.go">
package websocket

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strings"
	"time"

	"ambient-code-backend/handlers"

	"github.com/gin-gonic/gin"
	"github.com/gorilla/websocket"
)

// WebSocket upgrader
var upgrader = websocket.Upgrader{
	CheckOrigin: func(r *http.Request) bool {
		// Allow all origins for development - should be restricted in production
		return true
	},
}

// HandleSessionWebSocket handles WebSocket connections for sessions
// Route: /projects/:projectName/sessions/:sessionId/ws
func HandleSessionWebSocket(c *gin.Context) {
	sessionID := c.Param("sessionId")
	log.Printf("handleSessionWebSocket for session: %s", sessionID)

	// Access enforced by RBAC on downstream resources

	// Best-effort user identity: prefer forwarded user, else extract ServiceAccount from bearer token
	var userIDStr string
	if v, ok := c.Get("userID"); ok {
		if s, ok2 := v.(string); ok2 {
			userIDStr = s
		}
	}
	if userIDStr == "" {
		if ns, sa, ok := handlers.ExtractServiceAccountFromAuth(c); ok {
			userIDStr = ns + ":" + sa
		}
	}

	// Upgrade HTTP connection to WebSocket
	conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
	if err != nil {
		log.Printf("WebSocket upgrade failed: %v", err)
		return
	}

	sessionConn := &SessionConnection{
		SessionID: sessionID,
		Conn:      conn,
		UserID:    userIDStr,
	}

	// Register connection
	Hub.register <- sessionConn

	// Handle messages from client
	go handleWebSocketMessages(sessionConn)

	// Keep connection alive
	go handleWebSocketPing(sessionConn)
}

// handleWebSocketMessages processes incoming WebSocket messages
func handleWebSocketMessages(conn *SessionConnection) {
	defer func() {
		Hub.unregister <- conn
	}()

	for {
		messageType, messageData, err := conn.Conn.ReadMessage()
		if err != nil {
			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
				log.Printf("WebSocket error: %v", err)
			}
			break
		}

		if messageType == websocket.TextMessage {
			var msg map[string]interface{}
			if err := json.Unmarshal(messageData, &msg); err != nil {
				log.Printf("Failed to parse WebSocket message: %v", err)
				continue
			}

			// Handle control messages
			if msgType, ok := msg["type"].(string); ok {
				if msgType == "ping" {
					// Respond with pong
					pong := map[string]interface{}{
						"type":      "pong",
						"timestamp": time.Now().UTC().Format(time.RFC3339),
					}
					pongData, _ := json.Marshal(pong)
					// Lock write mutex before writing pong
					conn.writeMu.Lock()
					_ = conn.Conn.WriteMessage(websocket.TextMessage, pongData)
					conn.writeMu.Unlock()
					continue
				}
				// Extract payload from runner message to avoid double-nesting
				// Runner sends: {type, seq, timestamp, payload}
				// We only want to store the payload field
				payload, ok := msg["payload"].(map[string]interface{})
				if !ok {
					payload = msg // Fallback for legacy format
				}
				// Broadcast all other messages to session listeners (UI and others)
				sessionMsg := &SessionMessage{
					SessionID: conn.SessionID,
					Type:      msgType,
					Timestamp: time.Now().UTC().Format(time.RFC3339),
					Payload:   payload,
				}
				Hub.broadcast <- sessionMsg
			}
		}
	}
}

// handleWebSocketPing sends periodic ping messages
func handleWebSocketPing(conn *SessionConnection) {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for range ticker.C {
		// Lock write mutex before writing ping
		conn.writeMu.Lock()
		err := conn.Conn.WriteMessage(websocket.PingMessage, nil)
		conn.writeMu.Unlock()
		if err != nil {
			return
		}
	}
}

// GetSessionMessagesWS handles GET /projects/:projectName/sessions/:sessionId/messages
// Retrieves messages from S3 storage
func GetSessionMessagesWS(c *gin.Context) {
	sessionID := c.Param("sessionId")

	// Access enforced by RBAC on downstream resources

	messages, err := retrieveMessagesFromS3(sessionID)
	if err != nil {
		log.Printf("getSessionMessagesWS: retrieve failed: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": fmt.Sprintf("failed to retrieve messages: %v", err),
		})
		return
	}

	// Optional consolidation of partial messages
	includeParam := strings.ToLower(strings.TrimSpace(c.Query("include_partial_messages")))
	includePartials := includeParam == "1" || includeParam == "true" || includeParam == "yes"

	collapsed := make([]SessionMessage, 0, len(messages))
	activePartialIndex := -1
	for _, m := range messages {
		if m.Type == "message.partial" {
			if includePartials {
				if activePartialIndex >= 0 {
					collapsed[activePartialIndex] = m
				} else {
					collapsed = append(collapsed, m)
					activePartialIndex = len(collapsed) - 1
				}
			}
			// If not including partials, simply skip adding them
			continue
		}
		// On any non-partial, clear active partial placeholder
		activePartialIndex = -1
		collapsed = append(collapsed, m)
	}

	c.JSON(http.StatusOK, gin.H{
		"sessionId": sessionID,
		"messages":  collapsed,
	})
}

// PostSessionMessageWS handles POST /projects/:projectName/sessions/:sessionId/messages
// Accepts a generic JSON body. If a "type" string is provided, it will be used.
// Otherwise, defaults to "user_message" and wraps body under payload.
func PostSessionMessageWS(c *gin.Context) {
	sessionID := c.Param("sessionId")

	var body map[string]interface{}
	if err := c.BindJSON(&body); err != nil {
		log.Printf("postSessionMessageWS: bind failed: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid JSON body"})
		return
	}

	msgType := "user_message"
	if v, ok := body["type"].(string); ok && v != "" {
		msgType = v
		// Remove type from payload to avoid duplication
		delete(body, "type")
	}

	message := &SessionMessage{
		SessionID: sessionID,
		Type:      msgType,
		Timestamp: time.Now().UTC().Format(time.RFC3339),
		Payload:   body,
	}

	// Broadcast to session listeners (runner) and persist
	Hub.broadcast <- message

	c.JSON(http.StatusAccepted, gin.H{"status": "queued"})
}

// NOTE: GetSessionMessagesClaudeFormat removed - session continuation now uses
// SDK's built-in resume functionality with persisted ~/.claude state
// See: https://docs.claude.com/en/api/agent-sdk/sessions
</file>

<file path="components/backend/websocket/hub.go">
// Package websocket provides real-time WebSocket communication for session updates.
package websocket

import (
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"sync"
	"time"

	"github.com/gorilla/websocket"
)

// SessionWebSocketHub manages WebSocket connections for sessions
type SessionWebSocketHub struct {
	// Map of sessionID -> SessionConnection pointers
	sessions map[string]map[*SessionConnection]bool
	// Register new connections
	register chan *SessionConnection
	// Unregister connections
	unregister chan *SessionConnection
	// Broadcast messages to session
	broadcast chan *SessionMessage
	mu        sync.RWMutex
}

// SessionConnection represents a WebSocket connection to a session
type SessionConnection struct {
	SessionID string
	Conn      *websocket.Conn
	UserID    string
	writeMu   sync.Mutex // Protects concurrent writes to Conn
}

// SessionMessage represents a message in a session
type SessionMessage struct {
	SessionID string                 `json:"sessionId"`
	Type      string                 `json:"type"`
	Timestamp string                 `json:"timestamp"`
	Payload   map[string]interface{} `json:"payload"`
	// Partial message support
	Partial *PartialMessageInfo `json:"partial,omitempty"`
}

// PartialMessageInfo for fragmented messages
type PartialMessageInfo struct {
	ID    string `json:"id"`
	Index int    `json:"index"`
	Total int    `json:"total"`
	Data  string `json:"data"`
}

// Package-level variables
var (
	Hub          *SessionWebSocketHub
	StateBaseDir string
)

// Initialize WebSocket hub
func init() {
	Hub = &SessionWebSocketHub{
		sessions:   make(map[string]map[*SessionConnection]bool),
		register:   make(chan *SessionConnection),
		unregister: make(chan *SessionConnection),
		broadcast:  make(chan *SessionMessage),
	}
	go Hub.run()
}

// run starts the WebSocket hub
func (h *SessionWebSocketHub) run() {
	for {
		select {
		case conn := <-h.register:
			h.mu.Lock()
			if h.sessions[conn.SessionID] == nil {
				h.sessions[conn.SessionID] = make(map[*SessionConnection]bool)
			}
			h.sessions[conn.SessionID][conn] = true
			h.mu.Unlock()
			log.Printf("WebSocket connection registered for session %s", conn.SessionID)

		case conn := <-h.unregister:
			h.mu.Lock()
			if connections, exists := h.sessions[conn.SessionID]; exists {
				if _, exists := connections[conn]; exists {
					delete(connections, conn)
					conn.Conn.Close()
					if len(connections) == 0 {
						delete(h.sessions, conn.SessionID)
					}
				}
			}
			h.mu.Unlock()
			log.Printf("WebSocket connection unregistered for session %s", conn.SessionID)

		case message := <-h.broadcast:
			h.mu.RLock()
			connections := h.sessions[message.SessionID]
			h.mu.RUnlock()

			if connections != nil {
				messageData, _ := json.Marshal(message)
				for sessionConn := range connections {
					// Lock write mutex before writing
					sessionConn.writeMu.Lock()
					err := sessionConn.Conn.WriteMessage(websocket.TextMessage, messageData)
					sessionConn.writeMu.Unlock()
					if err != nil {
						// Unregister in goroutine to avoid deadlock - hub select loop
						// can only process one case at a time, so blocking send would hang
						go func(conn *SessionConnection) {
							h.unregister <- conn
						}(sessionConn)
					}
				}
			}

			// Also persist to S3
			go persistMessageToS3(message)
		}
	}
}

// SendMessageToSession sends a message to all connections for a session
func SendMessageToSession(sessionID string, messageType string, payload map[string]interface{}) {
	message := &SessionMessage{
		SessionID: sessionID,
		Type:      messageType,
		Timestamp: time.Now().UTC().Format(time.RFC3339),
		Payload:   payload,
	}

	Hub.broadcast <- message
}

// SendPartialMessage sends a fragmented message to a session
func SendPartialMessage(sessionID string, partialID string, index, total int, data string) {
	message := &SessionMessage{
		SessionID: sessionID,
		Type:      "message.partial",
		Timestamp: time.Now().UTC().Format(time.RFC3339),
		Payload:   map[string]interface{}{},
		Partial: &PartialMessageInfo{
			ID:    partialID,
			Index: index,
			Total: total,
			Data:  data,
		},
	}

	Hub.broadcast <- message
}

// Helper functions

func persistMessageToS3(message *SessionMessage) {
	// Write messages to per-project content service path as JSONL append for now
	// Backend does not have project in this scope; persist to local state dir for durability
	path := fmt.Sprintf("%s/sessions/%s/messages.jsonl", StateBaseDir, message.SessionID)
	log.Printf("persistMessageToS3: path: %s", path)
	b, _ := json.Marshal(message)
	// Ensure dir
	_ = os.MkdirAll(fmt.Sprintf("%s/sessions/%s", StateBaseDir, message.SessionID), 0o755)
	f, err := os.OpenFile(path, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0o644)
	if err != nil {
		log.Printf("persistMessage: open failed: %v", err)
		return
	}
	defer f.Close()
	if _, err := f.Write(append(b, '\n')); err != nil {
		log.Printf("persistMessage: write failed: %v", err)
	}
}

func retrieveMessagesFromS3(sessionID string) ([]SessionMessage, error) {
	// Read from local state JSONL path for now
	path := fmt.Sprintf("%s/sessions/%s/messages.jsonl", StateBaseDir, sessionID)
	data, err := os.ReadFile(path)
	if err != nil {
		log.Printf("retrieveMessagesFromS3: read failed: %v", err)
		if os.IsNotExist(err) {
			return []SessionMessage{}, nil
		}
		return nil, err
	}
	lines := bytes.Split(data, []byte("\n"))
	msgs := make([]SessionMessage, 0, len(lines))
	for _, line := range lines {
		line = bytes.TrimSpace(line)
		if len(line) == 0 {
			continue
		}
		var m SessionMessage
		if err := json.Unmarshal(line, &m); err == nil {
			msgs = append(msgs, m)
		}
	}
	return msgs, nil
}
</file>

<file path="components/manifests/base/crds/agenticsessions-crd.yaml">
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: agenticsessions.vteam.ambient-code
spec:
  group: vteam.ambient-code
  versions:
  - name: v1alpha1
    served: true
    storage: true
    subresources:
      status: {}
    schema:
      openAPIV3Schema:
        type: object
        properties:
          spec:
            type: object
            properties:
              # Multiple-repo configuration (new unified mapping)
              repos:
                type: array
                description: "List of repositories. Each has an input (required) and an optional output mapping."
                items:
                  type: object
                  required:
                  - input
                  properties:
                    input:
                      type: object
                      required:
                      - url
                      properties:
                        url:
                          type: string
                          description: "Input (upstream) Git repository URL"
                        branch:
                          type: string
                          description: "Input branch to checkout"
                          default: "main"
                    output:
                      type: object
                      description: "Optional output (fork/target) repository"
                      properties:
                        url:
                          type: string
                          description: "Output Git repository URL (fork or same as input)"
                        branch:
                          type: string
                          description: "Output branch to push to"
                          default: "main"
              mainRepoIndex:
                type: integer
                description: "Index of the repo in repos array treated as the main repo (Claude working dir). Defaults to 0 (first repo)."
                default: 0
              interactive:
                type: boolean
                description: "When true, run session in interactive chat mode using inbox/outbox files"
              prompt:
                type: string
                description: "Optional initial prompt for the agentic session. If using a workflow with startupPrompt in ambient.json, this can be omitted."
              displayName:
                type: string
                description: "A descriptive display name for the agentic session generated from prompt and website"
              userContext:
                type: object
                description: "Authenticated caller identity captured at creation time"
                properties:
                  userId:
                    type: string
                    description: "Stable user identifier (from SSO)"
                  displayName:
                    type: string
                    description: "Human-readable display name"
                  groups:
                    type: array
                    items:
                      type: string
                    description: "Group memberships of the user"
              llmSettings:
                type: object
                properties:
                  model:
                    type: string
                    default: "claude-3-7-sonnet-latest"
                  temperature:
                    type: number
                    default: 0.7
                  maxTokens:
                    type: integer
                    default: 4000
                description: "LLM configuration settings"
              timeout:
                type: integer
                default: 300
                description: "Timeout in seconds for the agentic session"
              autoPushOnComplete:
                type: boolean
                default: false
                description: "When true, the runner will commit and push changes automatically after it finishes"
              activeWorkflow:
                type: object
                description: "Active workflow configuration for dynamic workflow switching"
                properties:
                  gitUrl:
                    type: string
                    description: "Git repository URL for the workflow"
                  branch:
                    type: string
                    description: "Branch to clone"
                    default: "main"
                  path:
                    type: string
                    description: "Optional path within repo (for repos with multiple workflows)"
          status:
            type: object
            properties:
              phase:
                type: string
                enum:
                - "Pending"
                - "Creating"
                - "Running"
                - "Completed"
                - "Failed"
                - "Stopped"
                - "Error"
                default: "Pending"
              message:
                type: string
                description: "Status message or error details"
              startTime:
                type: string
                format: date-time
              completionTime:
                type: string
                format: date-time
              jobName:
                type: string
                description: "Name of the Kubernetes job created for this session"
              stateDir:
                type: string
                description: "Directory path where session state files are stored"
              # Result summary fields from the runner's ResultMessage
              subtype:
                type: string
                description: "Result subtype (e.g., success, error, interrupted)"
              is_error:
                type: boolean
                description: "Whether the run ended with an error"
              num_turns:
                type: integer
                description: "Number of conversation turns in the run"
              session_id:
                type: string
                description: "Runner session identifier"
              total_cost_usd:
                type: number
                description: "Total cost of the run in USD as reported by the runner"
              usage:
                type: object
                description: "Token and request usage breakdown"
                x-kubernetes-preserve-unknown-fields: true
              result:
                type: string
                description: "Final result text as reported by the runner"
              has_workspace_changes:
                type: boolean
                description: "Whether workspace has uncommitted changes (for cleanup decisions)"
              repos:
                type: array
                description: "Per-repo status tracking"
                items:
                  type: object
                  properties:
                    name:
                      type: string
                      description: "Repository name (derived from URL or spec.repos[].name)"
                    status:
                      type: string
                      description: "Repository state"
                      enum:
                      - "pushed"
                      - "abandoned"
                      - "diff"
                      - "nodiff"
                    last_updated:
                      type: string
                      format: date-time
                      description: "Last time this repo status was updated"
                    total_added:
                      type: integer
                      description: "Total lines added (from git diff)"
                    total_removed:
                      type: integer
                      description: "Total lines removed (from git diff)"
    additionalPrinterColumns:
    - name: Phase
      type: string
      description: Current phase of the agentic session
      jsonPath: .status.phase
    - name: Age
      type: date
      jsonPath: .metadata.creationTimestamp
  scope: Namespaced
  names:
    plural: agenticsessions
    singular: agenticsession
    kind: AgenticSession
    shortNames:
    - as
</file>

<file path="components/manifests/base/crds/kustomization.yaml">
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
resources:
- agenticsessions-crd.yaml
- projectsettings-crd.yaml
</file>

<file path="components/backend/handlers/github_auth.go">
package handlers

import (
	"context"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
)

// Package-level variables for GitHub auth (set from main package)
var (
	K8sClient          *kubernetes.Clientset
	Namespace          string
	GithubTokenManager GithubTokenManagerInterface
)

// GithubTokenManagerInterface defines the interface for GitHub token management
type GithubTokenManagerInterface interface {
	GenerateJWT() (string, error)
}

// GitHubAppInstallation represents a GitHub App installation for a user
type GitHubAppInstallation struct {
	UserID         string    `json:"userId"`
	GitHubUserID   string    `json:"githubUserId"`
	InstallationID int64     `json:"installationId"`
	Host           string    `json:"host"`
	UpdatedAt      time.Time `json:"updatedAt"`
}

// GetInstallationID implements the interface for git package
func (g *GitHubAppInstallation) GetInstallationID() int64 {
	return g.InstallationID
}

// GetHost implements the interface for git package
func (g *GitHubAppInstallation) GetHost() string {
	return g.Host
}

// helper: resolve GitHub API base URL from host
func githubAPIBaseURL(host string) string {
	if host == "" || host == "github.com" {
		return "https://api.github.com"
	}
	// GitHub Enterprise default
	return fmt.Sprintf("https://%s/api/v3", host)
}

// doGitHubRequest executes an HTTP request to the GitHub API
func doGitHubRequest(ctx context.Context, method string, url string, authHeader string, accept string, body io.Reader) (*http.Response, error) {
	req, err := http.NewRequestWithContext(ctx, method, url, body)
	if err != nil {
		return nil, err
	}
	if accept == "" {
		accept = "application/vnd.github+json"
	}
	req.Header.Set("Accept", accept)
	req.Header.Set("X-GitHub-Api-Version", "2022-11-28")
	req.Header.Set("User-Agent", "vTeam-Backend")
	if authHeader != "" {
		req.Header.Set("Authorization", authHeader)
	}
	// Optional If-None-Match can be set by callers via context
	if v := ctx.Value("ifNoneMatch"); v != nil {
		if s, ok := v.(string); ok && s != "" {
			req.Header.Set("If-None-Match", s)
		}
	}
	client := &http.Client{Timeout: 15 * time.Second}
	return client.Do(req)
}

// ===== OAuth during installation (user verification) =====

// signState signs a payload with HMAC SHA-256
func signState(secret string, payload string) string {
	mac := hmac.New(sha256.New, []byte(secret))
	mac.Write([]byte(payload))
	return hex.EncodeToString(mac.Sum(nil))
}

// HandleGitHubUserOAuthCallback handles GET /auth/github/user/callback
func HandleGitHubUserOAuthCallback(c *gin.Context) {
	clientID := os.Getenv("GITHUB_CLIENT_ID")
	clientSecret := os.Getenv("GITHUB_CLIENT_SECRET")
	stateSecret := os.Getenv("GITHUB_STATE_SECRET")
	if strings.TrimSpace(clientID) == "" || strings.TrimSpace(clientSecret) == "" || strings.TrimSpace(stateSecret) == "" {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "OAuth not configured"})
		return
	}
	code := c.Query("code")
	state := c.Query("state")
	if code == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "missing code"})
		return
	}
	// Defaults when no state provided
	var retB64 string
	var instID int64
	// Validate state if present
	if state != "" {
		raw, err := base64.RawURLEncoding.DecodeString(state)
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "invalid state"})
			return
		}
		parts := strings.SplitN(string(raw), ".", 2)
		if len(parts) != 2 {
			c.JSON(http.StatusBadRequest, gin.H{"error": "invalid state"})
			return
		}
		payload, sig := parts[0], parts[1]
		if signState(stateSecret, payload) != sig {
			c.JSON(http.StatusBadRequest, gin.H{"error": "bad state signature"})
			return
		}
		fields := strings.Split(payload, ":")
		if len(fields) != 5 {
			c.JSON(http.StatusBadRequest, gin.H{"error": "bad state payload"})
			return
		}
		userInState := fields[0]
		ts := fields[1]
		retB64 = fields[3]
		instB64 := fields[4]
		if sec, err := strconv.ParseInt(ts, 10, 64); err == nil {
			if time.Since(time.Unix(sec, 0)) > 10*time.Minute {
				c.JSON(http.StatusBadRequest, gin.H{"error": "state expired"})
				return
			}
		}
		// Confirm current session user matches state user
		userID, _ := c.Get("userID")
		if userID == nil || userInState != userID.(string) {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "user mismatch"})
			return
		}
		// Decode installation id from state
		instBytes, _ := base64.RawURLEncoding.DecodeString(instB64)
		instStr := string(instBytes)
		instID, _ = strconv.ParseInt(instStr, 10, 64)
	} else {
		// No state (install started outside our UI). Require user session and read installation_id from query.
		userID, _ := c.Get("userID")
		if userID == nil || strings.TrimSpace(userID.(string)) == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "missing user identity"})
			return
		}
		instStr := c.Query("installation_id")
		var err error
		instID, err = strconv.ParseInt(instStr, 10, 64)
		if err != nil || instID <= 0 {
			c.JSON(http.StatusBadRequest, gin.H{"error": "invalid installation id"})
			return
		}
	}
	// Exchange code → user token
	token, err := exchangeOAuthCodeForUserToken(clientID, clientSecret, code)
	if err != nil {
		c.JSON(http.StatusBadGateway, gin.H{"error": "oauth exchange failed"})
		return
	}
	// Verify ownership: GET /user/installations includes the installation
	owns, login, err := userOwnsInstallation(token, instID)
	if err != nil {
		c.JSON(http.StatusBadGateway, gin.H{"error": "verification failed"})
		return
	}
	if !owns {
		c.JSON(http.StatusForbidden, gin.H{"error": "installation not owned by user"})
		return
	}
	// Store mapping
	installation := GitHubAppInstallation{
		UserID:         c.GetString("userID"),
		GitHubUserID:   login,
		InstallationID: instID,
		Host:           "github.com",
		UpdatedAt:      time.Now(),
	}
	if err := storeGitHubInstallation(c.Request.Context(), "", &installation); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to store installation"})
		return
	}
	// Redirect back to return_to if present
	retURL := "/integrations"
	if retB64 != "" {
		if b, err := base64.RawURLEncoding.DecodeString(retB64); err == nil {
			retURL = string(b)
		}
	}
	if retURL == "" {
		retURL = "/integrations"
	}
	c.Redirect(http.StatusFound, retURL)
}

func exchangeOAuthCodeForUserToken(clientID, clientSecret, code string) (string, error) {
	reqBody := strings.NewReader(fmt.Sprintf("client_id=%s&client_secret=%s&code=%s", clientID, clientSecret, code))
	req, _ := http.NewRequest(http.MethodPost, "https://github.com/login/oauth/access_token", reqBody)
	req.Header.Set("Accept", "application/json")
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	var parsed struct {
		AccessToken string `json:"access_token"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&parsed); err != nil {
		return "", err
	}
	if parsed.AccessToken == "" {
		return "", fmt.Errorf("empty token")
	}
	return parsed.AccessToken, nil
}

func userOwnsInstallation(userToken string, installationID int64) (bool, string, error) {
	req, _ := http.NewRequest(http.MethodGet, "https://api.github.com/user/installations", nil)
	req.Header.Set("Accept", "application/vnd.github+json")
	req.Header.Set("Authorization", "token "+userToken)
	req.Header.Set("X-GitHub-Api-Version", "2022-11-28")
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return false, "", err
	}
	defer resp.Body.Close()
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return false, "", fmt.Errorf("bad status: %d", resp.StatusCode)
	}
	var data struct {
		Installations []struct {
			ID      int64 `json:"id"`
			Account struct {
				Login string `json:"login"`
			} `json:"account"`
		} `json:"installations"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
		return false, "", err
	}
	for _, inst := range data.Installations {
		if inst.ID == installationID {
			return true, inst.Account.Login, nil
		}
	}
	return false, "", nil
}

// storeGitHubInstallation persists the GitHub App installation mapping
func storeGitHubInstallation(ctx context.Context, projectName string, installation *GitHubAppInstallation) error {
	if installation == nil || installation.UserID == "" {
		return fmt.Errorf("invalid installation payload")
	}
	// Cluster-scoped by server namespace; ignore projectName for storage
	const cmName = "github-app-installations"
	for i := 0; i < 3; i++ { // retry on conflict
		cm, err := K8sClient.CoreV1().ConfigMaps(Namespace).Get(ctx, cmName, v1.GetOptions{})
		if err != nil {
			if errors.IsNotFound(err) {
				// create
				cm = &corev1.ConfigMap{ObjectMeta: v1.ObjectMeta{Name: cmName, Namespace: Namespace}, Data: map[string]string{}}
				if _, cerr := K8sClient.CoreV1().ConfigMaps(Namespace).Create(ctx, cm, v1.CreateOptions{}); cerr != nil && !errors.IsAlreadyExists(cerr) {
					return fmt.Errorf("failed to create ConfigMap: %w", cerr)
				}
				// fetch again to get resourceVersion
				cm, err = K8sClient.CoreV1().ConfigMaps(Namespace).Get(ctx, cmName, v1.GetOptions{})
				if err != nil {
					return fmt.Errorf("failed to fetch ConfigMap after create: %w", err)
				}
			} else {
				return fmt.Errorf("failed to get ConfigMap: %w", err)
			}
		}
		if cm.Data == nil {
			cm.Data = map[string]string{}
		}
		b, err := json.Marshal(installation)
		if err != nil {
			return fmt.Errorf("failed to marshal installation: %w", err)
		}
		cm.Data[installation.UserID] = string(b)
		if _, uerr := K8sClient.CoreV1().ConfigMaps(Namespace).Update(ctx, cm, v1.UpdateOptions{}); uerr != nil {
			if errors.IsConflict(uerr) {
				continue // retry
			}
			return fmt.Errorf("failed to update ConfigMap: %w", uerr)
		}
		return nil
	}
	return fmt.Errorf("failed to update ConfigMap after retries")
}

// GetGitHubInstallation retrieves GitHub App installation for a user
func GetGitHubInstallation(ctx context.Context, userID string) (*GitHubAppInstallation, error) {
	const cmName = "github-app-installations"
	cm, err := K8sClient.CoreV1().ConfigMaps(Namespace).Get(ctx, cmName, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			return nil, fmt.Errorf("installation not found")
		}
		return nil, fmt.Errorf("failed to read ConfigMap: %w", err)
	}
	if cm.Data == nil {
		return nil, fmt.Errorf("installation not found")
	}
	raw, ok := cm.Data[userID]
	if !ok || raw == "" {
		return nil, fmt.Errorf("installation not found")
	}
	var inst GitHubAppInstallation
	if err := json.Unmarshal([]byte(raw), &inst); err != nil {
		return nil, fmt.Errorf("failed to decode installation: %w", err)
	}
	return &inst, nil
}

// deleteGitHubInstallation removes the user mapping from ConfigMap
func deleteGitHubInstallation(ctx context.Context, userID string) error {
	const cmName = "github-app-installations"
	cm, err := K8sClient.CoreV1().ConfigMaps(Namespace).Get(ctx, cmName, v1.GetOptions{})
	if err != nil {
		return err
	}
	if cm.Data == nil {
		return nil
	}
	delete(cm.Data, userID)
	_, uerr := K8sClient.CoreV1().ConfigMaps(Namespace).Update(ctx, cm, v1.UpdateOptions{})
	return uerr
}

// ===== Global, non-project-scoped endpoints =====

// LinkGitHubInstallationGlobal handles POST /auth/github/install
// Links the current SSO user to a GitHub App installation ID.
func LinkGitHubInstallationGlobal(c *gin.Context) {
	userID, _ := c.Get("userID")
	if userID == nil || strings.TrimSpace(userID.(string)) == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "missing user identity"})
		return
	}
	var req struct {
		InstallationID int64 `json:"installationId" binding:"required"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	installation := GitHubAppInstallation{
		UserID:         userID.(string),
		InstallationID: req.InstallationID,
		Host:           "github.com",
		UpdatedAt:      time.Now(),
	}
	// Best-effort: enrich with GitHub account login for the installation
	if GithubTokenManager != nil {
		if jwt, err := GithubTokenManager.GenerateJWT(); err == nil {
			api := githubAPIBaseURL(installation.Host)
			url := fmt.Sprintf("%s/app/installations/%d", api, req.InstallationID)
			resp, err := doGitHubRequest(c.Request.Context(), http.MethodGet, url, "Bearer "+jwt, "", nil)
			if err == nil {
				defer resp.Body.Close()
				if resp.StatusCode >= 200 && resp.StatusCode < 300 {
					var instObj map[string]interface{}
					if err := json.NewDecoder(resp.Body).Decode(&instObj); err == nil {
						if acct, ok := instObj["account"].(map[string]interface{}); ok {
							if login, ok := acct["login"].(string); ok {
								installation.GitHubUserID = login
							}
						}
					}
				}
			}
		}
	}
	if err := storeGitHubInstallation(c.Request.Context(), "", &installation); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to store installation"})
		return
	}
	c.JSON(http.StatusOK, gin.H{"message": "GitHub App installation linked successfully", "installationId": req.InstallationID})
}

// GetGitHubStatusGlobal handles GET /auth/github/status
func GetGitHubStatusGlobal(c *gin.Context) {
	userID, _ := c.Get("userID")
	if userID == nil || strings.TrimSpace(userID.(string)) == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "missing user identity"})
		return
	}
	inst, err := GetGitHubInstallation(c.Request.Context(), userID.(string))
	if err != nil {
		c.JSON(http.StatusOK, gin.H{"installed": false})
		return
	}
	c.JSON(http.StatusOK, gin.H{
		"installed":      true,
		"installationId": inst.InstallationID,
		"host":           inst.Host,
		"githubUserId":   inst.GitHubUserID,
		"userId":         inst.UserID,
		"updatedAt":      inst.UpdatedAt.Format(time.RFC3339),
	})
}

// DisconnectGitHubGlobal handles POST /auth/github/disconnect
func DisconnectGitHubGlobal(c *gin.Context) {
	userID, _ := c.Get("userID")
	if userID == nil || strings.TrimSpace(userID.(string)) == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "missing user identity"})
		return
	}
	if err := deleteGitHubInstallation(c.Request.Context(), userID.(string)); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to unlink installation"})
		return
	}
	c.JSON(http.StatusOK, gin.H{"message": "GitHub account disconnected"})
}
</file>

<file path="components/backend/handlers/helpers.go">
package handlers

import (
	"fmt"
	"log"
	"math"
	"time"

	"k8s.io/apimachinery/pkg/runtime/schema"
)

// GetProjectSettingsResource returns the GroupVersionResource for ProjectSettings
func GetProjectSettingsResource() schema.GroupVersionResource {
	return schema.GroupVersionResource{
		Group:    "vteam.ambient-code",
		Version:  "v1alpha1",
		Resource: "projectsettings",
	}
}

// RetryWithBackoff attempts an operation with exponential backoff
// Used for operations that may temporarily fail due to async resource creation
// This is a generic utility that can be used by any handler
// Checks for context cancellation between retries to avoid wasting resources
func RetryWithBackoff(maxRetries int, initialDelay, maxDelay time.Duration, operation func() error) error {
	var lastErr error
	for i := 0; i < maxRetries; i++ {
		if err := operation(); err != nil {
			lastErr = err
			if i < maxRetries-1 {
				// Calculate exponential backoff delay
				delay := time.Duration(float64(initialDelay) * math.Pow(2, float64(i)))
				if delay > maxDelay {
					delay = maxDelay
				}
				log.Printf("Operation failed (attempt %d/%d), retrying in %v: %v", i+1, maxRetries, delay, err)
				time.Sleep(delay)
				continue
			}
		} else {
			return nil
		}
	}
	return fmt.Errorf("operation failed after %d retries: %w", maxRetries, lastErr)
}
</file>

<file path="components/backend/handlers/repo.go">
package handlers

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
	authv1 "k8s.io/api/authorization/v1"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/dynamic"
	"k8s.io/client-go/kubernetes"
)

// Dependencies injected from main package
var (
	GetK8sClientsForRequestRepo func(*gin.Context) (*kubernetes.Clientset, dynamic.Interface)
	GetGitHubTokenRepo          func(context.Context, *kubernetes.Clientset, dynamic.Interface, string, string) (string, error)
)

// ===== Helper Functions =====

// parseOwnerRepo parses repo into owner/repo from either owner/repo or full URL/SSH
func parseOwnerRepo(full string) (string, string, error) {
	s := strings.TrimSpace(full)
	s = strings.TrimSuffix(s, ".git")
	// Handle URLs or SSH forms like git@github.com:owner/repo.git
	if strings.HasPrefix(s, "http://") || strings.HasPrefix(s, "https://") || strings.HasPrefix(s, "ssh://") || strings.Contains(s, "@") {
		// Normalize SSH to https-like then split
		s = strings.NewReplacer(":", "/", "git@", "https://").Replace(s)
		parts := strings.Split(s, "/")
		if len(parts) >= 2 {
			owner := parts[len(parts)-2]
			repo := parts[len(parts)-1]
			if owner != "" && repo != "" {
				return owner, repo, nil
			}
		}
		return "", "", fmt.Errorf("invalid repo format, expected owner/repo")
	}
	// owner/repo
	parts := strings.Split(s, "/")
	if len(parts) == 2 && parts[0] != "" && parts[1] != "" {
		return parts[0], parts[1], nil
	}
	return "", "", fmt.Errorf("invalid repo format, expected owner/repo")
}

// Note: githubAPIBaseURL and doGitHubRequest are defined in github_auth.go

// ===== Handler Functions =====

// AccessCheck verifies if the caller has write access to ProjectSettings in the project namespace
// It performs a Kubernetes SelfSubjectAccessReview using the caller token (user or API key).
func AccessCheck(c *gin.Context) {
	projectName := c.Param("projectName")
	reqK8s, _ := GetK8sClientsForRequestRepo(c)

	// Build the SSAR spec for RoleBinding management in the project namespace
	ssar := &authv1.SelfSubjectAccessReview{
		Spec: authv1.SelfSubjectAccessReviewSpec{
			ResourceAttributes: &authv1.ResourceAttributes{
				Group:     "rbac.authorization.k8s.io",
				Resource:  "rolebindings",
				Verb:      "create",
				Namespace: projectName,
			},
		},
	}

	// Perform the review
	res, err := reqK8s.AuthorizationV1().SelfSubjectAccessReviews().Create(c.Request.Context(), ssar, v1.CreateOptions{})
	if err != nil {
		log.Printf("SSAR failed for project %s: %v", projectName, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to perform access review"})
		return
	}

	role := "view"
	if res.Status.Allowed {
		// If update on ProjectSettings is allowed, treat as admin for this page
		role = "admin"
	} else {
		// Optional: try a lesser check for create sessions to infer "edit"
		editSSAR := &authv1.SelfSubjectAccessReview{
			Spec: authv1.SelfSubjectAccessReviewSpec{
				ResourceAttributes: &authv1.ResourceAttributes{
					Group:     "vteam.ambient-code",
					Resource:  "agenticsessions",
					Verb:      "create",
					Namespace: projectName,
				},
			},
		}
		res2, err2 := reqK8s.AuthorizationV1().SelfSubjectAccessReviews().Create(c.Request.Context(), editSSAR, v1.CreateOptions{})
		if err2 == nil && res2.Status.Allowed {
			role = "edit"
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"project":  projectName,
		"allowed":  res.Status.Allowed,
		"reason":   res.Status.Reason,
		"userRole": role,
	})
}

// ListUserForks handles GET /projects/:projectName/users/forks
// List user forks for an upstream repo (RBAC-scoped)
func ListUserForks(c *gin.Context) {
	project := c.Param("projectName")
	upstreamRepo := c.Query("upstreamRepo")

	if upstreamRepo == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "upstreamRepo query parameter required"})
		return
	}

	userID, _ := c.Get("userID")
	reqK8s, reqDyn := GetK8sClientsForRequestRepo(c)

	// Try to get GitHub token (GitHub App or PAT from runner secret)
	token, err := GetGitHubTokenRepo(c.Request.Context(), reqK8s, reqDyn, project, userID.(string))
	if err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
		return
	}

	owner, repoName, err := parseOwnerRepo(upstreamRepo)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	api := githubAPIBaseURL("github.com")
	// Fetch all pages of forks (public + any accessible private). Cap pages for safety.
	allForksResp := make([]map[string]interface{}, 0, 100)
	const perPage = 100
	for page := 1; page <= 10; page++ { // safety cap: up to 1000 forks
		url := fmt.Sprintf("%s/repos/%s/%s/forks?per_page=%d&page=%d", api, owner, repoName, perPage, page)
		resp, err := doGitHubRequest(c.Request.Context(), http.MethodGet, url, "Bearer "+token, "", nil)
		if err != nil {
			c.JSON(http.StatusBadGateway, gin.H{"error": fmt.Sprintf("GitHub request failed: %v", err)})
			return
		}
		if resp.StatusCode < 200 || resp.StatusCode >= 300 {
			b, _ := io.ReadAll(resp.Body)
			_ = resp.Body.Close()
			c.JSON(resp.StatusCode, gin.H{"error": string(b)})
			return
		}
		var pageForks []map[string]interface{}
		decErr := json.NewDecoder(resp.Body).Decode(&pageForks)
		_ = resp.Body.Close()
		if decErr != nil {
			c.JSON(http.StatusBadGateway, gin.H{"error": fmt.Sprintf("failed to parse GitHub response: %v", decErr)})
			return
		}
		if len(pageForks) == 0 {
			break
		}
		allForksResp = append(allForksResp, pageForks...)
		if len(pageForks) < perPage {
			break
		}
	}
	// Map all forks
	all := make([]map[string]interface{}, 0, len(allForksResp))
	for _, f := range allForksResp {
		name, _ := f["name"].(string)
		full, _ := f["full_name"].(string)
		html, _ := f["html_url"].(string)
		all = append(all, map[string]interface{}{
			"name":     name,
			"fullName": full,
			"url":      html,
		})
	}
	c.JSON(http.StatusOK, gin.H{
		"forks": all,
	})
}

// CreateUserFork handles POST /projects/:projectName/users/forks
// Create a fork of the upstream umbrella repo for the user
func CreateUserFork(c *gin.Context) {
	project := c.Param("projectName")

	var req struct {
		UpstreamRepo string `json:"upstreamRepo" binding:"required"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	userID, _ := c.Get("userID")
	reqK8s, reqDyn := GetK8sClientsForRequestRepo(c)

	// Try to get GitHub token (GitHub App or PAT from runner secret)
	token, err := GetGitHubTokenRepo(c.Request.Context(), reqK8s, reqDyn, project, userID.(string))
	if err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
		return
	}

	owner, repoName, err := parseOwnerRepo(req.UpstreamRepo)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	api := githubAPIBaseURL("github.com")
	url := fmt.Sprintf("%s/repos/%s/%s/forks", api, owner, repoName)
	resp, err := doGitHubRequest(c.Request.Context(), http.MethodPost, url, "Bearer "+token, "", nil)
	if err != nil {
		c.JSON(http.StatusBadGateway, gin.H{"error": fmt.Sprintf("GitHub request failed: %v", err)})
		return
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusAccepted && (resp.StatusCode < 200 || resp.StatusCode >= 300) {
		b, _ := io.ReadAll(resp.Body)
		c.JSON(resp.StatusCode, gin.H{"error": string(b)})
		return
	}
	// Respond that fork creation is in progress or created
	c.JSON(http.StatusAccepted, gin.H{"message": "Fork creation requested", "upstreamRepo": req.UpstreamRepo})
}

// GetRepoTree handles GET /projects/:projectName/repo/tree
// Fetch repo tree entries via backend proxy
func GetRepoTree(c *gin.Context) {
	project := c.Param("projectName")
	repo := c.Query("repo")
	ref := c.Query("ref")
	path := c.Query("path")

	if repo == "" || ref == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "repo and ref query parameters required"})
		return
	}

	userID, _ := c.Get("userID")
	reqK8s, reqDyn := GetK8sClientsForRequestRepo(c)

	// Try to get GitHub token (GitHub App or PAT from runner secret)
	token, err := GetGitHubTokenRepo(c.Request.Context(), reqK8s, reqDyn, project, userID.(string))
	if err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
		return
	}

	owner, repoName, err := parseOwnerRepo(repo)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	api := githubAPIBaseURL("github.com")
	p := path
	if p == "" || p == "/" {
		p = ""
	}
	url := fmt.Sprintf("%s/repos/%s/%s/contents/%s?ref=%s", api, owner, repoName, strings.TrimPrefix(p, "/"), ref)
	resp, err := doGitHubRequest(c.Request.Context(), http.MethodGet, url, "Bearer "+token, "", nil)
	if err != nil {
		c.JSON(http.StatusBadGateway, gin.H{"error": fmt.Sprintf("GitHub request failed: %v", err)})
		return
	}
	defer resp.Body.Close()
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		b, _ := io.ReadAll(resp.Body)
		c.JSON(resp.StatusCode, gin.H{"error": string(b)})
		return
	}
	var decoded interface{}
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		c.JSON(http.StatusBadGateway, gin.H{"error": fmt.Sprintf("failed to parse GitHub response: %v", err)})
		return
	}
	entries := []map[string]interface{}{}
	if arr, ok := decoded.([]interface{}); ok {
		for _, item := range arr {
			if m, ok := item.(map[string]interface{}); ok {
				name, _ := m["name"].(string)
				typ, _ := m["type"].(string)
				size, _ := m["size"].(float64)
				mapped := "blob"
				switch strings.ToLower(typ) {
				case "dir":
					mapped = "tree"
				case "file", "symlink", "submodule":
					mapped = "blob"
				default:
					if strings.TrimSpace(typ) == "" {
						mapped = "blob"
					}
				}
				entries = append(entries, map[string]interface{}{"name": name, "type": mapped, "size": int(size)})
			}
		}
	} else if m, ok := decoded.(map[string]interface{}); ok {
		// single file; present as one entry
		name, _ := m["name"].(string)
		typ, _ := m["type"].(string)
		size, _ := m["size"].(float64)
		mapped := "blob"
		if strings.ToLower(typ) == "dir" {
			mapped = "tree"
		}
		entries = append(entries, map[string]interface{}{"name": name, "type": mapped, "size": int(size)})
	}
	c.JSON(http.StatusOK, map[string]interface{}{"path": path, "entries": entries})
}

// ListRepoBranches handles GET /projects/:projectName/repo/branches
// List all branches in a repository
func ListRepoBranches(c *gin.Context) {
	project := c.Param("projectName")
	repo := c.Query("repo")

	if repo == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "repo query parameter required"})
		return
	}

	userID, _ := c.Get("userID")
	reqK8s, reqDyn := GetK8sClientsForRequestRepo(c)

	// Try to get GitHub token (GitHub App or PAT from runner secret)
	token, err := GetGitHubTokenRepo(c.Request.Context(), reqK8s, reqDyn, project, userID.(string))
	if err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
		return
	}

	owner, repoName, err := parseOwnerRepo(repo)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	api := githubAPIBaseURL("github.com")
	url := fmt.Sprintf("%s/repos/%s/%s/branches", api, owner, repoName)
	resp, err := doGitHubRequest(c.Request.Context(), http.MethodGet, url, "Bearer "+token, "", nil)
	if err != nil {
		c.JSON(http.StatusBadGateway, gin.H{"error": fmt.Sprintf("GitHub request failed: %v", err)})
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		b, _ := io.ReadAll(resp.Body)
		c.JSON(resp.StatusCode, gin.H{"error": string(b)})
		return
	}

	var branchesResp []map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&branchesResp); err != nil {
		c.JSON(http.StatusBadGateway, gin.H{"error": fmt.Sprintf("failed to parse GitHub response: %v", err)})
		return
	}

	// Map branches to a simpler format
	branches := make([]map[string]interface{}, 0, len(branchesResp))
	for _, b := range branchesResp {
		name, _ := b["name"].(string)
		if name != "" {
			branches = append(branches, map[string]interface{}{
				"name": name,
			})
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"branches": branches,
	})
}

// GetRepoBlob handles GET /projects/:projectName/repo/blob
// Fetch blob (text) via backend proxy
func GetRepoBlob(c *gin.Context) {
	project := c.Param("projectName")
	repo := c.Query("repo")
	ref := c.Query("ref")
	path := c.Query("path")

	if repo == "" || ref == "" || path == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "repo, ref, and path query parameters required"})
		return
	}

	userID, _ := c.Get("userID")
	reqK8s, reqDyn := GetK8sClientsForRequestRepo(c)

	// Try to get GitHub token (GitHub App or PAT from runner secret)
	token, err := GetGitHubTokenRepo(c.Request.Context(), reqK8s, reqDyn, project, userID.(string))
	if err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
		return
	}

	owner, repoName, err := parseOwnerRepo(repo)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	api := githubAPIBaseURL("github.com")
	url := fmt.Sprintf("%s/repos/%s/%s/contents/%s?ref=%s", api, owner, repoName, strings.TrimPrefix(path, "/"), ref)
	resp, err := doGitHubRequest(c.Request.Context(), http.MethodGet, url, "Bearer "+token, "", nil)
	if err != nil {
		c.JSON(http.StatusBadGateway, gin.H{"error": fmt.Sprintf("GitHub request failed: %v", err)})
		return
	}
	defer resp.Body.Close()
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		b, _ := io.ReadAll(resp.Body)
		c.JSON(resp.StatusCode, gin.H{"error": string(b)})
		return
	}
	// Decode generically first because GitHub returns an array for directories
	var decoded interface{}
	if err := json.NewDecoder(resp.Body).Decode(&decoded); err != nil {
		c.JSON(http.StatusBadGateway, gin.H{"error": fmt.Sprintf("failed to parse GitHub response: %v", err)})
		return
	}
	// If the response is an array, the path is a directory. Return entries for convenience.
	if arr, ok := decoded.([]interface{}); ok {
		entries := []map[string]interface{}{}
		for _, item := range arr {
			if m, ok := item.(map[string]interface{}); ok {
				name, _ := m["name"].(string)
				typ, _ := m["type"].(string)
				size, _ := m["size"].(float64)
				mapped := "blob"
				switch strings.ToLower(typ) {
				case "dir":
					mapped = "tree"
				case "file", "symlink", "submodule":
					mapped = "blob"
				default:
					if strings.TrimSpace(typ) == "" {
						mapped = "blob"
					}
				}
				entries = append(entries, map[string]interface{}{"name": name, "type": mapped, "size": int(size)})
			}
		}
		c.JSON(http.StatusOK, gin.H{"isDir": true, "path": path, "entries": entries})
		return
	}
	// Otherwise, treat as a file object
	if m, ok := decoded.(map[string]interface{}); ok {
		content, _ := m["content"].(string)
		encoding, _ := m["encoding"].(string)
		if strings.ToLower(encoding) == "base64" {
			raw := strings.ReplaceAll(content, "\n", "")
			if data, err := base64.StdEncoding.DecodeString(raw); err == nil {
				c.JSON(http.StatusOK, gin.H{"content": string(data), "encoding": "utf-8"})
				return
			}
		}
		c.JSON(http.StatusOK, gin.H{"content": content, "encoding": encoding})
		return
	}
	// Fallback unexpected structure
	c.JSON(http.StatusBadGateway, gin.H{"error": "unexpected GitHub response structure"})
}
</file>

<file path="components/backend/k8s/resources.go">
// Package k8s provides Kubernetes client creation and configuration utilities.
package k8s

import "k8s.io/apimachinery/pkg/runtime/schema"

// GetAgenticSessionV1Alpha1Resource returns the GroupVersionResource for AgenticSession v1alpha1
func GetAgenticSessionV1Alpha1Resource() schema.GroupVersionResource {
	return schema.GroupVersionResource{
		Group:    "vteam.ambient-code",
		Version:  "v1alpha1",
		Resource: "agenticsessions",
	}
}

// GetProjectSettingsResource returns the GroupVersionResource for ProjectSettings
func GetProjectSettingsResource() schema.GroupVersionResource {
	return schema.GroupVersionResource{
		Group:    "vteam.ambient-code",
		Version:  "v1alpha1",
		Resource: "projectsettings",
	}
}

// GetOpenShiftProjectResource returns the GroupVersionResource for OpenShift Project
func GetOpenShiftProjectResource() schema.GroupVersionResource {
	return schema.GroupVersionResource{
		Group:    "project.openshift.io",
		Version:  "v1",
		Resource: "projects",
	}
}

// GetOpenShiftProjectRequestResource returns the GroupVersionResource for OpenShift ProjectRequest
func GetOpenShiftProjectRequestResource() schema.GroupVersionResource {
	return schema.GroupVersionResource{
		Group:    "project.openshift.io",
		Version:  "v1",
		Resource: "projectrequests",
	}
}
</file>

<file path="components/manifests/base/backend-deployment.yaml">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend-api
  labels:
    app: backend-api
spec:
  replicas: 1  # Single pod for RWO PVC
  selector:
    matchLabels:
      app: backend-api
  template:
    metadata:
      labels:
        app: backend-api
        role: backend
    spec:
      serviceAccountName: backend-api
      containers:
      - name: backend-api
        image: quay.io/ambient_code/vteam_backend:latest
        imagePullPolicy: Always
        ports:
        - containerPort: 8080
          name: http
        env:
        - name: NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: PORT
          value: "8080"
        - name: STATE_BASE_DIR
          value: "/workspace"
        # Spec-kit configuration for RFE seeding
        - name: SPEC_KIT_REPO
          value: "ambient-code/spec-kit-rh"
        - name: SPEC_KIT_VERSION
          value: "main"
        # Spec-kit templates are only used when version is a tagged release
        - name: SPEC_KIT_TEMPLATE
          value: "spec-kit-template-claude-sh"
        - name: CONTENT_SERVICE_IMAGE
          value: "quay.io/ambient_code/vteam_backend:latest"
        - name: IMAGE_PULL_POLICY
          value: "Always"
        # GitHub App authentication (optional - use this OR git-secret)
        - name: GITHUB_APP_ID
          valueFrom:
            secretKeyRef:
              name: github-app-secret
              key: GITHUB_APP_ID
              optional: true
        - name: GITHUB_PRIVATE_KEY
          valueFrom:
            secretKeyRef:
              name: github-app-secret
              key: GITHUB_PRIVATE_KEY
              optional: true
        - name: GITHUB_CLIENT_ID
          valueFrom:
            secretKeyRef:
              name: github-app-secret
              key: GITHUB_CLIENT_ID
              optional: true
        - name: GITHUB_CLIENT_SECRET
          valueFrom:
            secretKeyRef:
              name: github-app-secret
              key: GITHUB_CLIENT_SECRET
              optional: true
        - name: GITHUB_STATE_SECRET
          valueFrom:
            secretKeyRef:
              name: github-app-secret
              key: GITHUB_STATE_SECRET
              optional: true
        # OOTB Workflows Configuration
        - name: OOTB_WORKFLOWS_REPO
          value: "https://github.com/ambient-code/ootb-ambient-workflows.git"
        - name: OOTB_WORKFLOWS_BRANCH
          value: "main"
        - name: OOTB_WORKFLOWS_PATH
          value: "workflows"
        # Backend needs CLAUDE_CODE_USE_VERTEX to expose vertexEnabled flag via /api/cluster-info
        # This allows the frontend to show warnings when ANTHROPIC_API_KEY is configured with Vertex enabled
        # Shares the same config value as the operator for consistency
        - name: CLAUDE_CODE_USE_VERTEX
          valueFrom:
            configMapKeyRef:
              name: operator-config
              key: CLAUDE_CODE_USE_VERTEX
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
        livenessProbe:
          httpGet:
            path: /health
            port: http
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: http
          initialDelaySeconds: 5
          periodSeconds: 5
        volumeMounts:
        - name: backend-state
          mountPath: /workspace
      volumes:
      - name: backend-state
        persistentVolumeClaim:
          claimName: backend-state-pvc
      
---
apiVersion: v1
kind: Service
metadata:
  name: backend-service
  labels:
    app: backend-api
spec:
  selector:
    app: backend-api
  ports:
  - port: 8080
    targetPort: http
    protocol: TCP
    name: http
  type: ClusterIP
</file>

<file path="components/backend/handlers/content.go">
package handlers

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"log"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"ambient-code-backend/git"

	"github.com/gin-gonic/gin"
)

// StateBaseDir is the base directory for content storage
// Set by main during initialization
var StateBaseDir string

// Git operation functions - set by main package during initialization
// These are set to the actual implementations from git package
var (
	GitPushRepo           func(ctx context.Context, repoDir, commitMessage, outputRepoURL, branch, githubToken string) (string, error)
	GitAbandonRepo        func(ctx context.Context, repoDir string) error
	GitDiffRepo           func(ctx context.Context, repoDir string) (*git.DiffSummary, error)
	GitCheckMergeStatus   func(ctx context.Context, repoDir, branch string) (*git.MergeStatus, error)
	GitPullRepo           func(ctx context.Context, repoDir, branch string) error
	GitPushToRepo         func(ctx context.Context, repoDir, branch, commitMessage string) error
	GitCreateBranch       func(ctx context.Context, repoDir, branchName string) error
	GitListRemoteBranches func(ctx context.Context, repoDir string) ([]string, error)
)

// ContentGitPush handles POST /content/github/push in CONTENT_SERVICE_MODE
func ContentGitPush(c *gin.Context) {
	var body struct {
		RepoPath      string `json:"repoPath"`
		CommitMessage string `json:"commitMessage"`
		OutputRepoURL string `json:"outputRepoUrl"`
		Branch        string `json:"branch"`
	}
	_ = c.BindJSON(&body)
	log.Printf("contentGitPush: request received repoPath=%q outputRepoUrl=%q branch=%q commitLen=%d", body.RepoPath, body.OutputRepoURL, body.Branch, len(strings.TrimSpace(body.CommitMessage)))

	// Require explicit output repo URL and branch from caller
	if strings.TrimSpace(body.OutputRepoURL) == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "missing outputRepoUrl"})
		return
	}
	if strings.TrimSpace(body.Branch) == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "missing branch"})
		return
	}

	repoDir := filepath.Clean(filepath.Join(StateBaseDir, body.RepoPath))
	if body.RepoPath == "" {
		repoDir = StateBaseDir
	}

	// Basic safety: repoDir must be under StateBaseDir
	if !strings.HasPrefix(repoDir+string(os.PathSeparator), StateBaseDir+string(os.PathSeparator)) && repoDir != StateBaseDir {
		log.Printf("contentGitPush: invalid repoPath resolved=%q stateBaseDir=%q", repoDir, StateBaseDir)
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid repoPath"})
		return
	}

	log.Printf("contentGitPush: using repoDir=%q (stateBaseDir=%q)", repoDir, StateBaseDir)

	// Optional GitHub token provided by backend via internal header
	gitHubToken := strings.TrimSpace(c.GetHeader("X-GitHub-Token"))
	log.Printf("contentGitPush: tokenHeaderPresent=%t url.host.redacted=%t branch=%q", gitHubToken != "", strings.HasPrefix(body.OutputRepoURL, "https://"), body.Branch)

	// Call refactored git push function
	out, err := GitPushRepo(c.Request.Context(), repoDir, body.CommitMessage, body.OutputRepoURL, body.Branch, gitHubToken)
	if err != nil {
		if out == "" {
			// No changes to commit
			c.JSON(http.StatusOK, gin.H{"ok": true, "message": "no changes"})
			return
		}
		c.JSON(http.StatusBadRequest, gin.H{"error": "push failed", "stderr": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"ok": true, "stdout": out})
}

// ContentGitAbandon handles POST /content/github/abandon
func ContentGitAbandon(c *gin.Context) {
	var body struct {
		RepoPath string `json:"repoPath"`
	}
	_ = c.BindJSON(&body)
	log.Printf("contentGitAbandon: request repoPath=%q", body.RepoPath)

	repoDir := filepath.Clean(filepath.Join(StateBaseDir, body.RepoPath))
	if body.RepoPath == "" {
		repoDir = StateBaseDir
	}

	if !strings.HasPrefix(repoDir+string(os.PathSeparator), StateBaseDir+string(os.PathSeparator)) && repoDir != StateBaseDir {
		log.Printf("contentGitAbandon: invalid repoPath resolved=%q base=%q", repoDir, StateBaseDir)
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid repoPath"})
		return
	}

	log.Printf("contentGitAbandon: using repoDir=%q", repoDir)

	if err := GitAbandonRepo(c.Request.Context(), repoDir); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"ok": true})
}

// ContentGitDiff handles GET /content/github/diff
func ContentGitDiff(c *gin.Context) {
	repoPath := strings.TrimSpace(c.Query("repoPath"))
	if repoPath == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "missing repoPath"})
		return
	}

	repoDir := filepath.Clean(filepath.Join(StateBaseDir, repoPath))
	if !strings.HasPrefix(repoDir+string(os.PathSeparator), StateBaseDir+string(os.PathSeparator)) && repoDir != StateBaseDir {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid repoPath"})
		return
	}

	log.Printf("contentGitDiff: repoPath=%q repoDir=%q", repoPath, repoDir)

	summary, err := GitDiffRepo(c.Request.Context(), repoDir)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			"files": gin.H{
				"added":   0,
				"removed": 0,
			},
			"total_added":   0,
			"total_removed": 0,
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"files": gin.H{
			"added":   summary.FilesAdded,
			"removed": summary.FilesRemoved,
		},
		"total_added":   summary.TotalAdded,
		"total_removed": summary.TotalRemoved,
	})
}

// ContentGitStatus handles GET /content/git-status?path=
func ContentGitStatus(c *gin.Context) {
	path := filepath.Clean("/" + strings.TrimSpace(c.Query("path")))
	if path == "/" || strings.Contains(path, "..") {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid path"})
		return
	}

	abs := filepath.Join(StateBaseDir, path)

	// Check if directory exists
	if info, err := os.Stat(abs); err != nil || !info.IsDir() {
		c.JSON(http.StatusOK, gin.H{
			"initialized": false,
			"hasChanges":  false,
		})
		return
	}

	// Check if git repo exists
	gitDir := filepath.Join(abs, ".git")
	if _, err := os.Stat(gitDir); err != nil {
		c.JSON(http.StatusOK, gin.H{
			"initialized": false,
			"hasChanges":  false,
		})
		return
	}

	// Get git status using existing git package
	summary, err := GitDiffRepo(c.Request.Context(), abs)
	if err != nil {
		log.Printf("ContentGitStatus: git diff failed: %v", err)
		c.JSON(http.StatusOK, gin.H{
			"initialized": true,
			"hasChanges":  false,
		})
		return
	}

	hasChanges := summary.FilesAdded > 0 || summary.FilesRemoved > 0 || summary.TotalAdded > 0 || summary.TotalRemoved > 0

	c.JSON(http.StatusOK, gin.H{
		"initialized":      true,
		"hasChanges":       hasChanges,
		"filesAdded":       summary.FilesAdded,
		"filesRemoved":     summary.FilesRemoved,
		"uncommittedFiles": summary.FilesAdded + summary.FilesRemoved,
		"totalAdded":       summary.TotalAdded,
		"totalRemoved":     summary.TotalRemoved,
	})
}

// ContentGitConfigureRemote handles POST /content/git-configure-remote
// Body: { path: string, remoteURL: string, branch: string }
func ContentGitConfigureRemote(c *gin.Context) {
	var body struct {
		Path      string `json:"path"`
		RemoteURL string `json:"remoteUrl"`
		Branch    string `json:"branch"`
	}

	if err := c.BindJSON(&body); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request body"})
		return
	}

	path := filepath.Clean("/" + body.Path)
	if path == "/" || strings.Contains(path, "..") {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid path"})
		return
	}

	abs := filepath.Join(StateBaseDir, path)

	// Check if directory exists
	if info, err := os.Stat(abs); err != nil || !info.IsDir() {
		c.JSON(http.StatusBadRequest, gin.H{"error": "directory not found"})
		return
	}

	// Initialize git if not already
	gitDir := filepath.Join(abs, ".git")
	if _, err := os.Stat(gitDir); err != nil {
		if err := git.InitRepo(c.Request.Context(), abs); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to initialize git"})
			return
		}
		log.Printf("Initialized git repository at %s", abs)
	}

	// Get GitHub token and inject into URL for authentication
	remoteURL := body.RemoteURL
	gitHubToken := strings.TrimSpace(c.GetHeader("X-GitHub-Token"))
	if gitHubToken != "" {
		if authenticatedURL, err := git.InjectGitHubToken(remoteURL, gitHubToken); err == nil {
			remoteURL = authenticatedURL
			log.Printf("Injected GitHub token into remote URL")
		}
	}

	// Configure remote with authenticated URL
	if err := git.ConfigureRemote(c.Request.Context(), abs, "origin", remoteURL); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to configure remote"})
		return
	}

	log.Printf("Configured remote for %s: %s", abs, body.RemoteURL)

	// Fetch from remote so merge status can be checked
	// This is best-effort - don't fail if fetch fails
	branch := body.Branch
	if branch == "" {
		branch = "main"
	}
	cmd := exec.CommandContext(c.Request.Context(), "git", "fetch", "origin", branch)
	cmd.Dir = abs
	if out, err := cmd.CombinedOutput(); err != nil {
		log.Printf("Initial fetch after configure remote failed (non-fatal): %v (output: %s)", err, string(out))
	} else {
		log.Printf("Fetched origin/%s after configuring remote", branch)
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "remote configured",
		"remote":  body.RemoteURL,
		"branch":  body.Branch,
	})
}

// ContentGitSync handles POST /content/git-sync
// Body: { path: string, message: string, branch: string }
func ContentGitSync(c *gin.Context) {
	var body struct {
		Path    string `json:"path"`
		Message string `json:"message"`
		Branch  string `json:"branch"`
	}

	if err := c.BindJSON(&body); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request body"})
		return
	}

	path := filepath.Clean("/" + body.Path)
	if path == "/" || strings.Contains(path, "..") {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid path"})
		return
	}

	abs := filepath.Join(StateBaseDir, path)

	// Check if git repo exists
	gitDir := filepath.Join(abs, ".git")
	if _, err := os.Stat(gitDir); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "git repository not initialized"})
		return
	}

	// Perform git sync operations
	if err := git.SyncRepo(c.Request.Context(), abs, body.Message, body.Branch); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	log.Printf("Synchronized git repository at %s to branch %s", abs, body.Branch)
	c.JSON(http.StatusOK, gin.H{
		"message": "synchronized successfully",
		"branch":  body.Branch,
	})
}

// ContentWrite handles POST /content/write when running in CONTENT_SERVICE_MODE
func ContentWrite(c *gin.Context) {
	var req struct {
		Path     string `json:"path"`
		Content  string `json:"content"`
		Encoding string `json:"encoding"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		log.Printf("ContentWrite: bind JSON failed: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	log.Printf("ContentWrite: path=%q contentLen=%d encoding=%q StateBaseDir=%q", req.Path, len(req.Content), req.Encoding, StateBaseDir)

	path := filepath.Clean("/" + strings.TrimSpace(req.Path))
	if path == "/" || strings.Contains(path, "..") {
		log.Printf("ContentWrite: invalid path rejected: path=%q", path)
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid path"})
		return
	}
	abs := filepath.Join(StateBaseDir, path)
	log.Printf("ContentWrite: absolute path=%q", abs)

	if err := os.MkdirAll(filepath.Dir(abs), 0755); err != nil {
		log.Printf("ContentWrite: mkdir failed for %q: %v", filepath.Dir(abs), err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to create directory"})
		return
	}
	var data []byte
	if strings.EqualFold(req.Encoding, "base64") {
		b, err := base64.StdEncoding.DecodeString(req.Content)
		if err != nil {
			log.Printf("ContentWrite: base64 decode failed: %v", err)
			c.JSON(http.StatusBadRequest, gin.H{"error": "invalid base64 content"})
			return
		}
		data = b
	} else {
		data = []byte(req.Content)
	}
	if err := os.WriteFile(abs, data, 0644); err != nil {
		log.Printf("ContentWrite: write failed for %q: %v", abs, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to write file"})
		return
	}
	log.Printf("ContentWrite: successfully wrote %d bytes to %q", len(data), abs)
	c.JSON(http.StatusOK, gin.H{"message": "ok"})
}

// ContentRead handles GET /content/file?path=
func ContentRead(c *gin.Context) {
	path := filepath.Clean("/" + strings.TrimSpace(c.Query("path")))
	log.Printf("ContentRead: requested path=%q StateBaseDir=%q", c.Query("path"), StateBaseDir)
	log.Printf("ContentRead: cleaned path=%q", path)

	if path == "/" || strings.Contains(path, "..") {
		log.Printf("ContentRead: invalid path rejected: path=%q", path)
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid path"})
		return
	}
	abs := filepath.Join(StateBaseDir, path)
	log.Printf("ContentRead: absolute path=%q", abs)

	b, err := os.ReadFile(abs)
	if err != nil {
		log.Printf("ContentRead: read failed for %q: %v", abs, err)
		if os.IsNotExist(err) {
			c.JSON(http.StatusNotFound, gin.H{"error": "not found"})
		} else {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "read failed"})
		}
		return
	}
	log.Printf("ContentRead: successfully read %d bytes from %q", len(b), abs)
	c.Data(http.StatusOK, "application/octet-stream", b)
}

// ContentList handles GET /content/list?path=
func ContentList(c *gin.Context) {
	path := filepath.Clean("/" + strings.TrimSpace(c.Query("path")))
	log.Printf("ContentList: requested path=%q", c.Query("path"))
	log.Printf("ContentList: cleaned path=%q", path)
	log.Printf("ContentList: StateBaseDir=%q", StateBaseDir)

	if path == "/" || strings.Contains(path, "..") {
		log.Printf("ContentList: invalid path rejected: path=%q", path)
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid path"})
		return
	}
	abs := filepath.Join(StateBaseDir, path)
	log.Printf("ContentList: absolute path=%q", abs)

	info, err := os.Stat(abs)
	if err != nil {
		log.Printf("ContentList: stat failed for %q: %v", abs, err)
		if os.IsNotExist(err) {
			c.JSON(http.StatusNotFound, gin.H{"error": "not found"})
		} else {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "stat failed"})
		}
		return
	}
	if !info.IsDir() {
		// If it's a file, return single entry metadata
		c.JSON(http.StatusOK, gin.H{"items": []gin.H{{
			"name":       filepath.Base(abs),
			"path":       path,
			"isDir":      false,
			"size":       info.Size(),
			"modifiedAt": info.ModTime().UTC().Format(time.RFC3339),
		}}})
		return
	}
	entries, err := os.ReadDir(abs)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "readdir failed"})
		return
	}
	items := make([]gin.H, 0, len(entries))
	for _, e := range entries {
		info, _ := e.Info()
		items = append(items, gin.H{
			"name":       e.Name(),
			"path":       filepath.Join(path, e.Name()),
			"isDir":      e.IsDir(),
			"size":       info.Size(),
			"modifiedAt": info.ModTime().UTC().Format(time.RFC3339),
		})
	}
	log.Printf("ContentList: returning %d items for path=%q", len(items), path)
	c.JSON(http.StatusOK, gin.H{"items": items})
}

// ContentWorkflowMetadata handles GET /content/workflow-metadata?session=
// Parses .claude/commands/*.md and .claude/agents/*.md files from active workflow
func ContentWorkflowMetadata(c *gin.Context) {
	sessionName := c.Query("session")
	if sessionName == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "missing session parameter"})
		return
	}

	log.Printf("ContentWorkflowMetadata: session=%q", sessionName)

	// Find active workflow directory
	workflowDir := findActiveWorkflowDir(sessionName)
	if workflowDir == "" {
		log.Printf("ContentWorkflowMetadata: no active workflow found for session=%q", sessionName)
		c.JSON(http.StatusOK, gin.H{
			"commands": []interface{}{},
			"agents":   []interface{}{},
			"config":   gin.H{"artifactsDir": "artifacts"}, // Default platform folder when no workflow
		})
		return
	}

	log.Printf("ContentWorkflowMetadata: found workflow at %q", workflowDir)

	// Parse ambient.json configuration
	ambientConfig := parseAmbientConfig(workflowDir)

	// Parse commands from .claude/commands/*.md
	commandsDir := filepath.Join(workflowDir, ".claude", "commands")
	commands := []map[string]interface{}{}

	if files, err := os.ReadDir(commandsDir); err == nil {
		for _, file := range files {
			if !file.IsDir() && strings.HasSuffix(file.Name(), ".md") {
				filePath := filepath.Join(commandsDir, file.Name())
				metadata := parseFrontmatter(filePath)
				commandName := strings.TrimSuffix(file.Name(), ".md")

				displayName := metadata["displayName"]
				if displayName == "" {
					displayName = commandName
				}

				// Extract short command (last segment after final dot)
				shortCommand := commandName
				if lastDot := strings.LastIndex(commandName, "."); lastDot != -1 {
					shortCommand = commandName[lastDot+1:]
				}

				commands = append(commands, map[string]interface{}{
					"id":           commandName,
					"name":         displayName,
					"description":  metadata["description"],
					"slashCommand": "/" + shortCommand,
					"icon":         metadata["icon"],
				})
			}
		}
		log.Printf("ContentWorkflowMetadata: found %d commands", len(commands))
	} else {
		log.Printf("ContentWorkflowMetadata: commands directory not found or unreadable: %v", err)
	}

	// Parse agents from .claude/agents/*.md
	agentsDir := filepath.Join(workflowDir, ".claude", "agents")
	agents := []map[string]interface{}{}

	if files, err := os.ReadDir(agentsDir); err == nil {
		for _, file := range files {
			if !file.IsDir() && strings.HasSuffix(file.Name(), ".md") {
				filePath := filepath.Join(agentsDir, file.Name())
				metadata := parseFrontmatter(filePath)
				agentID := strings.TrimSuffix(file.Name(), ".md")

				agents = append(agents, map[string]interface{}{
					"id":          agentID,
					"name":        metadata["name"],
					"description": metadata["description"],
					"tools":       metadata["tools"],
				})
			}
		}
		log.Printf("ContentWorkflowMetadata: found %d agents", len(agents))
	} else {
		log.Printf("ContentWorkflowMetadata: agents directory not found or unreadable: %v", err)
	}

	c.JSON(http.StatusOK, gin.H{
		"commands": commands,
		"agents":   agents,
		"config": gin.H{
			"name":         ambientConfig.Name,
			"description":  ambientConfig.Description,
			"systemPrompt": ambientConfig.SystemPrompt,
			"artifactsDir": ambientConfig.ArtifactsDir,
		},
	})
}

// parseFrontmatter extracts YAML frontmatter from a markdown file
func parseFrontmatter(filePath string) map[string]string {
	content, err := os.ReadFile(filePath)
	if err != nil {
		log.Printf("parseFrontmatter: failed to read %q: %v", filePath, err)
		return map[string]string{}
	}

	str := string(content)
	if !strings.HasPrefix(str, "---\n") {
		return map[string]string{}
	}

	// Find end of frontmatter
	endIdx := strings.Index(str[4:], "\n---")
	if endIdx == -1 {
		return map[string]string{}
	}

	frontmatter := str[4 : 4+endIdx]
	result := map[string]string{}

	// Simple key: value parsing
	for _, line := range strings.Split(frontmatter, "\n") {
		if strings.TrimSpace(line) == "" {
			continue
		}
		parts := strings.SplitN(line, ":", 2)
		if len(parts) == 2 {
			key := strings.TrimSpace(parts[0])
			value := strings.Trim(strings.TrimSpace(parts[1]), "\"'")
			result[key] = value
		}
	}

	return result
}

// AmbientConfig represents the ambient.json configuration
type AmbientConfig struct {
	Name         string `json:"name"`
	Description  string `json:"description"`
	SystemPrompt string `json:"systemPrompt"`
	ArtifactsDir string `json:"artifactsDir"`
}

// parseAmbientConfig reads and parses ambient.json from workflow directory
// Returns default config if file doesn't exist (not an error)
// For custom workflows without ambient.json, returns empty artifactsDir (root directory)
// allowing them to manage their own structure
func parseAmbientConfig(workflowDir string) *AmbientConfig {
	configPath := filepath.Join(workflowDir, ".ambient", "ambient.json")

	// Check if file exists
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		log.Printf("parseAmbientConfig: no ambient.json found at %q, using defaults", configPath)
		return &AmbientConfig{
			ArtifactsDir: "", // Empty string means root (custom workflows manage their own structure)
		}
	}

	// Read file
	data, err := os.ReadFile(configPath)
	if err != nil {
		log.Printf("parseAmbientConfig: failed to read %q: %v", configPath, err)
		return &AmbientConfig{ArtifactsDir: ""}
	}

	// Parse JSON
	var config AmbientConfig
	if err := json.Unmarshal(data, &config); err != nil {
		log.Printf("parseAmbientConfig: failed to parse JSON from %q: %v", configPath, err)
		return &AmbientConfig{ArtifactsDir: ""}
	}

	log.Printf("parseAmbientConfig: loaded config: name=%q artifactsDir=%q", config.Name, config.ArtifactsDir)
	return &config
}

// findActiveWorkflowDir finds the active workflow directory for a session
func findActiveWorkflowDir(sessionName string) string {
	// Workflows are stored at {StateBaseDir}/sessions/{session-name}/workspace/workflows/{workflow-name}
	// The runner creates this nested structure
	workflowsBase := filepath.Join(StateBaseDir, "sessions", sessionName, "workspace", "workflows")

	entries, err := os.ReadDir(workflowsBase)
	if err != nil {
		log.Printf("findActiveWorkflowDir: failed to read workflows directory %q: %v", workflowsBase, err)
		return ""
	}

	// Find first directory that has .claude subdirectory (excluding temp clones)
	for _, entry := range entries {
		if entry.IsDir() && entry.Name() != "default" && !strings.HasSuffix(entry.Name(), "-clone-temp") {
			claudeDir := filepath.Join(workflowsBase, entry.Name(), ".claude")
			if stat, err := os.Stat(claudeDir); err == nil && stat.IsDir() {
				return filepath.Join(workflowsBase, entry.Name())
			}
		}
	}

	return ""
}

// ContentGitMergeStatus handles GET /content/git-merge-status?path=&branch=
func ContentGitMergeStatus(c *gin.Context) {
	path := filepath.Clean("/" + strings.TrimSpace(c.Query("path")))
	branch := strings.TrimSpace(c.Query("branch"))

	if path == "/" || strings.Contains(path, "..") {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid path"})
		return
	}

	if branch == "" {
		branch = "main"
	}

	abs := filepath.Join(StateBaseDir, path)

	// Check if git repo exists
	gitDir := filepath.Join(abs, ".git")
	if _, err := os.Stat(gitDir); err != nil {
		c.JSON(http.StatusOK, gin.H{
			"canMergeClean":      true,
			"localChanges":       0,
			"remoteCommitsAhead": 0,
			"conflictingFiles":   []string{},
			"remoteBranchExists": false,
		})
		return
	}

	status, err := GitCheckMergeStatus(c.Request.Context(), abs, branch)
	if err != nil {
		log.Printf("ContentGitMergeStatus: check failed: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, status)
}

// ContentGitPull handles POST /content/git-pull
// Body: { path: string, branch: string }
func ContentGitPull(c *gin.Context) {
	var body struct {
		Path   string `json:"path"`
		Branch string `json:"branch"`
	}

	if err := c.BindJSON(&body); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request body"})
		return
	}

	path := filepath.Clean("/" + body.Path)
	if path == "/" || strings.Contains(path, "..") {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid path"})
		return
	}

	if body.Branch == "" {
		body.Branch = "main"
	}

	abs := filepath.Join(StateBaseDir, path)

	if err := GitPullRepo(c.Request.Context(), abs, body.Branch); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	log.Printf("Pulled changes from origin/%s in %s", body.Branch, abs)
	c.JSON(http.StatusOK, gin.H{"message": "pulled successfully", "branch": body.Branch})
}

// ContentGitPushToBranch handles POST /content/git-push
// Body: { path: string, branch: string, message: string }
func ContentGitPushToBranch(c *gin.Context) {
	var body struct {
		Path    string `json:"path"`
		Branch  string `json:"branch"`
		Message string `json:"message"`
	}

	if err := c.BindJSON(&body); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request body"})
		return
	}

	path := filepath.Clean("/" + body.Path)
	if path == "/" || strings.Contains(path, "..") {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid path"})
		return
	}

	if body.Branch == "" {
		body.Branch = "main"
	}

	if body.Message == "" {
		body.Message = "Session artifacts update"
	}

	abs := filepath.Join(StateBaseDir, path)

	if err := GitPushToRepo(c.Request.Context(), abs, body.Branch, body.Message); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	log.Printf("Pushed changes to origin/%s in %s", body.Branch, abs)
	c.JSON(http.StatusOK, gin.H{"message": "pushed successfully", "branch": body.Branch})
}

// ContentGitCreateBranch handles POST /content/git-create-branch
// Body: { path: string, branchName: string }
func ContentGitCreateBranch(c *gin.Context) {
	var body struct {
		Path       string `json:"path"`
		BranchName string `json:"branchName"`
	}

	if err := c.BindJSON(&body); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request body"})
		return
	}

	path := filepath.Clean("/" + body.Path)
	if path == "/" || strings.Contains(path, "..") {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid path"})
		return
	}

	if body.BranchName == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "branchName is required"})
		return
	}

	abs := filepath.Join(StateBaseDir, path)

	if err := GitCreateBranch(c.Request.Context(), abs, body.BranchName); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	log.Printf("Created branch %s in %s", body.BranchName, abs)
	c.JSON(http.StatusOK, gin.H{"message": "branch created", "branchName": body.BranchName})
}

// ContentGitListBranches handles GET /content/git-list-branches?path=
func ContentGitListBranches(c *gin.Context) {
	path := filepath.Clean("/" + strings.TrimSpace(c.Query("path")))

	if path == "/" || strings.Contains(path, "..") {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid path"})
		return
	}

	abs := filepath.Join(StateBaseDir, path)

	branches, err := GitListRemoteBranches(c.Request.Context(), abs)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"branches": branches})
}
</file>

<file path="components/backend/handlers/projects.go">
package handlers

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"os"
	"regexp"
	"strings"
	"sync"
	"time"

	"ambient-code-backend/types"

	"github.com/gin-gonic/gin"
	authv1 "k8s.io/api/authorization/v1"
	corev1 "k8s.io/api/core/v1"
	rbacv1 "k8s.io/api/rbac/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	k8stypes "k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/dynamic"
	"k8s.io/client-go/kubernetes"
)

// Package-level variables for project handlers (set from main package)
var (
	// GetOpenShiftProjectResource returns the GVR for OpenShift Project resources
	GetOpenShiftProjectResource func() schema.GroupVersionResource
	// K8sClientProjects is the backend service account client used for namespace operations
	// that require elevated permissions (e.g., creating namespaces, assigning roles)
	K8sClientProjects *kubernetes.Clientset
	// DynamicClientProjects is the backend SA dynamic client for OpenShift Project operations
	DynamicClientProjects dynamic.Interface
)

var (
	isOpenShiftCache bool
	isOpenShiftOnce  sync.Once
)

// Default timeout for Kubernetes API operations
const defaultK8sTimeout = 10 * time.Second

// Retry configuration constants
const (
	projectRetryAttempts     = 5
	projectRetryInitialDelay = 200 * time.Millisecond
	projectRetryMaxDelay     = 2 * time.Second
)

// Kubernetes namespace name validation pattern
var namespaceNamePattern = regexp.MustCompile(`^[a-z0-9]([-a-z0-9]*[a-z0-9])?$`)

// validateProjectName validates a project/namespace name according to Kubernetes naming rules
func validateProjectName(name string) error {
	if name == "" {
		return fmt.Errorf("project name is required")
	}
	if len(name) > 63 {
		return fmt.Errorf("project name must be 63 characters or less")
	}
	if !namespaceNamePattern.MatchString(name) {
		return fmt.Errorf("project name must be lowercase alphanumeric with hyphens (cannot start or end with hyphen)")
	}
	// Reserved namespaces
	reservedNames := map[string]bool{
		"default": true, "kube-system": true, "kube-public": true, "kube-node-lease": true,
		"openshift": true, "openshift-infra": true, "openshift-node": true,
	}
	if reservedNames[name] {
		return fmt.Errorf("project name '%s' is reserved and cannot be used", name)
	}
	return nil
}

// sanitizeForK8sName converts a user subject to a valid Kubernetes resource name
func sanitizeForK8sName(subject string) string {
	// Remove system:serviceaccount: prefix if present
	subject = strings.TrimPrefix(subject, "system:serviceaccount:")

	// Replace invalid characters with hyphens
	reg := regexp.MustCompile(`[^a-z0-9-]`)
	sanitized := reg.ReplaceAllString(strings.ToLower(subject), "-")

	// Remove leading/trailing hyphens
	sanitized = strings.Trim(sanitized, "-")

	// Ensure it doesn't exceed 63 chars (leave room for prefix)
	if len(sanitized) > 40 {
		sanitized = sanitized[:40]
	}

	return sanitized
}

// isOpenShiftCluster detects if we're running on OpenShift by checking for the project.openshift.io API group
// Results are cached using sync.Once for thread-safe, race-free initialization
func isOpenShiftCluster() bool {
	isOpenShiftOnce.Do(func() {
		if K8sClientProjects == nil {
			log.Printf("K8s client not initialized, assuming vanilla Kubernetes")
			isOpenShiftCache = false
			return
		}

		// Try to list API groups and look for project.openshift.io
		groups, err := K8sClientProjects.Discovery().ServerGroups()
		if err != nil {
			log.Printf("Failed to detect OpenShift (assuming vanilla Kubernetes): %v", err)
			isOpenShiftCache = false
			return
		}

		for _, group := range groups.Groups {
			if group.Name == "project.openshift.io" {
				log.Printf("Detected OpenShift cluster")
				isOpenShiftCache = true
				return
			}
		}

		log.Printf("Detected vanilla Kubernetes cluster")
		isOpenShiftCache = false
	})
	return isOpenShiftCache
}

// GetClusterInfo handles GET /cluster-info
// Returns information about the cluster type (OpenShift vs vanilla Kubernetes)
// and whether Vertex AI is enabled
// This endpoint does not require authentication as it's public cluster information
func GetClusterInfo(c *gin.Context) {
	isOpenShift := isOpenShiftCluster()
	vertexEnabled := os.Getenv("CLAUDE_CODE_USE_VERTEX") == "1"

	c.JSON(http.StatusOK, gin.H{
		"isOpenShift":   isOpenShift,
		"vertexEnabled": vertexEnabled,
	})
}

// ListProjects handles GET /projects
// Lists Namespaces (both platforms) using backend SA with label selector,
// then uses SubjectAccessReview to verify user access to each namespace
func ListProjects(c *gin.Context) {
	reqK8s, _ := GetK8sClientsForRequest(c)

	if reqK8s == nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid or missing token"})
		return
	}

	// List namespaces using backend SA (both platforms)
	if K8sClientProjects == nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list projects"})
		return
	}

	isOpenShift := isOpenShiftCluster()
	projects := []types.AmbientProject{}

	ctx, cancel := context.WithTimeout(context.Background(), defaultK8sTimeout)
	defer cancel()

	nsList, err := K8sClientProjects.CoreV1().Namespaces().List(ctx, v1.ListOptions{
		LabelSelector: "ambient-code.io/managed=true",
	})
	if err != nil {
		log.Printf("Failed to list Namespaces: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list projects"})
		return
	}

	// Filter to only namespaces where user has access
	// Use SubjectAccessReview - checks ALL RBAC sources (any RoleBinding, group, etc.)
	for _, ns := range nsList.Items {
		hasAccess, err := checkUserCanAccessNamespace(reqK8s, ns.Name)
		if err != nil {
			log.Printf("Failed to check access for namespace %s: %v", ns.Name, err)
			continue
		}

		if hasAccess {
			projects = append(projects, projectFromNamespace(&ns, isOpenShift))
		}
	}

	c.JSON(http.StatusOK, gin.H{"items": projects})
}

// projectFromNamespace converts a Kubernetes Namespace to AmbientProject
// On OpenShift, extracts displayName and description from namespace annotations
func projectFromNamespace(ns *corev1.Namespace, isOpenShift bool) types.AmbientProject {
	status := "Active"
	if ns.Status.Phase != corev1.NamespaceActive {
		status = string(ns.Status.Phase)
	}

	displayName := ""
	description := ""

	// On OpenShift, extract display metadata from annotations
	if isOpenShift && ns.Annotations != nil {
		displayName = ns.Annotations["openshift.io/display-name"]
		description = ns.Annotations["openshift.io/description"]
	}

	return types.AmbientProject{
		Name:              ns.Name,
		DisplayName:       displayName,
		Description:       description,
		Labels:            ns.Labels,
		Annotations:       ns.Annotations,
		CreationTimestamp: ns.CreationTimestamp.Format(time.RFC3339),
		Status:            status,
		IsOpenShift:       isOpenShift,
	}
}

// CreateProject handles POST /projects
// Unified approach for both Kubernetes and OpenShift:
// 1. Creates namespace using backend SA (both platforms)
// 2. Assigns ambient-project-admin ClusterRole to creator via RoleBinding (both platforms)
//
// The ClusterRole is namespace-scoped via the RoleBinding, giving the user admin access
// only to their specific project namespace.
func CreateProject(c *gin.Context) {
	reqK8s, _ := GetK8sClientsForRequest(c)

	// Validate that user authentication succeeded
	if reqK8s == nil {
		log.Printf("CreateProject: Invalid or missing authentication token")
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid or missing token"})
		return
	}

	var req types.CreateProjectRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Validate project name
	if err := validateProjectName(req.Name); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Extract user identity from token
	userSubject, err := getUserSubjectFromContext(c)
	if err != nil {
		log.Printf("CreateProject: Failed to extract user subject: %v", err)
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
		return
	}

	isOpenShift := isOpenShiftCluster()

	// Create namespace using backend SA (users don't have cluster-level permissions)
	ns := &corev1.Namespace{
		ObjectMeta: v1.ObjectMeta{
			Name: req.Name,
			Labels: map[string]string{
				"ambient-code.io/managed": "true",
			},
			Annotations: map[string]string{},
		},
	}

	// Add OpenShift-specific annotations if on OpenShift
	if isOpenShift {
		// Use displayName if provided, otherwise use name
		displayName := req.DisplayName
		if displayName == "" {
			displayName = req.Name
		}
		ns.Annotations["openshift.io/display-name"] = displayName
		if req.Description != "" {
			ns.Annotations["openshift.io/description"] = req.Description
		}
		ns.Annotations["openshift.io/requester"] = userSubject
	}

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	createdNs, err := K8sClientProjects.CoreV1().Namespaces().Create(ctx, ns, v1.CreateOptions{})
	if err != nil {
		log.Printf("Failed to create namespace %s: %v", req.Name, err)
		if errors.IsAlreadyExists(err) {
			c.JSON(http.StatusConflict, gin.H{"error": "Project already exists"})
		} else if errors.IsForbidden(err) {
			c.JSON(http.StatusForbidden, gin.H{"error": "Insufficient permissions to create project"})
		} else {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create project"})
		}
		return
	}

	// Assign ambient-project-admin ClusterRole to the creator in the namespace
	// Use deterministic name based on user to avoid conflicts with multiple admins
	roleBindingName := fmt.Sprintf("ambient-admin-%s", sanitizeForK8sName(userSubject))

	roleBinding := &rbacv1.RoleBinding{
		ObjectMeta: v1.ObjectMeta{
			Name:      roleBindingName,
			Namespace: req.Name,
			Labels: map[string]string{
				"ambient-code.io/role": "admin",
			},
		},
		RoleRef: rbacv1.RoleRef{
			APIGroup: "rbac.authorization.k8s.io",
			Kind:     "ClusterRole",
			Name:     "ambient-project-admin",
		},
		Subjects: []rbacv1.Subject{
			{
				Kind:     getUserSubjectKind(userSubject),
				Name:     getUserSubjectName(userSubject),
				APIGroup: "rbac.authorization.k8s.io",
			},
		},
	}

	// Add namespace for ServiceAccount subjects
	if getUserSubjectKind(userSubject) == "ServiceAccount" {
		roleBinding.Subjects[0].Namespace = getUserSubjectNamespace(userSubject)
		roleBinding.Subjects[0].APIGroup = ""
	}

	ctx2, cancel2 := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel2()

	_, err = K8sClientProjects.RbacV1().RoleBindings(req.Name).Create(ctx2, roleBinding, v1.CreateOptions{})
	if err != nil {
		log.Printf("ERROR: Created namespace %s but failed to assign admin role: %v", req.Name, err)

		// ROLLBACK: Delete the namespace since role binding failed
		// Without the role binding, the user won't have access to their project
		ctx3, cancel3 := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel3()

		deleteErr := K8sClientProjects.CoreV1().Namespaces().Delete(ctx3, req.Name, v1.DeleteOptions{})
		if deleteErr != nil {
			log.Printf("CRITICAL: Failed to rollback namespace %s after role binding failure: %v", req.Name, deleteErr)

			// Label the namespace as orphaned for manual cleanup
			patch := []byte(`{"metadata":{"labels":{"ambient-code.io/orphaned":"true","ambient-code.io/orphan-reason":"role-binding-failed"}}}`)
			ctx4, cancel4 := context.WithTimeout(context.Background(), 5*time.Second)
			defer cancel4()

			_, labelErr := K8sClientProjects.CoreV1().Namespaces().Patch(
				ctx4, req.Name, k8stypes.MergePatchType, patch, v1.PatchOptions{},
			)
			if labelErr != nil {
				log.Printf("CRITICAL: Failed to label orphaned namespace %s: %v", req.Name, labelErr)
			} else {
				log.Printf("Labeled orphaned namespace %s for manual cleanup", req.Name)
			}
		}

		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create project permissions"})
		return
	}

	// On OpenShift: Update the Project resource with display metadata
	// Use retry logic as OpenShift needs time to create the Project resource from the namespace
	// Use backend SA dynamic client (users don't have permission to update Project resources)
	if isOpenShift && DynamicClientProjects != nil {
		projGvr := GetOpenShiftProjectResource()

		// Retry getting and updating the Project resource (OpenShift creates it asynchronously)
		retryErr := RetryWithBackoff(projectRetryAttempts, projectRetryInitialDelay, projectRetryMaxDelay, func() error {
			ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
			defer cancel()

			// Get the Project resource (using backend SA)
			projObj, err := DynamicClientProjects.Resource(projGvr).Get(ctx, req.Name, v1.GetOptions{})
			if err != nil {
				return fmt.Errorf("failed to get Project resource: %w", err)
			}

			// Update Project annotations with display metadata
			unstruct := projObj // Reference to unstructured object
			meta, ok := unstruct.Object["metadata"].(map[string]interface{})
			if !ok || meta == nil {
				meta = map[string]interface{}{}
				projObj.Object["metadata"] = meta
			}
			anns, ok := meta["annotations"].(map[string]interface{})
			if !ok || anns == nil {
				anns = map[string]interface{}{}
				meta["annotations"] = anns
			}

			// Use displayName if provided, otherwise use name
			displayName := req.DisplayName
			if displayName == "" {
				displayName = req.Name
			}
			anns["openshift.io/display-name"] = displayName
			if req.Description != "" {
				anns["openshift.io/description"] = req.Description
			}
			anns["openshift.io/requester"] = userSubject

			ctx2, cancel2 := context.WithTimeout(context.Background(), 5*time.Second)
			defer cancel2()

			// Update using backend SA (users don't have Project update permission)
			_, err = DynamicClientProjects.Resource(projGvr).Update(ctx2, projObj, v1.UpdateOptions{})
			if err != nil {
				return fmt.Errorf("failed to update Project annotations: %w", err)
			}

			return nil
		})

		if retryErr != nil {
			log.Printf("WARNING: Failed to update Project resource for %s after retries: %v", req.Name, retryErr)
		} else {
			log.Printf("Successfully updated Project resource with display metadata for %s", req.Name)
		}
	}

	// Build response
	responseDisplayName := ""
	if isOpenShift {
		responseDisplayName = req.DisplayName
		if responseDisplayName == "" {
			responseDisplayName = req.Name
		}
	}

	project := types.AmbientProject{
		Name:              createdNs.Name,
		DisplayName:       responseDisplayName,
		Description:       req.Description,
		Labels:            createdNs.Labels,
		Annotations:       createdNs.Annotations,
		CreationTimestamp: createdNs.CreationTimestamp.Format(time.RFC3339),
		Status:            "Active",
		IsOpenShift:       isOpenShift,
	}

	c.JSON(http.StatusCreated, project)
}

// GetProject handles GET /projects/:projectName
// Returns Namespace details with OpenShift annotations if on OpenShift
func GetProject(c *gin.Context) {
	projectName := c.Param("projectName")
	reqK8s, _ := GetK8sClientsForRequest(c)

	if reqK8s == nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid or missing token"})
		return
	}

	isOpenShift := isOpenShiftCluster()

	// Get namespace using backend SA
	if K8sClientProjects == nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get project"})
		return
	}

	ctx, cancel := context.WithTimeout(context.Background(), defaultK8sTimeout)
	defer cancel()

	ns, err := K8sClientProjects.CoreV1().Namespaces().Get(ctx, projectName, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			c.JSON(http.StatusNotFound, gin.H{"error": "Project not found"})
			return
		}
		log.Printf("Failed to get Namespace %s: %v", projectName, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get project"})
		return
	}

	// Validate it's an Ambient-managed namespace
	if ns.Labels["ambient-code.io/managed"] != "true" {
		log.Printf("SECURITY: User attempted to access non-managed namespace: %s", projectName)
		c.JSON(http.StatusNotFound, gin.H{"error": "Project not found or not an Ambient project"})
		return
	}

	// Verify user can view the project (GET projectsettings)
	canView, err := checkUserCanViewProject(reqK8s, projectName)
	if err != nil {
		log.Printf("GetProject: Failed to check access for %s: %v", projectName, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to verify permissions"})
		return
	}

	if !canView {
		log.Printf("User attempted to view project %s without GET projectsettings permission", projectName)
		c.JSON(http.StatusForbidden, gin.H{"error": "Unauthorized to view project"})
		return
	}

	project := projectFromNamespace(ns, isOpenShift)
	c.JSON(http.StatusOK, project)
}

// UpdateProject handles PUT /projects/:projectName
// On OpenShift: Updates namespace annotations for display name/description
// On Kubernetes: No-op (k8s namespaces don't have display metadata)
func UpdateProject(c *gin.Context) {
	projectName := c.Param("projectName")
	reqK8s, _ := GetK8sClientsForRequest(c)

	if reqK8s == nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid or missing token"})
		return
	}

	var req struct {
		Name        string `json:"name"`
		DisplayName string `json:"displayName"`
		Description string `json:"description"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	if req.Name != "" && req.Name != projectName {
		c.JSON(http.StatusBadRequest, gin.H{"error": "project name in URL does not match request body"})
		return
	}

	isOpenShift := isOpenShiftCluster()

	// Get namespace using backend SA
	if K8sClientProjects == nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update project"})
		return
	}

	ctx, cancel := context.WithTimeout(context.Background(), defaultK8sTimeout)
	defer cancel()

	ns, err := K8sClientProjects.CoreV1().Namespaces().Get(ctx, projectName, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			c.JSON(http.StatusNotFound, gin.H{"error": "Project not found"})
			return
		}
		log.Printf("Failed to get Namespace %s: %v", projectName, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get project"})
		return
	}

	// Validate it's an Ambient-managed namespace
	if ns.Labels["ambient-code.io/managed"] != "true" {
		log.Printf("SECURITY: User attempted to update non-managed namespace: %s", projectName)
		c.JSON(http.StatusNotFound, gin.H{"error": "Project not found or not an Ambient project"})
		return
	}

	// Verify user can modify the project (UPDATE projectsettings)
	canModify, err := checkUserCanModifyProject(reqK8s, projectName)
	if err != nil {
		log.Printf("UpdateProject: Failed to check access for %s: %v", projectName, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to verify permissions"})
		return
	}

	if !canModify {
		log.Printf("User attempted to update project %s without UPDATE projectsettings permission", projectName)
		c.JSON(http.StatusForbidden, gin.H{"error": "Unauthorized to update project"})
		return
	}

	// On OpenShift: Update namespace annotations (backend SA needed for namespace updates)
	if isOpenShift && K8sClientProjects != nil {
		if req.DisplayName != "" {
			if ns.Annotations == nil {
				ns.Annotations = make(map[string]string)
			}
			ns.Annotations["openshift.io/display-name"] = req.DisplayName
		}
		if req.Description != "" {
			if ns.Annotations == nil {
				ns.Annotations = make(map[string]string)
			}
			ns.Annotations["openshift.io/description"] = req.Description
		}

		ctx2, cancel2 := context.WithTimeout(context.Background(), defaultK8sTimeout)
		defer cancel2()

		// Update using backend SA (users can't update namespace annotations)
		_, err = K8sClientProjects.CoreV1().Namespaces().Update(ctx2, ns, v1.UpdateOptions{})
		if err != nil {
			log.Printf("Failed to update Namespace annotations for %s: %v", projectName, err)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update project"})
			return
		}

		// Read back the updated namespace
		ctx3, cancel3 := context.WithTimeout(context.Background(), defaultK8sTimeout)
		defer cancel3()

		ns, _ = K8sClientProjects.CoreV1().Namespaces().Get(ctx3, projectName, v1.GetOptions{})
	}

	project := projectFromNamespace(ns, isOpenShift)
	c.JSON(http.StatusOK, project)
}

// DeleteProject handles DELETE /projects/:projectName
// Verifies user has access, then uses backend SA to delete namespace (both platforms)
// Namespace deletion is cluster-scoped, so regular users can't delete directly
func DeleteProject(c *gin.Context) {
	projectName := c.Param("projectName")
	reqK8s, _ := GetK8sClientsForRequest(c)

	if reqK8s == nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid or missing token"})
		return
	}

	ctx, cancel := context.WithTimeout(context.Background(), defaultK8sTimeout)
	defer cancel()

	// Verify namespace exists and is Ambient-managed (using backend SA)
	if K8sClientProjects == nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete project"})
		return
	}

	ns, err := K8sClientProjects.CoreV1().Namespaces().Get(ctx, projectName, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			c.JSON(http.StatusNotFound, gin.H{"error": "Project not found"})
			return
		}
		log.Printf("Failed to get namespace %s: %v", projectName, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get project"})
		return
	}

	// Validate it's an Ambient-managed namespace
	if ns.Labels["ambient-code.io/managed"] != "true" {
		log.Printf("SECURITY: User attempted to delete non-managed namespace: %s", projectName)
		c.JSON(http.StatusNotFound, gin.H{"error": "Project not found or not an Ambient project"})
		return
	}

	// Verify user can modify the project (UPDATE projectsettings)
	canModify, err := checkUserCanModifyProject(reqK8s, projectName)
	if err != nil {
		log.Printf("DeleteProject: Failed to check access for %s: %v", projectName, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to verify permissions"})
		return
	}

	if !canModify {
		log.Printf("User attempted to delete project %s without UPDATE projectsettings permission", projectName)
		c.JSON(http.StatusForbidden, gin.H{"error": "Insufficient permissions to delete project"})
		return
	}

	// Delete the namespace using backend SA (after verifying user has access)
	ctx2, cancel2 := context.WithTimeout(context.Background(), defaultK8sTimeout)
	defer cancel2()

	err = K8sClientProjects.CoreV1().Namespaces().Delete(ctx2, projectName, v1.DeleteOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			c.JSON(http.StatusNotFound, gin.H{"error": "Project not found"})
			return
		}
		log.Printf("Failed to delete namespace %s: %v", projectName, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete project"})
		return
	}

	c.Status(http.StatusNoContent)
}

// checkUserCanViewProject checks if user can GET projectsettings in the namespace
// This determines if they can view the project/namespace details
func checkUserCanViewProject(userClient *kubernetes.Clientset, namespace string) (bool, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
	defer cancel()

	ssar := &authv1.SelfSubjectAccessReview{
		Spec: authv1.SelfSubjectAccessReviewSpec{
			ResourceAttributes: &authv1.ResourceAttributes{
				Namespace: namespace,
				Verb:      "get",
				Group:     "vteam.ambient-code",
				Resource:  "projectsettings",
			},
		},
	}

	result, err := userClient.AuthorizationV1().SelfSubjectAccessReviews().Create(ctx, ssar, v1.CreateOptions{})
	if err != nil {
		return false, err
	}

	return result.Status.Allowed, nil
}

// checkUserCanModifyProject checks if user can UPDATE projectsettings in the namespace
// This determines if they can update or delete the project/namespace
func checkUserCanModifyProject(userClient *kubernetes.Clientset, namespace string) (bool, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
	defer cancel()

	ssar := &authv1.SelfSubjectAccessReview{
		Spec: authv1.SelfSubjectAccessReviewSpec{
			ResourceAttributes: &authv1.ResourceAttributes{
				Namespace: namespace,
				Verb:      "update",
				Group:     "vteam.ambient-code",
				Resource:  "projectsettings",
			},
		},
	}

	result, err := userClient.AuthorizationV1().SelfSubjectAccessReviews().Create(ctx, ssar, v1.CreateOptions{})
	if err != nil {
		return false, err
	}

	return result.Status.Allowed, nil
}

// checkUserCanAccessNamespace uses SelfSubjectAccessReview to verify if user can access a namespace
// This is the proper Kubernetes-native way - lets RBAC engine determine access from ALL sources
// (RoleBindings, ClusterRoleBindings, groups, etc.)
// Deprecated: Use checkUserCanViewProject or checkUserCanModifyProject instead
func checkUserCanAccessNamespace(userClient *kubernetes.Clientset, namespace string) (bool, error) {
	// For backward compatibility, check if user can list agenticsessions
	return checkUserCanViewProject(userClient, namespace)
}

// getUserSubjectFromContext extracts the user subject from the JWT token in the request
// Returns subject in format like "user@example.com" or "system:serviceaccount:namespace:name"
func getUserSubjectFromContext(c *gin.Context) (string, error) {
	// Try to extract from ServiceAccount first
	ns, saName, ok := ExtractServiceAccountFromAuth(c)
	if ok {
		return fmt.Sprintf("system:serviceaccount:%s:%s", ns, saName), nil
	}

	// Otherwise try to get from context (set by middleware)
	if userName, exists := c.Get("userName"); exists && userName != nil {
		return fmt.Sprintf("%v", userName), nil
	}
	if userID, exists := c.Get("userID"); exists && userID != nil {
		return fmt.Sprintf("%v", userID), nil
	}

	return "", fmt.Errorf("no user subject found in token")
}

// getUserSubjectKind returns "ServiceAccount" or "User" based on the subject format
func getUserSubjectKind(subject string) string {
	if len(subject) > 22 && subject[:22] == "system:serviceaccount:" {
		return "ServiceAccount"
	}
	return "User"
}

// getUserSubjectName returns the name part of the subject
// For ServiceAccount: "system:serviceaccount:namespace:name" -> "name"
// For User: returns the subject as-is
func getUserSubjectName(subject string) string {
	if getUserSubjectKind(subject) == "ServiceAccount" {
		parts := strings.Split(subject, ":")
		if len(parts) >= 4 {
			return parts[3]
		}
	}
	return subject
}

// getUserSubjectNamespace returns the namespace for ServiceAccount subjects
// For ServiceAccount: "system:serviceaccount:namespace:name" -> "namespace"
// For User: returns empty string
func getUserSubjectNamespace(subject string) string {
	if getUserSubjectKind(subject) == "ServiceAccount" {
		parts := strings.Split(subject, ":")
		if len(parts) >= 3 {
			return parts[2]
		}
	}
	return ""
}
</file>

<file path="components/backend/handlers/secrets.go">
package handlers

import (
	"fmt"
	"log"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// Two-secret architecture (hardcoded secret names):
// 1. ambient-runner-secrets: ANTHROPIC_API_KEY only (ignored when Vertex enabled)
// 2. ambient-non-vertex-integrations: GITHUB_TOKEN, JIRA_*, custom keys (optional, injected if present)

// ListNamespaceSecrets handles GET /api/projects/:projectName/secrets -> { items: [{name, createdAt}] }
func ListNamespaceSecrets(c *gin.Context) {
	projectName := c.Param("projectName")
	reqK8s, _ := GetK8sClientsForRequest(c)

	list, err := reqK8s.CoreV1().Secrets(projectName).List(c.Request.Context(), v1.ListOptions{})
	if err != nil {
		log.Printf("Failed to list secrets in %s: %v", projectName, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list secrets"})
		return
	}

	type Item struct {
		Name      string `json:"name"`
		CreatedAt string `json:"createdAt,omitempty"`
		Type      string `json:"type"`
	}
	items := []Item{}
	for _, s := range list.Items {
		// Only include runner/session secrets: Opaque + annotated
		if s.Type != corev1.SecretTypeOpaque {
			continue
		}
		if s.Annotations == nil || s.Annotations["ambient-code.io/runner-secret"] != "true" {
			continue
		}
		it := Item{Name: s.Name, Type: string(s.Type)}
		if !s.CreationTimestamp.IsZero() {
			it.CreatedAt = s.CreationTimestamp.Format(time.RFC3339)
		}
		items = append(items, it)
	}
	c.JSON(http.StatusOK, gin.H{"items": items})
}

// Runner secrets (ANTHROPIC_API_KEY only)
// Hardcoded secret name: "ambient-runner-secrets"
// Only injected when Vertex is disabled

// ListRunnerSecrets handles GET /api/projects/:projectName/runner-secrets -> { data: { key: value } }
func ListRunnerSecrets(c *gin.Context) {
	projectName := c.Param("projectName")
	reqK8s, _ := GetK8sClientsForRequest(c)
	if reqK8s == nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid or missing token"})
		c.Abort()
		return
	}

	const secretName = "ambient-runner-secrets"

	sec, err := reqK8s.CoreV1().Secrets(projectName).Get(c.Request.Context(), secretName, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			c.JSON(http.StatusOK, gin.H{"data": map[string]string{}})
			return
		}
		log.Printf("Failed to get Secret %s/%s: %v", projectName, secretName, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to read runner secrets"})
		return
	}

	out := map[string]string{}
	for k, v := range sec.Data {
		out[k] = string(v)
	}
	c.JSON(http.StatusOK, gin.H{"data": out})
}

// UpdateRunnerSecrets handles PUT /api/projects/:projectName/runner-secrets { data: { key: value } }
func UpdateRunnerSecrets(c *gin.Context) {
	projectName := c.Param("projectName")
	reqK8s, _ := GetK8sClientsForRequest(c)
	if reqK8s == nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid or missing token"})
		c.Abort()
		return
	}

	var req struct {
		Data map[string]string `json:"data" binding:"required"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Validate that only allowed keys are present in runner secrets
	allowedKeys := map[string]bool{
		"ANTHROPIC_API_KEY": true,
		// Future: "GEMINI_KEY": true, etc.
	}
	for key := range req.Data {
		if !allowedKeys[key] {
			c.JSON(http.StatusBadRequest, gin.H{
				"error": fmt.Sprintf("Invalid key '%s' for ambient-runner-secrets. Only ANTHROPIC_API_KEY is allowed.", key),
			})
			return
		}
	}

	const secretName = "ambient-runner-secrets"

	sec, err := reqK8s.CoreV1().Secrets(projectName).Get(c.Request.Context(), secretName, v1.GetOptions{})
	if errors.IsNotFound(err) {
		// Create new Secret
		newSec := &corev1.Secret{
			ObjectMeta: v1.ObjectMeta{
				Name:      secretName,
				Namespace: projectName,
				Labels:    map[string]string{"app": "ambient-runner-secrets"},
				Annotations: map[string]string{
					"ambient-code.io/runner-secret": "true",
				},
			},
			Type:       corev1.SecretTypeOpaque,
			StringData: req.Data,
		}
		if _, err := reqK8s.CoreV1().Secrets(projectName).Create(c.Request.Context(), newSec, v1.CreateOptions{}); err != nil {
			log.Printf("Failed to create Secret %s/%s: %v", projectName, secretName, err)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create runner secrets"})
			return
		}
	} else if err != nil {
		log.Printf("Failed to get Secret %s/%s: %v", projectName, secretName, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to read runner secrets"})
		return
	} else {
		// Update existing - replace Data
		sec.Type = corev1.SecretTypeOpaque
		sec.Data = map[string][]byte{}
		for k, v := range req.Data {
			sec.Data[k] = []byte(v)
		}
		if _, err := reqK8s.CoreV1().Secrets(projectName).Update(c.Request.Context(), sec, v1.UpdateOptions{}); err != nil {
			log.Printf("Failed to update Secret %s/%s: %v", projectName, secretName, err)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update runner secrets"})
			return
		}
	}

	c.JSON(http.StatusOK, gin.H{"message": "runner secrets updated"})
}

// Integration secrets (GITHUB_TOKEN, JIRA_*, custom keys)
// Hardcoded secret name: "ambient-non-vertex-integrations"
// Injected as env vars if present (optional), regardless of Vertex setting

// ListIntegrationSecrets handles GET /api/projects/:projectName/integration-secrets -> { data: { key: value } }
func ListIntegrationSecrets(c *gin.Context) {
	projectName := c.Param("projectName")
	reqK8s, _ := GetK8sClientsForRequest(c)
	if reqK8s == nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid or missing token"})
		c.Abort()
		return
	}

	const secretName = "ambient-non-vertex-integrations"

	sec, err := reqK8s.CoreV1().Secrets(projectName).Get(c.Request.Context(), secretName, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			c.JSON(http.StatusOK, gin.H{"data": map[string]string{}})
			return
		}
		log.Printf("Failed to get Secret %s/%s: %v", projectName, secretName, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to read integration secrets"})
		return
	}

	out := map[string]string{}
	for k, v := range sec.Data {
		out[k] = string(v)
	}
	c.JSON(http.StatusOK, gin.H{"data": out})
}

// UpdateIntegrationSecrets handles PUT /api/projects/:projectName/integration-secrets { data: { key: value } }
func UpdateIntegrationSecrets(c *gin.Context) {
	projectName := c.Param("projectName")
	reqK8s, _ := GetK8sClientsForRequest(c)
	if reqK8s == nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid or missing token"})
		c.Abort()
		return
	}

	var req struct {
		Data map[string]string `json:"data" binding:"required"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	const secretName = "ambient-non-vertex-integrations"

	sec, err := reqK8s.CoreV1().Secrets(projectName).Get(c.Request.Context(), secretName, v1.GetOptions{})
	if errors.IsNotFound(err) {
		newSec := &corev1.Secret{
			ObjectMeta: v1.ObjectMeta{
				Name:      secretName,
				Namespace: projectName,
				Labels:    map[string]string{"app": "ambient-integration-secrets"},
				Annotations: map[string]string{
					"ambient-code.io/runner-secret": "true",
				},
			},
			Type:       corev1.SecretTypeOpaque,
			StringData: req.Data,
		}
		if _, err := reqK8s.CoreV1().Secrets(projectName).Create(c.Request.Context(), newSec, v1.CreateOptions{}); err != nil {
			log.Printf("Failed to create Secret %s/%s: %v", projectName, secretName, err)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create integration secrets"})
			return
		}
	} else if err != nil {
		log.Printf("Failed to get Secret %s/%s: %v", projectName, secretName, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to read integration secrets"})
		return
	} else {
		sec.Type = corev1.SecretTypeOpaque
		sec.Data = map[string][]byte{}
		for k, v := range req.Data {
			sec.Data[k] = []byte(v)
		}
		if _, err := reqK8s.CoreV1().Secrets(projectName).Update(c.Request.Context(), sec, v1.UpdateOptions{}); err != nil {
			log.Printf("Failed to update Secret %s/%s: %v", projectName, secretName, err)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update integration secrets"})
			return
		}
	}

	c.JSON(http.StatusOK, gin.H{"message": "integration secrets updated"})
}
</file>

<file path="components/backend/types/session.go">
package types

// AgenticSession represents the structure of our custom resource
type AgenticSession struct {
	APIVersion string                 `json:"apiVersion"`
	Kind       string                 `json:"kind"`
	Metadata   map[string]interface{} `json:"metadata"`
	Spec       AgenticSessionSpec     `json:"spec"`
	Status     *AgenticSessionStatus  `json:"status,omitempty"`
}

type AgenticSessionSpec struct {
	Prompt               string             `json:"prompt" binding:"required"`
	Interactive          bool               `json:"interactive,omitempty"`
	DisplayName          string             `json:"displayName"`
	LLMSettings          LLMSettings        `json:"llmSettings"`
	Timeout              int                `json:"timeout"`
	UserContext          *UserContext       `json:"userContext,omitempty"`
	BotAccount           *BotAccountRef     `json:"botAccount,omitempty"`
	ResourceOverrides    *ResourceOverrides `json:"resourceOverrides,omitempty"`
	EnvironmentVariables map[string]string  `json:"environmentVariables,omitempty"`
	Project              string             `json:"project,omitempty"`
	// Multi-repo support (unified mapping)
	Repos         []SessionRepoMapping `json:"repos,omitempty"`
	MainRepoIndex *int                 `json:"mainRepoIndex,omitempty"`
	// Active workflow for dynamic workflow switching
	ActiveWorkflow *WorkflowSelection `json:"activeWorkflow,omitempty"`
}

// NamedGitRepo represents named repository types for multi-repo session support.
type NamedGitRepo struct {
	URL    string  `json:"url"`
	Branch *string `json:"branch,omitempty"`
}

type OutputNamedGitRepo struct {
	URL    string  `json:"url"`
	Branch *string `json:"branch,omitempty"`
}

// SessionRepoMapping is a unified session repo mapping.
type SessionRepoMapping struct {
	Input  NamedGitRepo        `json:"input"`
	Output *OutputNamedGitRepo `json:"output,omitempty"`
	Status *string             `json:"status,omitempty"`
}

type AgenticSessionStatus struct {
	Phase          string  `json:"phase,omitempty"`
	Message        string  `json:"message,omitempty"`
	StartTime      *string `json:"startTime,omitempty"`
	CompletionTime *string `json:"completionTime,omitempty"`
	JobName        string  `json:"jobName,omitempty"`
	StateDir       string  `json:"stateDir,omitempty"`
	// Result summary fields from runner
	Subtype      string                 `json:"subtype,omitempty"`
	IsError      bool                   `json:"is_error,omitempty"`
	NumTurns     int                    `json:"num_turns,omitempty"`
	SessionID    string                 `json:"session_id,omitempty"`
	TotalCostUSD *float64               `json:"total_cost_usd,omitempty"`
	Usage        map[string]interface{} `json:"usage,omitempty"`
	Result       *string                `json:"result,omitempty"`
}

type CreateAgenticSessionRequest struct {
	Prompt          string       `json:"prompt" binding:"required"`
	DisplayName     string       `json:"displayName,omitempty"`
	LLMSettings     *LLMSettings `json:"llmSettings,omitempty"`
	Timeout         *int         `json:"timeout,omitempty"`
	Interactive     *bool        `json:"interactive,omitempty"`
	WorkspacePath   string       `json:"workspacePath,omitempty"`
	ParentSessionID string       `json:"parent_session_id,omitempty"`
	// Multi-repo support (unified mapping)
	Repos                []SessionRepoMapping `json:"repos,omitempty"`
	MainRepoIndex        *int                 `json:"mainRepoIndex,omitempty"`
	AutoPushOnComplete   *bool                `json:"autoPushOnComplete,omitempty"`
	UserContext          *UserContext         `json:"userContext,omitempty"`
	BotAccount           *BotAccountRef       `json:"botAccount,omitempty"`
	ResourceOverrides    *ResourceOverrides   `json:"resourceOverrides,omitempty"`
	EnvironmentVariables map[string]string    `json:"environmentVariables,omitempty"`
	Labels               map[string]string    `json:"labels,omitempty"`
	Annotations          map[string]string    `json:"annotations,omitempty"`
}

type CloneSessionRequest struct {
	TargetProject  string `json:"targetProject" binding:"required"`
	NewSessionName string `json:"newSessionName" binding:"required"`
}

type UpdateAgenticSessionRequest struct {
	Prompt      *string      `json:"prompt,omitempty"`
	DisplayName *string      `json:"displayName,omitempty"`
	Timeout     *int         `json:"timeout,omitempty"`
	LLMSettings *LLMSettings `json:"llmSettings,omitempty"`
}

type CloneAgenticSessionRequest struct {
	TargetProject     string `json:"targetProject,omitempty"`
	TargetSessionName string `json:"targetSessionName,omitempty"`
	DisplayName       string `json:"displayName,omitempty"`
	Prompt            string `json:"prompt,omitempty"`
}

// WorkflowSelection represents a workflow to load into the session
type WorkflowSelection struct {
	GitURL string `json:"gitUrl" binding:"required"`
	Branch string `json:"branch,omitempty"`
	Path   string `json:"path,omitempty"`
}
</file>

<file path="components/backend/.golangci.yml">
# golangci-lint configuration for vTeam backend
# Compatible with golangci-lint v2+
#
# This configuration is pragmatic for a Kubernetes-native application.
# We focus on catching real bugs rather than style issues.

version: "2"

run:
  timeout: 5m

linters:
  enable:
    - govet         # Reports suspicious constructs
    - ineffassign   # Detect ineffectual assignments
    - staticcheck   # Advanced static analysis (includes many useful checks)
    - unused        # Check for unused constants, variables, functions
    - misspell      # Find commonly misspelled words
  disable:
    - errcheck      # Disabled: too many false positives with defer cleanup

  settings:
    staticcheck:
      checks: ["all", "-SA1019"]  # Disable deprecation warnings only

  exclusions:
    rules:
      # Exclude all linters from test files
      - path: _test\.go
        linters:
          - staticcheck
          - govet

      # Allow type assertions in K8s unstructured object parsing (intentional pattern)
      - path: (handlers|jira)/.*\.go
        text: "type assertion"

issues:
  max-issues-per-linter: 0  # Show all issues
  max-same-issues: 0        # Show all instances
  new: false                # Show all issues
</file>

<file path="README.md">
# Ambient Code Platform

> Kubernetes-native AI automation platform for intelligent agentic sessions with multi-agent collaboration

**Note:** This project was formerly known as "vTeam". While the project has been rebranded to **Ambient Code Platform**, the name "vTeam" still appears in various technical artifacts for backward compatibility (see [Legacy vTeam References](#legacy-vteam-references) below).

## Overview

The **Ambient Code Platform** is an AI automation platform that combines Claude Code CLI with multi-agent collaboration capabilities. The platform enables teams to create and manage intelligent agentic sessions through a modern web interface.

### Key Capabilities

- **Intelligent Agentic Sessions**: AI-powered automation for analysis, research, content creation, and development tasks
- **Multi-Agent Workflows**: Specialized AI agents model realistic software team dynamics
- **Kubernetes Native**: Built with Custom Resources, Operators, and proper RBAC for enterprise deployment
- **Real-time Monitoring**: Live status updates and job execution tracking

## Architecture

The platform consists of containerized microservices orchestrated via Kubernetes:

| Component | Technology | Description |
|-----------|------------|-------------|
| **Frontend** | NextJS + Shadcn | User interface for managing agentic sessions |
| **Backend API** | Go + Gin | REST API for managing Kubernetes Custom Resources (multi-tenant: projects, sessions, access control) |
| **Agentic Operator** | Go | Kubernetes operator that watches CRs and creates Jobs |
| **Claude Code Runner** | Python + Claude Code CLI | Pod that executes AI with multi-agent collaboration capabilities |

### Agentic Session Flow

1. **Create Session**: User creates agentic session via web UI with task description
2. **API Processing**: Backend creates `AgenticSession` Custom Resource in Kubernetes
3. **Job Scheduling**: Operator detects CR and creates Kubernetes Job with runner pod
4. **AI Execution**: Pod runs Claude Code CLI with multi-agent collaboration for intelligent analysis
5. **Result Storage**: Analysis results stored back in Custom Resource status
6. **UI Updates**: Frontend displays real-time progress and completed results

## Prerequisites

### Required Tools
- **OpenShift Local (CRC)** for local development or OpenShift cluster for production
- **oc** (OpenShift CLI) or **kubectl** v1.28+ configured to access your cluster
- **Docker or Podman** for building container images
- **Container registry access** (Docker Hub, Quay.io, ECR, etc.) for production
- **Go 1.24+** for building backend services (if building from source)
- **Node.js 20+** and **npm** for the frontend (if building from source)

### Required API Keys
- **Anthropic API Key** - Get from [Anthropic Console](https://console.anthropic.com/)
  - Configure via web UI: Settings → Runner Secrets after deployment

## Quick Start

### 1. Deploy to OpenShift

Deploy using the default images from `quay.io/ambient_code`:

```bash
# From repo root, prepare env for deploy script (required once)
cp components/manifests/env.example components/manifests/.env
# Edit .env and set at least ANTHROPIC_API_KEY

# Deploy to ambient-code namespace (default)
make deploy

# Or deploy to custom namespace
make deploy NAMESPACE=my-namespace
```

### 2. Verify Deployment

```bash
# Check pod status
oc get pods -n ambient-code

# Check services and routes
oc get services,routes -n ambient-code
```

### 3. Access the Web Interface

```bash
# Get the route URL
oc get route frontend-route -n ambient-code

# Or use port forwarding as fallback
kubectl port-forward svc/frontend-service 3000:3000 -n ambient-code
```

### 4. Configure API Keys

1. Access the web interface
2. Navigate to Settings → Runner Secrets
3. Add your Anthropic API key

## Usage

### Creating an Agentic Session

1. **Access Web Interface**: Navigate to your deployed route URL
2. **Create New Session**:
   - **Prompt**: Task description (e.g., "Review this codebase for security vulnerabilities and suggest improvements")
   - **Model**: Choose AI model (Claude Sonnet/Haiku)
   - **Settings**: Adjust temperature, token limits, timeout (default: 300s)
3. **Monitor Progress**: View real-time status updates and execution logs
4. **Review Results**: Download analysis results and structured output

### Example Use Cases

- **Code Analysis**: Security reviews, code quality assessments, architecture analysis
- **Technical Documentation**: API documentation, user guides, technical specifications
- **Project Planning**: Feature specifications, implementation plans, task breakdowns
- **Research & Analysis**: Technology research, competitive analysis, requirement gathering
- **Development Workflows**: Code reviews, testing strategies, deployment planning

## Advanced Configuration

### Building Custom Images

To build and deploy your own container images:

```bash
# Set your container registry
export REGISTRY="quay.io/your-username"

# Build all images
make build-all

# Push to registry (requires authentication)
make push-all REGISTRY=$REGISTRY

# Deploy with custom images
cd components/manifests
REGISTRY=$REGISTRY ./deploy.sh
```

### Container Engine Options

```bash
# Use Podman instead of Docker
make build-all CONTAINER_ENGINE=podman

# Build for specific platform
# Default is linux/amd64
make build-all PLATFORM=linux/arm64

# Build with additional flags
make build-all BUILD_FLAGS="--no-cache --pull"
```

### OpenShift OAuth Integration

For cluster-based authentication and authorization, the deployment script can configure the Route host, create an `OAuthClient`, and set the frontend secret when provided a `.env` file. See the guide for details and a manual alternative:

- [docs/OPENSHIFT_OAUTH.md](docs/OPENSHIFT_OAUTH.md)

## Configuration & Secrets

### Operator Configuration (Vertex AI vs Direct API)

The operator supports two modes for accessing Claude AI:

#### Direct Anthropic API (Default)
Use `operator-config.yaml` or `operator-config-crc.yaml` for standard deployments:

```bash
# Apply the standard config (Vertex AI disabled)
kubectl apply -f components/manifests/operator-config.yaml -n ambient-code
```

**When to use:**
- Standard cloud deployments without Google Cloud integration
- Local development with CRC/Minikube
- Any environment using direct Anthropic API access

**Configuration:** Sets `CLAUDE_CODE_USE_VERTEX=0`

#### Google Cloud Vertex AI
Use `operator-config-openshift.yaml` for production OpenShift deployments with Vertex AI:

```bash
# Apply the Vertex AI config
kubectl apply -f components/manifests/operator-config-openshift.yaml -n ambient-code
```

**When to use:**
- Production deployments on Google Cloud
- Environments requiring Vertex AI integration
- Enterprise deployments with Google Cloud service accounts

**Configuration:** Sets `CLAUDE_CODE_USE_VERTEX=1` and configures:
- `CLOUD_ML_REGION`: Google Cloud region (default: "global")
- `ANTHROPIC_VERTEX_PROJECT_ID`: Your GCP project ID
- `GOOGLE_APPLICATION_CREDENTIALS`: Path to service account key file

**Creating the Vertex AI Secret:**

When using Vertex AI, you must create a secret containing your Google Cloud service account key:

```bash
# The key file MUST be named ambient-code-key.json
kubectl create secret generic ambient-vertex \
  --from-file=ambient-code-key.json=ambient-code-key.json \
  -n ambient-code
```

**Important Requirements:**
- ✅ Secret name must be `ambient-vertex`
- ✅ Key file must be named `ambient-code-key.json`
- ✅ Service account must have Vertex AI API access
- ✅ Project ID in config must match the service account's project


### Session Timeout Configuration

Sessions have a configurable timeout (default: 300 seconds):

- **Environment Variable**: Set `TIMEOUT=1800` for 30-minute sessions
- **CRD Default**: Modify `components/manifests/crds/agenticsessions-crd.yaml`
- **Interactive Mode**: Set `interactive: true` for unlimited chat-based sessions

### Runner Secrets Management

Configure AI API keys and integrations via the web interface:

- **Settings → Runner Secrets**: Add Anthropic API keys
- **Project-scoped**: Each project namespace has isolated secret management
- **Security**: All secrets stored as Kubernetes Secrets with proper RBAC

## Troubleshooting

### Common Issues

**Pods Not Starting:**
```bash
oc describe pod <pod-name> -n ambient-code
oc logs <pod-name> -n ambient-code
```

**API Connection Issues:**
```bash
oc get endpoints -n ambient-code
oc exec -it <pod-name> -- curl http://backend-service:8080/health
```

**Job Failures:**
```bash
oc get jobs -n ambient-code
oc describe job <job-name> -n ambient-code
oc logs <failed-pod-name> -n ambient-code
```

### Verification Commands

```bash
# Check all resources
oc get all -l app=ambient-code -n ambient-code

# View recent events
oc get events --sort-by='.lastTimestamp' -n ambient-code

# Test frontend access
curl -f http://localhost:3000 || echo "Frontend not accessible"

# Test backend API
kubectl port-forward svc/backend-service 8080:8080 -n ambient-code &
curl http://localhost:8080/health
```

## Production Considerations

### Security
- **API Key Management**: Store Anthropic API keys securely in Kubernetes secrets
- **RBAC**: Configure appropriate role-based access controls
- **Network Policies**: Implement network isolation between components
- **Image Scanning**: Scan container images for vulnerabilities before deployment

### Monitoring
- **Prometheus Metrics**: Configure metrics collection for all components
- **Log Aggregation**: Set up centralized logging (ELK, Loki, etc.)
- **Alerting**: Configure alerts for pod failures, resource exhaustion
- **Health Checks**: Implement comprehensive health endpoints

### Scaling
- **Horizontal Pod Autoscaling**: Configure HPA based on CPU/memory usage
- **Resource Limits**: Set appropriate resource requests and limits
- **Node Affinity**: Configure pod placement for optimal resource usage

## Development

### Local Development with OpenShift Local (CRC)

**Single Command Setup:**
```bash
# Start complete local development environment
make dev-start
```

**What this provides:**
- ✅ Full OpenShift cluster with CRC
- ✅ Real OpenShift authentication and RBAC
- ✅ Production-like environment
- ✅ Automatic image builds and deployments
- ✅ Working frontend-backend integration

**Prerequisites:**
```bash
# Install CRC (macOS)
brew install crc

# Get Red Hat pull secret (free):
# 1. Visit: https://console.redhat.com/openshift/create/local
# 2. Download pull secret to ~/.crc/pull-secret.json
# 3. Run: crc setup

# Then start development
make dev-start
```

**Hot Reloading (optional):**
```bash
# Terminal 1: Start with development images
DEV_MODE=true make dev-start

# Terminal 2: Enable file sync for hot-reloading
make dev-sync
```

**Access URLs:**
- Frontend: `https://vteam-frontend-vteam-dev.apps-crc.testing`
- Backend: `https://vteam-backend-vteam-dev.apps-crc.testing/health`
- Console: `https://console-openshift-console.apps-crc.testing`

### Building from Source
```bash
# Build all images locally
make build-all

# Build specific components
make build-frontend
make build-backend
make build-operator
make build-runner
```

## File Structure

```
vTeam/
├── components/                     # 🚀 Ambient Code Platform Components
│   ├── frontend/                   # NextJS web interface
│   ├── backend/                    # Go API service
│   ├── operator/                   # Kubernetes operator
│   ├── runners/                   # AI runner services
│   │   └── claude-code-runner/    # Python Claude Code CLI service
│   └── manifests/                  # Kubernetes deployment manifests
├── docs/                           # Documentation
│   ├── OPENSHIFT_DEPLOY.md        # Detailed deployment guide
│   └── OPENSHIFT_OAUTH.md         # OAuth configuration
├── tools/                          # Supporting development tools
│   ├── vteam_shared_configs/       # Team configuration management
│   └── mcp_client_integration/     # MCP client library
└── Makefile                        # Build and deployment automation
```

## Production Considerations

### Security
- **RBAC**: Comprehensive role-based access controls
- **Network Policies**: Component isolation and secure communication
- **Secret Management**: Kubernetes-native secret storage with encryption
- **Image Scanning**: Vulnerability scanning for all container images

### Monitoring & Observability
- **Health Checks**: Comprehensive health endpoints for all services
- **Metrics**: Prometheus-compatible metrics collection
- **Logging**: Structured logging with OpenShift logging integration
- **Alerting**: Integration with OpenShift monitoring and alerting

### Scaling & Performance
- **Horizontal Pod Autoscaling**: Auto-scaling based on CPU/memory metrics
- **Resource Management**: Proper requests/limits for optimal resource usage
- **Job Queuing**: Intelligent job scheduling and resource allocation
- **Multi-tenancy**: Project-based isolation with shared infrastructure

## Contributing

We welcome contributions! Please follow these guidelines to ensure code quality and consistency.

### Development Workflow

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Make your changes following the existing patterns
4. Run code quality checks (see below)
5. Add tests if applicable
6. Commit with conventional commit messages
7. Push to the branch (`git push origin feature/amazing-feature`)
8. Open a Pull Request

### Code Quality Standards

#### Go Code (Backend & Operator)

Before committing Go code, run these checks locally:

```bash
# Backend
cd components/backend
gofmt -l .                    # Check formatting
go vet ./...                  # Run go vet
golangci-lint run            # Run full linting suite

# Operator
cd components/operator
gofmt -l .                    # Check formatting
go vet ./...                  # Run go vet
golangci-lint run            # Run full linting suite
```

**Install golangci-lint:**
```bash
go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
```

**Auto-format your code:**
```bash
# Format all Go files
gofmt -w components/backend components/operator
```

**CI/CD:** All pull requests automatically run these checks via GitHub Actions. Your PR must pass all linting checks before merging.

#### Frontend Code

```bash
cd components/frontend
npm run lint                  # ESLint checks
npm run type-check            # TypeScript checks (if available)
npm run format                # Prettier formatting
```

### Testing

```bash
# Backend tests
cd components/backend
make test                     # Run all tests
make test-unit                # Unit tests only
make test-integration         # Integration tests

# Operator tests
cd components/operator
go test ./... -v              # Run all tests

# Frontend tests
cd components/frontend
npm test                      # Run test suite
```

### E2E Testing

Run automated end-to-end tests in a local kind cluster:

```bash
make e2e-test                # Full test suite (setup, deploy, test, cleanup)
```

Or run steps individually:

```bash
cd e2e
./scripts/setup-kind.sh      # Create kind cluster
./scripts/deploy.sh          # Deploy vTeam
./scripts/run-tests.sh       # Run Cypress tests
./scripts/cleanup.sh         # Clean up
```

The e2e tests deploy the complete vTeam stack to a kind (Kubernetes in Docker) cluster and verify core functionality including project creation and UI navigation. Tests run automatically in GitHub Actions on every PR.

See [e2e/README.md](e2e/README.md) for detailed documentation, troubleshooting, and development guide.

## Agent Strategy for Pilot
- To ensure maximum focus and efficiency for the current RFE (Request for Enhancement) pilot, we are temporarily streamlining the active agent pool.
- Active Agents (Focused Scope): The 5 agents required for this specific RFE workflow are currently located in the agents folder.
- Agent Bullpen (Holding Pattern): All remaining agent definitions have been relocated to the "agent bullpen" folder. This transition does not signify the deprecation of any roles.
- Future Planning: Agents in the "agent bullpen" are designated for future reintegration and will be actively utilized as we expand to address subsequent processes and workflows across the organization.


### Documentation

- Update relevant documentation when changing functionality
- Follow existing documentation style (Markdown)
- Add code comments for complex logic
- Update CLAUDE.md if adding new patterns or standards

## Support & Documentation

- **Deployment Guide**: [docs/OPENSHIFT_DEPLOY.md](docs/OPENSHIFT_DEPLOY.md)
- **OAuth Setup**: [docs/OPENSHIFT_OAUTH.md](docs/OPENSHIFT_OAUTH.md)
- **Architecture Details**: [diagrams/](diagrams/)
- **API Documentation**: Available in web interface after deployment

## Legacy vTeam References

While the project is now branded as **Ambient Code Platform**, the name "vTeam" still appears in various technical components for backward compatibility and to avoid breaking changes. You will encounter "vTeam" or "vteam" in:

### Infrastructure & Deployment
- **GitHub Repository**: `github.com/ambient-code/vTeam` (repository name unchanged)
- **Container Images**: `vteam_frontend`, `vteam_backend`, `vteam_operator`, `vteam_claude_runner`
- **Kubernetes API Group**: `vteam.ambient-code` (used in Custom Resource Definitions)
- **Development Namespace**: `vteam-dev` (local development environment)

### URLs & Routes
- **Local Development Routes**:
  - `https://vteam-frontend-vteam-dev.apps-crc.testing`
  - `https://vteam-backend-vteam-dev.apps-crc.testing`

### Code & Configuration
- **File paths**: Repository directory structure (`/path/to/vTeam/...`)
- **Go package references**: Internal Kubernetes resource types
- **RBAC resources**: ClusterRole and RoleBinding names
- **Makefile targets**: Development commands reference `vteam-dev` namespace
- **Kubernetes resources**: Deployment names (`vteam-frontend`, `vteam-backend`, `vteam-operator`)
- **Environment variables**: `VTEAM_VERSION` in frontend deployment

These technical references remain unchanged to maintain compatibility with existing deployments and to avoid requiring migration for current users. Future major versions may fully transition these artifacts to use "Ambient Code Platform" or "ambient-code" naming.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
</file>

<file path="components/backend/jira/integration.go">
// Package jira provides JIRA integration (currently disabled - was RFE-specific).
// Kept for potential future use.
package jira

/*
// This package was RFE-specific and has been commented out.
// Uncomment and refactor when adding Jira support for sessions or other features.

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"strings"
	"time"

	"ambient-code-backend/git"
	"ambient-code-backend/handlers"

	"github.com/gin-gonic/gin"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/client-go/dynamic"
	"k8s.io/client-go/kubernetes"
)

// Handler dependencies
type Handler struct {
	GetK8sClientsForRequest    func(*gin.Context) (*kubernetes.Clientset, dynamic.Interface)
	GetProjectSettingsResource func() schema.GroupVersionResource
	GetRFEWorkflowResource     func() schema.GroupVersionResource
}

// Commented out RFE-specific functions
// Add Jira integration functions here when ready for session-based Jira support
*/
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

The **Ambient Code Platform** is a Kubernetes-native AI automation platform that orchestrates intelligent agentic sessions through containerized microservices. The platform enables AI-powered automation for analysis, research, development, and content creation tasks via a modern web interface.

> **Note:** This project was formerly known as "vTeam". Technical artifacts (image names, namespaces, API groups) still use "vteam" for backward compatibility.

### Core Architecture

The system follows a Kubernetes-native pattern with Custom Resources, Operators, and Job execution:

1. **Frontend** (NextJS + Shadcn): Web UI for session management and monitoring
2. **Backend API** (Go + Gin): REST API managing Kubernetes Custom Resources with multi-tenant project isolation
3. **Agentic Operator** (Go): Kubernetes controller watching CRs and creating Jobs
4. **Claude Code Runner** (Python): Job pods executing Claude Code CLI with multi-agent collaboration

### Agentic Session Flow

```
User Creates Session → Backend Creates CR → Operator Spawns Job →
Pod Runs Claude CLI → Results Stored in CR → UI Displays Progress
```

## Development Commands

### Quick Start - Local Development

**Single command setup with OpenShift Local (CRC):**

```bash
# Prerequisites: brew install crc
# Get free Red Hat pull secret from console.redhat.com/openshift/create/local
make dev-start

# Access at https://vteam-frontend-vteam-dev.apps-crc.testing
```

**Hot-reloading development:**

```bash
# Terminal 1
DEV_MODE=true make dev-start

# Terminal 2 (separate terminal)
make dev-sync
```

### Building Components

```bash
# Build all container images (default: docker, linux/amd64)
make build-all

# Build with podman
make build-all CONTAINER_ENGINE=podman

# Build for ARM64
make build-all PLATFORM=linux/arm64

# Build individual components
make build-frontend
make build-backend
make build-operator
make build-runner

# Push to registry
make push-all REGISTRY=quay.io/your-username
```

### Deployment

```bash
# Deploy with default images from quay.io/ambient_code
make deploy

# Deploy to custom namespace
make deploy NAMESPACE=my-namespace

# Deploy with custom images
cd components/manifests
cp env.example .env
# Edit .env with ANTHROPIC_API_KEY and CONTAINER_REGISTRY
./deploy.sh

# Clean up deployment
make clean
```

### Component Development

See component-specific documentation for detailed development commands:

- **Backend** (`components/backend/README.md`): Go API development, testing, linting
- **Frontend** (`components/frontend/README.md`): NextJS development, see also `DESIGN_GUIDELINES.md`
- **Operator** (`components/operator/README.md`): Operator development, watch patterns
- **Claude Code Runner** (`components/runners/claude-code-runner/README.md`): Python runner development

**Common commands**:

```bash
make build-all         # Build all components
make deploy            # Deploy to cluster
make test              # Run tests
make lint              # Lint code
```

### Documentation

```bash
# Install documentation dependencies
pip install -r requirements-docs.txt

# Serve locally at http://127.0.0.1:8000
mkdocs serve

# Build static site
mkdocs build

# Deploy to GitHub Pages
mkdocs gh-deploy

# Markdown linting
markdownlint docs/**/*.md
```

### Local Development Helpers

```bash
# View logs
make dev-logs              # Both backend and frontend
make dev-logs-backend      # Backend only
make dev-logs-frontend     # Frontend only
make dev-logs-operator     # Operator only

# Operator management
make dev-restart-operator  # Restart operator deployment
make dev-operator-status   # Show operator status and events

# Cleanup
make dev-stop              # Stop processes, keep CRC running
make dev-stop-cluster      # Stop processes and shutdown CRC
make dev-clean             # Stop and delete OpenShift project

# Testing
make dev-test              # Run smoke tests
make dev-test-operator     # Test operator only
```

## Key Architecture Patterns

### Custom Resource Definitions (CRDs)

The platform defines three primary CRDs:

1. **AgenticSession** (`agenticsessions.vteam.ambient-code`): Represents an AI execution session
   - Spec: prompt, repos (multi-repo support), interactive mode, timeout, model selection
   - Status: phase, startTime, completionTime, results, error messages, per-repo push status

2. **ProjectSettings** (`projectsettings.vteam.ambient-code`): Project-scoped configuration
   - Manages API keys, default models, timeout settings
   - Namespace-isolated for multi-tenancy

3. **RFEWorkflow** (`rfeworkflows.vteam.ambient-code`): RFE (Request For Enhancement) workflows
   - 7-step agent council process for engineering refinement
   - Agent roles: PM, Architect, Staff Engineer, PO, Team Lead, Team Member, Delivery Owner

### Multi-Repo Support

AgenticSessions support operating on multiple repositories simultaneously:

- Each repo has required `input` (URL, branch) and optional `output` (fork/target) configuration
- `mainRepoIndex` specifies which repo is the Claude working directory (default: 0)
- Per-repo status tracking: `pushed` or `abandoned`

### Interactive vs Batch Mode

- **Batch Mode** (default): Single prompt execution with timeout
- **Interactive Mode** (`interactive: true`): Long-running chat sessions using inbox/outbox files

### Backend API Structure

The Go backend (`components/backend/`) implements:

- **Project-scoped endpoints**: `/api/projects/:project/*` for namespaced resources
- **Multi-tenant isolation**: Each project maps to a Kubernetes namespace
- **WebSocket support**: Real-time session updates via `websocket_messaging.go`
- **Git operations**: Repository cloning, forking, PR creation via `git.go`
- **RBAC integration**: OpenShift OAuth for authentication

Main handler logic in `handlers.go` (3906 lines) manages:

- Project CRUD operations
- AgenticSession lifecycle
- ProjectSettings management
- RFE workflow orchestration

### Operator Reconciliation Loop

The Kubernetes operator (`components/operator/`) watches for:

- AgenticSession creation/updates → spawns Jobs with runner pods
- Job completion → updates CR status with results
- Timeout handling and cleanup

### Runner Execution

The Claude Code runner (`components/runners/claude-code-runner/`) provides:

- Claude Code SDK integration (`claude-code-sdk>=0.0.23`)
- Workspace synchronization via PVC proxy
- Multi-agent collaboration capabilities
- Anthropic API streaming (`anthropic>=0.68.0`)

## Configuration Standards

### Python

- **Virtual environments**: Always use `python -m venv venv` or `uv venv`
- **Package manager**: Prefer `uv` over `pip`
- **Formatting**: black (double quotes)
- **Import sorting**: isort with black profile
- **Linting**: flake8 (ignore E203, W503)

### Go

- **Formatting**: `go fmt ./...` (enforced)
- **Linting**: golangci-lint (install via `make install-tools`)
- **Testing**: Table-driven tests with subtests
- **Error handling**: Explicit error returns, no panic in production code

### Container Images

- **Default registry**: `quay.io/ambient_code`
- **Image tags**: Component-specific (vteam_frontend, vteam_backend, vteam_operator, vteam_claude_runner)
- **Platform**: Default `linux/amd64`, ARM64 supported via `PLATFORM=linux/arm64`
- **Build tool**: Docker or Podman (`CONTAINER_ENGINE=podman`)

### Git Workflow

- **Default branch**: `main`
- **Feature branches**: Required for development
- **Commit style**: Conventional commits (squashed on merge)
- **Branch verification**: Always check current branch before file modifications

### Kubernetes/OpenShift

- **Default namespace**: `ambient-code` (production), `vteam-dev` (local dev)
- **CRD group**: `vteam.ambient-code`
- **API version**: `v1alpha1` (current)
- **RBAC**: Namespace-scoped service accounts with minimal permissions

## Backend and Operator Development Standards

**IMPORTANT**: When working on backend (`components/backend/`) or operator (`components/operator/`) code, you MUST follow these strict guidelines based on established patterns in the codebase.

### Critical Rules (Never Violate)

1. **User Token Authentication Required**
   - FORBIDDEN: Using backend service account for user-initiated API operations
   - REQUIRED: Always use `GetK8sClientsForRequest(c)` to get user-scoped K8s clients
   - REQUIRED: Return `401 Unauthorized` if user token is missing or invalid
   - Exception: Backend service account ONLY for CR writes and token minting (handlers/sessions.go:227, handlers/sessions.go:449)

2. **Never Panic in Production Code**
   - FORBIDDEN: `panic()` in handlers, reconcilers, or any production path
   - REQUIRED: Return explicit errors with context: `return fmt.Errorf("failed to X: %w", err)`
   - REQUIRED: Log errors before returning: `log.Printf("Operation failed: %v", err)`

3. **Token Security and Redaction**
   - FORBIDDEN: Logging tokens, API keys, or sensitive headers
   - REQUIRED: Redact tokens in logs using custom formatters (server/server.go:22-34)
   - REQUIRED: Use `log.Printf("tokenLen=%d", len(token))` instead of logging token content
   - Example: `path = strings.Split(path, "?")[0] + "?token=[REDACTED]"`

4. **Type-Safe Unstructured Access**
   - FORBIDDEN: Direct type assertions without checking: `obj.Object["spec"].(map[string]interface{})`
   - REQUIRED: Use `unstructured.Nested*` helpers with three-value returns
   - Example: `spec, found, err := unstructured.NestedMap(obj.Object, "spec")`
   - REQUIRED: Check `found` before using values; handle type mismatches gracefully

5. **OwnerReferences for Resource Lifecycle**
   - REQUIRED: Set OwnerReferences on all child resources (Jobs, Secrets, PVCs, Services)
   - REQUIRED: Use `Controller: boolPtr(true)` for primary owner
   - FORBIDDEN: `BlockOwnerDeletion` (causes permission issues in multi-tenant environments)
   - Pattern: (operator/internal/handlers/sessions.go:125-134, handlers/sessions.go:470-476)

### Package Organization

**Backend Structure** (`components/backend/`):

```
backend/
├── handlers/          # HTTP handlers grouped by resource
│   ├── sessions.go    # AgenticSession CRUD + lifecycle
│   ├── projects.go    # Project management
│   ├── rfe.go         # RFE workflows
│   ├── helpers.go     # Shared utilities (StringPtr, etc.)
│   └── middleware.go  # Auth, validation, RBAC
├── types/             # Type definitions (no business logic)
│   ├── session.go
│   ├── project.go
│   └── common.go
├── server/            # Server setup, CORS, middleware
├── k8s/               # K8s resource templates
├── git/, github/      # External integrations
├── websocket/         # Real-time messaging
├── routes.go          # HTTP route registration
└── main.go            # Wiring, dependency injection
```

**Operator Structure** (`components/operator/`):

```
operator/
├── internal/
│   ├── config/        # K8s client init, config loading
│   ├── types/         # GVR definitions, resource helpers
│   ├── handlers/      # Watch handlers (sessions, namespaces, projectsettings)
│   └── services/      # Reusable services (PVC provisioning, etc.)
└── main.go            # Watch coordination
```

**Rules**:

- Handlers contain HTTP/watch logic ONLY
- Types are pure data structures
- Business logic in separate service packages
- No cyclic dependencies between packages

### Kubernetes Client Patterns

**User-Scoped Clients** (for API operations):

```go
// ALWAYS use for user-initiated operations (list, get, create, update, delete)
reqK8s, reqDyn := GetK8sClientsForRequest(c)
if reqK8s == nil {
    c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid or missing token"})
    c.Abort()
    return
}
// Use reqDyn for CR operations in user's authorized namespaces
list, err := reqDyn.Resource(gvr).Namespace(project).List(ctx, v1.ListOptions{})
```

**Backend Service Account Clients** (limited use cases):

```go
// ONLY use for:
// 1. Writing CRs after validation (handlers/sessions.go:417)
// 2. Minting tokens/secrets for runners (handlers/sessions.go:449)
// 3. Cross-namespace operations backend is authorized for
// Available as: DynamicClient, K8sClient (package-level in handlers/)
created, err := DynamicClient.Resource(gvr).Namespace(project).Create(ctx, obj, v1.CreateOptions{})
```

**Never**:

- ❌ Fall back to service account when user token is invalid
- ❌ Use service account for list/get operations on behalf of users
- ❌ Skip RBAC checks by using elevated permissions

### Error Handling Patterns

**Handler Errors**:

```go
// Pattern 1: Resource not found
if errors.IsNotFound(err) {
    c.JSON(http.StatusNotFound, gin.H{"error": "Session not found"})
    return
}

// Pattern 2: Log + return error
if err != nil {
    log.Printf("Failed to create session %s in project %s: %v", name, project, err)
    c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create session"})
    return
}

// Pattern 3: Non-fatal errors (continue operation)
if err := updateStatus(...); err != nil {
    log.Printf("Warning: status update failed: %v", err)
    // Continue - session was created successfully
}
```

**Operator Errors**:

```go
// Pattern 1: Resource deleted during processing (non-fatal)
if errors.IsNotFound(err) {
    log.Printf("AgenticSession %s no longer exists, skipping", name)
    return nil  // Don't treat as error
}

// Pattern 2: Retriable errors in watch loop
if err != nil {
    log.Printf("Failed to create job: %v", err)
    updateAgenticSessionStatus(ns, name, map[string]interface{}{
        "phase": "Error",
        "message": fmt.Sprintf("Failed to create job: %v", err),
    })
    return fmt.Errorf("failed to create job: %v", err)
}
```

**Never**:

- ❌ Silent failures (always log errors)
- ❌ Generic error messages ("operation failed")
- ❌ Retrying indefinitely without backoff

### Resource Management

**OwnerReferences Pattern**:

```go
// Always set owner when creating child resources
ownerRef := v1.OwnerReference{
    APIVersion: obj.GetAPIVersion(),  // e.g., "vteam.ambient-code/v1alpha1"
    Kind:       obj.GetKind(),        // e.g., "AgenticSession"
    Name:       obj.GetName(),
    UID:        obj.GetUID(),
    Controller: boolPtr(true),        // Only one controller per resource
    // BlockOwnerDeletion: intentionally omitted (permission issues)
}

// Apply to child resources
job := &batchv1.Job{
    ObjectMeta: v1.ObjectMeta{
        Name: jobName,
        Namespace: namespace,
        OwnerReferences: []v1.OwnerReference{ownerRef},
    },
    // ...
}
```

**Cleanup Patterns**:

```go
// Rely on OwnerReferences for automatic cleanup, but delete explicitly when needed
policy := v1.DeletePropagationBackground
err := K8sClient.BatchV1().Jobs(ns).Delete(ctx, jobName, v1.DeleteOptions{
    PropagationPolicy: &policy,
})
if err != nil && !errors.IsNotFound(err) {
    log.Printf("Failed to delete job: %v", err)
    return err
}
```

### Security Patterns

**Token Handling**:

```go
// Extract token from Authorization header
rawAuth := c.GetHeader("Authorization")
parts := strings.SplitN(rawAuth, " ", 2)
if len(parts) != 2 || !strings.EqualFold(parts[0], "Bearer") {
    c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid Authorization header"})
    return
}
token := strings.TrimSpace(parts[1])

// NEVER log the token itself
log.Printf("Processing request with token (len=%d)", len(token))
```

**RBAC Enforcement**:

```go
// Always check permissions before operations
ssar := &authv1.SelfSubjectAccessReview{
    Spec: authv1.SelfSubjectAccessReviewSpec{
        ResourceAttributes: &authv1.ResourceAttributes{
            Group:     "vteam.ambient-code",
            Resource:  "agenticsessions",
            Verb:      "list",
            Namespace: project,
        },
    },
}
res, err := reqK8s.AuthorizationV1().SelfSubjectAccessReviews().Create(ctx, ssar, v1.CreateOptions{})
if err != nil || !res.Status.Allowed {
    c.JSON(http.StatusForbidden, gin.H{"error": "Unauthorized"})
    return
}
```

**Container Security**:

```go
// Always set SecurityContext for Job pods
SecurityContext: &corev1.SecurityContext{
    AllowPrivilegeEscalation: boolPtr(false),
    ReadOnlyRootFilesystem:   boolPtr(false),  // Only if temp files needed
    Capabilities: &corev1.Capabilities{
        Drop: []corev1.Capability{"ALL"},  // Drop all by default
    },
},
```

### API Design Patterns

**Project-Scoped Endpoints**:

```go
// Standard pattern: /api/projects/:projectName/resource
r.GET("/api/projects/:projectName/agentic-sessions", ValidateProjectContext(), ListSessions)
r.POST("/api/projects/:projectName/agentic-sessions", ValidateProjectContext(), CreateSession)
r.GET("/api/projects/:projectName/agentic-sessions/:sessionName", ValidateProjectContext(), GetSession)

// ValidateProjectContext middleware:
// 1. Extracts project from route param
// 2. Validates user has access via RBAC check
// 3. Sets project in context: c.Set("project", projectName)
```

**Middleware Chain**:

```go
// Order matters: Recovery → Logging → CORS → Identity → Validation → Handler
r.Use(gin.Recovery())
r.Use(gin.LoggerWithFormatter(customRedactingFormatter))
r.Use(cors.New(corsConfig))
r.Use(forwardedIdentityMiddleware())  // Extracts X-Forwarded-User, etc.
r.Use(ValidateProjectContext())       // RBAC check
```

**Response Patterns**:

```go
// Success with data
c.JSON(http.StatusOK, gin.H{"items": sessions})

// Success with created resource
c.JSON(http.StatusCreated, gin.H{"message": "Session created", "name": name, "uid": uid})

// Success with no content
c.Status(http.StatusNoContent)

// Errors with structured messages
c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
```

### Operator Patterns

**Watch Loop with Reconnection**:

```go
func WatchAgenticSessions() {
    gvr := types.GetAgenticSessionResource()

    for {  // Infinite loop with reconnection
        watcher, err := config.DynamicClient.Resource(gvr).Watch(ctx, v1.ListOptions{})
        if err != nil {
            log.Printf("Failed to create watcher: %v", err)
            time.Sleep(5 * time.Second)  // Backoff before retry
            continue
        }

        log.Println("Watching for events...")

        for event := range watcher.ResultChan() {
            switch event.Type {
            case watch.Added, watch.Modified:
                obj := event.Object.(*unstructured.Unstructured)
                handleEvent(obj)
            case watch.Deleted:
                // Handle cleanup
            }
        }

        log.Println("Watch channel closed, restarting...")
        watcher.Stop()
        time.Sleep(2 * time.Second)
    }
}
```

**Reconciliation Pattern**:

```go
func handleEvent(obj *unstructured.Unstructured) error {
    name := obj.GetName()
    namespace := obj.GetNamespace()

    // 1. Verify resource still exists (avoid race conditions)
    currentObj, err := getDynamicClient().Get(ctx, name, namespace)
    if errors.IsNotFound(err) {
        log.Printf("Resource %s no longer exists, skipping", name)
        return nil  // Not an error
    }

    // 2. Get current phase/status
    status, found, _ := unstructured.NestedMap(currentObj.Object, "status")
    phase := getPhaseOrDefault(status, "Pending")

    // 3. Only reconcile if in expected state
    if phase != "Pending" {
        return nil  // Already processed
    }

    // 4. Create resources idempotently (check existence first)
    if _, err := getResource(name); err == nil {
        log.Printf("Resource %s already exists", name)
        return nil
    }

    // 5. Create and update status
    createResource(...)
    updateStatus(namespace, name, map[string]interface{}{"phase": "Creating"})

    return nil
}
```

**Status Updates** (use UpdateStatus subresource):

```go
func updateAgenticSessionStatus(namespace, name string, updates map[string]interface{}) error {
    gvr := types.GetAgenticSessionResource()

    obj, err := config.DynamicClient.Resource(gvr).Namespace(namespace).Get(ctx, name, v1.GetOptions{})
    if errors.IsNotFound(err) {
        log.Printf("Resource deleted, skipping status update")
        return nil  // Not an error
    }

    if obj.Object["status"] == nil {
        obj.Object["status"] = make(map[string]interface{})
    }

    status := obj.Object["status"].(map[string]interface{})
    for k, v := range updates {
        status[k] = v
    }

    // Use UpdateStatus subresource (requires /status permission)
    _, err = config.DynamicClient.Resource(gvr).Namespace(namespace).UpdateStatus(ctx, obj, v1.UpdateOptions{})
    if errors.IsNotFound(err) {
        return nil  // Resource deleted during update
    }
    return err
}
```

**Goroutine Monitoring**:

```go
// Start background monitoring (operator/internal/handlers/sessions.go:477)
go monitorJob(jobName, sessionName, namespace)

// Monitoring loop checks both K8s Job status AND custom container status
func monitorJob(jobName, sessionName, namespace string) {
    for {
        time.Sleep(5 * time.Second)

        // 1. Check if parent resource still exists (exit if deleted)
        if _, err := getSession(namespace, sessionName); errors.IsNotFound(err) {
            log.Printf("Session deleted, stopping monitoring")
            return
        }

        // 2. Check Job status
        job, err := K8sClient.BatchV1().Jobs(namespace).Get(ctx, jobName, v1.GetOptions{})
        if errors.IsNotFound(err) {
            return
        }

        // 3. Update status based on Job conditions
        if job.Status.Succeeded > 0 {
            updateStatus(namespace, sessionName, map[string]interface{}{
                "phase": "Completed",
                "completionTime": time.Now().Format(time.RFC3339),
            })
            cleanup(namespace, jobName)
            return
        }
    }
}
```

### Pre-Commit Checklist for Backend/Operator

Before committing backend or operator code, verify:

- [ ] **Authentication**: All user-facing endpoints use `GetK8sClientsForRequest(c)`
- [ ] **Authorization**: RBAC checks performed before resource access
- [ ] **Error Handling**: All errors logged with context, appropriate HTTP status codes
- [ ] **Token Security**: No tokens or sensitive data in logs
- [ ] **Type Safety**: Used `unstructured.Nested*` helpers, checked `found` before using values
- [ ] **Resource Cleanup**: OwnerReferences set on all child resources
- [ ] **Status Updates**: Used `UpdateStatus` subresource, handled IsNotFound gracefully
- [ ] **Tests**: Added/updated tests for new functionality
- [ ] **Logging**: Structured logs with relevant context (namespace, resource name, etc.)
- [ ] **Code Quality**: Ran all linting checks locally (see below)

**Run these commands before committing:**

```bash
# Backend
cd components/backend
gofmt -l .                    # Check formatting (should output nothing)
go vet ./...                  # Detect suspicious constructs
golangci-lint run            # Run comprehensive linting

# Operator
cd components/operator
gofmt -l .
go vet ./...
golangci-lint run
```

**Auto-format code:**

```bash
gofmt -w components/backend components/operator
```

**Note**: GitHub Actions will automatically run these checks on your PR. Fix any issues locally before pushing.

### Common Mistakes to Avoid

**Backend**:

- ❌ Using service account client for user operations (always use user token)
- ❌ Not checking if user-scoped client creation succeeded
- ❌ Logging full token values (use `len(token)` instead)
- ❌ Not validating project access in middleware
- ❌ Type assertions without checking: `val := obj["key"].(string)` (use `val, ok := ...`)
- ❌ Not setting OwnerReferences (causes resource leaks)
- ❌ Treating IsNotFound as fatal error during cleanup
- ❌ Exposing internal error details to API responses (use generic messages)

**Operator**:

- ❌ Not reconnecting watch on channel close
- ❌ Processing events without verifying resource still exists
- ❌ Updating status on main object instead of /status subresource
- ❌ Not checking current phase before reconciliation (causes duplicate resources)
- ❌ Creating resources without idempotency checks
- ❌ Goroutine leaks (not exiting monitor when resource deleted)
- ❌ Using `panic()` in watch/reconciliation loops
- ❌ Not setting SecurityContext on Job pods

### Reference Files

Study these files to understand established patterns:

**Backend**:

- `components/backend/handlers/sessions.go` - Complete session lifecycle, user/SA client usage
- `components/backend/handlers/middleware.go` - Auth patterns, token extraction, RBAC
- `components/backend/handlers/helpers.go` - Utility functions (StringPtr, BoolPtr)
- `components/backend/types/common.go` - Type definitions
- `components/backend/server/server.go` - Server setup, middleware chain, token redaction
- `components/backend/routes.go` - HTTP route definitions and registration

**Operator**:

- `components/operator/internal/handlers/sessions.go` - Watch loop, reconciliation, status updates
- `components/operator/internal/config/config.go` - K8s client initialization
- `components/operator/internal/types/resources.go` - GVR definitions
- `components/operator/internal/services/infrastructure.go` - Reusable services

## GitHub Actions CI/CD

### Component Build Pipeline (`.github/workflows/components-build-deploy.yml`)

- **Change detection**: Only builds modified components (frontend, backend, operator, claude-runner)
- **Multi-platform builds**: linux/amd64 and linux/arm64
- **Registry**: Pushes to `quay.io/ambient_code` on main branch
- **PR builds**: Build-only, no push on pull requests

### Other Workflows

- **claude.yml**: Claude Code integration
- **test-local-dev.yml**: Local development environment validation
- **dependabot-auto-merge.yml**: Automated dependency updates
- **project-automation.yml**: GitHub project board automation

## Testing Strategy

### E2E Tests (Cypress + Kind)

**Purpose**: Automated end-to-end testing of the complete vTeam stack in a Kubernetes environment.

**Location**: `e2e/`

**Quick Start**:

```bash
make e2e-test CONTAINER_ENGINE=podman  # Or docker
```

**What Gets Tested**:

- ✅ Full vTeam deployment in kind (Kubernetes in Docker)
- ✅ Frontend UI rendering and navigation
- ✅ Backend API connectivity
- ✅ Project creation workflow (main user journey)
- ✅ Authentication with ServiceAccount tokens
- ✅ Ingress routing
- ✅ All pods deploy and become ready

**What Doesn't Get Tested**:

- ❌ OAuth proxy flow (uses direct token auth for simplicity)
- ❌ Session pod execution (requires Anthropic API key)
- ❌ Multi-user scenarios

**Test Suite** (`e2e/cypress/e2e/vteam.cy.ts`):

1. UI loads with token authentication
2. Navigate to new project page
3. Create a new project
4. List created projects
5. Backend API cluster-info endpoint

**CI Integration**: Tests run automatically on all PRs via GitHub Actions (`.github/workflows/e2e.yml`)

**Key Implementation Details**:

- **Architecture**: Frontend without oauth-proxy, direct token injection via environment variables
- **Authentication**: Test user ServiceAccount with cluster-admin permissions
- **Token Handling**: Frontend deployment includes `OC_TOKEN`, `OC_USER`, `OC_EMAIL` env vars
- **Podman Support**: Auto-detects runtime, uses ports 8080/8443 for rootless Podman
- **Ingress**: Standard nginx-ingress with path-based routing

**Adding New Tests**:

```typescript
it('should test new feature', () => {
  cy.visit('/some-page')
  cy.contains('Expected Content').should('be.visible')
  cy.get('#button').click()
  // Auth header automatically injected via beforeEach interceptor
})
```

**Debugging Tests**:

```bash
cd e2e
source .env.test
CYPRESS_TEST_TOKEN="$TEST_TOKEN" CYPRESS_BASE_URL="http://vteam.local:8080" npm run test:headed
```

**Documentation**: See `e2e/README.md` and `docs/testing/e2e-guide.md` for comprehensive testing guide.

### Backend Tests (Go)

- **Unit tests** (`tests/unit/`): Isolated component logic
- **Contract tests** (`tests/contract/`): API contract validation
- **Integration tests** (`tests/integration/`): End-to-end with real k8s cluster
  - Requires `TEST_NAMESPACE` environment variable
  - Set `CLEANUP_RESOURCES=true` for automatic cleanup
  - Permission tests validate RBAC boundaries

### Frontend Tests (NextJS)

- Jest for component testing (when configured)
- Cypress for e2e testing (see E2E Tests section above)

### Operator Tests (Go)

- Controller reconciliation logic tests
- CRD validation tests

## Documentation Structure

The MkDocs site (`mkdocs.yml`) provides:

- **User Guide**: Getting started, RFE creation, agent framework, configuration
- **Developer Guide**: Setup, architecture, plugin development, API reference, testing
- **Labs**: Hands-on exercises (basic → advanced → production)
  - Basic: First RFE, agent interaction, workflow basics
  - Advanced: Custom agents, workflow modification, integration testing
  - Production: Jira integration, OpenShift deployment, scaling
- **Reference**: Agent personas, API endpoints, configuration schema, glossary

### Director Training Labs

Special lab track for leadership training located in `docs/labs/director-training/`:

- Structured exercises for understanding the vTeam system from a strategic perspective
- Validation reports for tracking completion and understanding

## Production Considerations

### Security

- **API keys**: Store in Kubernetes Secrets, managed via ProjectSettings CR
- **RBAC**: Namespace-scoped isolation prevents cross-project access
- **OAuth integration**: OpenShift OAuth for cluster-based authentication (see `docs/OPENSHIFT_OAUTH.md`)
- **Network policies**: Component isolation and secure communication

### Monitoring

- **Health endpoints**: `/health` on backend API
- **Logs**: Structured logging with OpenShift integration
- **Metrics**: Prometheus-compatible (when configured)
- **Events**: Kubernetes events for operator actions

### Scaling

- **Horizontal Pod Autoscaling**: Configure based on CPU/memory
- **Job concurrency**: Operator manages concurrent session execution
- **Resource limits**: Set appropriate requests/limits per component
- **Multi-tenancy**: Project-based isolation with shared infrastructure

---

## Frontend Development Standards

**See `components/frontend/DESIGN_GUIDELINES.md` for complete frontend development patterns.**

### Critical Rules (Quick Reference)

1. **Zero `any` Types** - Use proper types, `unknown`, or generic constraints
2. **Shadcn UI Components Only** - Use `@/components/ui/*` components, no custom UI from scratch
3. **React Query for ALL Data Operations** - Use hooks from `@/services/queries/*`, no manual `fetch()`
4. **Use `type` over `interface`** - Always prefer `type` for type definitions
5. **Colocate Single-Use Components** - Keep page-specific components with their pages

### Pre-Commit Checklist for Frontend

Before committing frontend code:

- [ ] Zero `any` types (or justified with eslint-disable)
- [ ] All UI uses Shadcn components
- [ ] All data operations use React Query
- [ ] Components under 200 lines
- [ ] Single-use components colocated with their pages
- [ ] All buttons have loading states
- [ ] All lists have empty states
- [ ] All nested pages have breadcrumbs
- [ ] All routes have loading.tsx, error.tsx
- [ ] `npm run build` passes with 0 errors, 0 warnings
- [ ] All types use `type` instead of `interface`

### Reference Files

- `components/frontend/DESIGN_GUIDELINES.md` - Detailed patterns and examples
- `components/frontend/COMPONENT_PATTERNS.md` - Architecture patterns
- `components/frontend/src/components/ui/` - Available Shadcn components
- `components/frontend/src/services/` - API service layer examples
</file>

<file path="components/backend/main.go">
package main

import (
	"context"
	"log"
	"os"

	"ambient-code-backend/git"
	"ambient-code-backend/github"
	"ambient-code-backend/handlers"
	"ambient-code-backend/k8s"
	"ambient-code-backend/server"
	"ambient-code-backend/websocket"

	"github.com/joho/godotenv"
)

func main() {
	// Load environment from .env in development if present
	_ = godotenv.Overload(".env.local")
	_ = godotenv.Overload(".env")

	// Content service mode - minimal initialization, no K8s access needed
	if os.Getenv("CONTENT_SERVICE_MODE") == "true" {
		log.Println("Starting in CONTENT_SERVICE_MODE (no K8s client initialization)")

		// Initialize config to set StateBaseDir from environment
		server.InitConfig()

		// Only initialize what content service needs
		handlers.StateBaseDir = server.StateBaseDir
		handlers.GitPushRepo = git.PushRepo
		handlers.GitAbandonRepo = git.AbandonRepo
		handlers.GitDiffRepo = git.DiffRepo
		handlers.GitCheckMergeStatus = git.CheckMergeStatus
		handlers.GitPullRepo = git.PullRepo
		handlers.GitPushToRepo = git.PushToRepo
		handlers.GitCreateBranch = git.CreateBranch
		handlers.GitListRemoteBranches = git.ListRemoteBranches

		log.Printf("Content service using StateBaseDir: %s", server.StateBaseDir)

		if err := server.RunContentService(registerContentRoutes); err != nil {
			log.Fatalf("Content service error: %v", err)
		}
		return
	}

	// Normal server mode - full initialization
	log.Println("Starting in normal server mode with K8s client initialization")

	// Initialize components
	github.InitializeTokenManager()

	if err := server.InitK8sClients(); err != nil {
		log.Fatalf("Failed to initialize Kubernetes clients: %v", err)
	}

	server.InitConfig()

	// Initialize git package
	git.GetProjectSettingsResource = k8s.GetProjectSettingsResource
	git.GetGitHubInstallation = func(ctx context.Context, userID string) (interface{}, error) {
		return github.GetInstallation(ctx, userID)
	}
	git.GitHubTokenManager = github.Manager

	// Initialize content handlers
	handlers.StateBaseDir = server.StateBaseDir
	handlers.GitPushRepo = git.PushRepo
	handlers.GitAbandonRepo = git.AbandonRepo
	handlers.GitDiffRepo = git.DiffRepo
	handlers.GitCheckMergeStatus = git.CheckMergeStatus
	handlers.GitPullRepo = git.PullRepo
	handlers.GitPushToRepo = git.PushToRepo
	handlers.GitCreateBranch = git.CreateBranch
	handlers.GitListRemoteBranches = git.ListRemoteBranches

	// Initialize GitHub auth handlers
	handlers.K8sClient = server.K8sClient
	handlers.Namespace = server.Namespace
	handlers.GithubTokenManager = github.Manager

	// Initialize project handlers
	handlers.GetOpenShiftProjectResource = k8s.GetOpenShiftProjectResource
	handlers.K8sClientProjects = server.K8sClient         // Backend SA client for namespace operations
	handlers.DynamicClientProjects = server.DynamicClient // Backend SA dynamic client for Project operations

	// Initialize session handlers
	handlers.GetAgenticSessionV1Alpha1Resource = k8s.GetAgenticSessionV1Alpha1Resource
	handlers.DynamicClient = server.DynamicClient
	handlers.GetGitHubToken = git.GetGitHubToken
	handlers.DeriveRepoFolderFromURL = git.DeriveRepoFolderFromURL
	handlers.SendMessageToSession = websocket.SendMessageToSession

	// Initialize repo handlers
	handlers.GetK8sClientsForRequestRepo = handlers.GetK8sClientsForRequest
	handlers.GetGitHubTokenRepo = git.GetGitHubToken

	// Initialize middleware
	handlers.BaseKubeConfig = server.BaseKubeConfig
	handlers.K8sClientMw = server.K8sClient

	// Initialize websocket package
	websocket.StateBaseDir = server.StateBaseDir

	// Normal server mode
	if err := server.Run(registerRoutes); err != nil {
		log.Fatalf("Server error: %v", err)
	}
}
</file>

<file path="components/backend/routes.go">
package main

import (
	"ambient-code-backend/handlers"
	"ambient-code-backend/websocket"

	"github.com/gin-gonic/gin"
)

func registerContentRoutes(r *gin.Engine) {
	r.POST("/content/write", handlers.ContentWrite)
	r.GET("/content/file", handlers.ContentRead)
	r.GET("/content/list", handlers.ContentList)
	r.POST("/content/github/push", handlers.ContentGitPush)
	r.POST("/content/github/abandon", handlers.ContentGitAbandon)
	r.GET("/content/github/diff", handlers.ContentGitDiff)
	r.GET("/content/git-status", handlers.ContentGitStatus)
	r.POST("/content/git-configure-remote", handlers.ContentGitConfigureRemote)
	r.POST("/content/git-sync", handlers.ContentGitSync)
	r.GET("/content/workflow-metadata", handlers.ContentWorkflowMetadata)
	r.GET("/content/git-merge-status", handlers.ContentGitMergeStatus)
	r.POST("/content/git-pull", handlers.ContentGitPull)
	r.POST("/content/git-push", handlers.ContentGitPushToBranch)
	r.POST("/content/git-create-branch", handlers.ContentGitCreateBranch)
	r.GET("/content/git-list-branches", handlers.ContentGitListBranches)
}

func registerRoutes(r *gin.Engine) {
	// API routes
	api := r.Group("/api")
	{
		// Public endpoints (no auth required)
		api.GET("/workflows/ootb", handlers.ListOOTBWorkflows)

		api.POST("/projects/:projectName/agentic-sessions/:sessionName/github/token", handlers.MintSessionGitHubToken)

		projectGroup := api.Group("/projects/:projectName", handlers.ValidateProjectContext())
		{
			projectGroup.GET("/access", handlers.AccessCheck)
			projectGroup.GET("/users/forks", handlers.ListUserForks)
			projectGroup.POST("/users/forks", handlers.CreateUserFork)

			projectGroup.GET("/repo/tree", handlers.GetRepoTree)
			projectGroup.GET("/repo/blob", handlers.GetRepoBlob)
			projectGroup.GET("/repo/branches", handlers.ListRepoBranches)

			projectGroup.GET("/agentic-sessions", handlers.ListSessions)
			projectGroup.POST("/agentic-sessions", handlers.CreateSession)
			projectGroup.GET("/agentic-sessions/:sessionName", handlers.GetSession)
			projectGroup.PUT("/agentic-sessions/:sessionName", handlers.UpdateSession)
			projectGroup.PATCH("/agentic-sessions/:sessionName", handlers.PatchSession)
			projectGroup.DELETE("/agentic-sessions/:sessionName", handlers.DeleteSession)
			projectGroup.POST("/agentic-sessions/:sessionName/clone", handlers.CloneSession)
			projectGroup.POST("/agentic-sessions/:sessionName/start", handlers.StartSession)
			projectGroup.POST("/agentic-sessions/:sessionName/stop", handlers.StopSession)
			projectGroup.PUT("/agentic-sessions/:sessionName/status", handlers.UpdateSessionStatus)
			projectGroup.GET("/agentic-sessions/:sessionName/workspace", handlers.ListSessionWorkspace)
			projectGroup.GET("/agentic-sessions/:sessionName/workspace/*path", handlers.GetSessionWorkspaceFile)
			projectGroup.PUT("/agentic-sessions/:sessionName/workspace/*path", handlers.PutSessionWorkspaceFile)
			projectGroup.POST("/agentic-sessions/:sessionName/github/push", handlers.PushSessionRepo)
			projectGroup.POST("/agentic-sessions/:sessionName/github/abandon", handlers.AbandonSessionRepo)
			projectGroup.GET("/agentic-sessions/:sessionName/github/diff", handlers.DiffSessionRepo)
			projectGroup.GET("/agentic-sessions/:sessionName/git/status", handlers.GetGitStatus)
			projectGroup.POST("/agentic-sessions/:sessionName/git/configure-remote", handlers.ConfigureGitRemote)
			projectGroup.POST("/agentic-sessions/:sessionName/git/synchronize", handlers.SynchronizeGit)
			projectGroup.GET("/agentic-sessions/:sessionName/git/merge-status", handlers.GetGitMergeStatus)
			projectGroup.POST("/agentic-sessions/:sessionName/git/pull", handlers.GitPullSession)
			projectGroup.POST("/agentic-sessions/:sessionName/git/push", handlers.GitPushSession)
			projectGroup.POST("/agentic-sessions/:sessionName/git/create-branch", handlers.GitCreateBranchSession)
			projectGroup.GET("/agentic-sessions/:sessionName/git/list-branches", handlers.GitListBranchesSession)
			projectGroup.GET("/agentic-sessions/:sessionName/k8s-resources", handlers.GetSessionK8sResources)
			projectGroup.POST("/agentic-sessions/:sessionName/spawn-content-pod", handlers.SpawnContentPod)
			projectGroup.GET("/agentic-sessions/:sessionName/content-pod-status", handlers.GetContentPodStatus)
			projectGroup.DELETE("/agentic-sessions/:sessionName/content-pod", handlers.DeleteContentPod)
			projectGroup.POST("/agentic-sessions/:sessionName/workflow", handlers.SelectWorkflow)
			projectGroup.GET("/agentic-sessions/:sessionName/workflow/metadata", handlers.GetWorkflowMetadata)
			projectGroup.POST("/agentic-sessions/:sessionName/repos", handlers.AddRepo)
			projectGroup.DELETE("/agentic-sessions/:sessionName/repos/:repoName", handlers.RemoveRepo)

			projectGroup.GET("/sessions/:sessionId/ws", websocket.HandleSessionWebSocket)
			projectGroup.GET("/sessions/:sessionId/messages", websocket.GetSessionMessagesWS)
			// Removed: /messages/claude-format - Using SDK's built-in resume with persisted ~/.claude state
			projectGroup.POST("/sessions/:sessionId/messages", websocket.PostSessionMessageWS)

			projectGroup.GET("/permissions", handlers.ListProjectPermissions)
			projectGroup.POST("/permissions", handlers.AddProjectPermission)
			projectGroup.DELETE("/permissions/:subjectType/:subjectName", handlers.RemoveProjectPermission)

			projectGroup.GET("/keys", handlers.ListProjectKeys)
			projectGroup.POST("/keys", handlers.CreateProjectKey)
			projectGroup.DELETE("/keys/:keyId", handlers.DeleteProjectKey)

			projectGroup.GET("/secrets", handlers.ListNamespaceSecrets)
			projectGroup.GET("/runner-secrets", handlers.ListRunnerSecrets)
			projectGroup.PUT("/runner-secrets", handlers.UpdateRunnerSecrets)
			projectGroup.GET("/integration-secrets", handlers.ListIntegrationSecrets)
			projectGroup.PUT("/integration-secrets", handlers.UpdateIntegrationSecrets)
		}

		api.POST("/auth/github/install", handlers.LinkGitHubInstallationGlobal)
		api.GET("/auth/github/status", handlers.GetGitHubStatusGlobal)
		api.POST("/auth/github/disconnect", handlers.DisconnectGitHubGlobal)
		api.GET("/auth/github/user/callback", handlers.HandleGitHubUserOAuthCallback)

		// Cluster info endpoint (public, no auth required)
		api.GET("/cluster-info", handlers.GetClusterInfo)

		api.GET("/projects", handlers.ListProjects)
		api.POST("/projects", handlers.CreateProject)
		api.GET("/projects/:projectName", handlers.GetProject)
		api.PUT("/projects/:projectName", handlers.UpdateProject)
		api.DELETE("/projects/:projectName", handlers.DeleteProject)
	}

	// Health check endpoint
	r.GET("/health", handlers.Health)
}
</file>

<file path="components/backend/git/operations.go">
// Package git provides Git repository operations including cloning, forking, and PR creation.
package git

import (
	"archive/zip"
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/fs"
	"log"
	"net/http"
	"net/url"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/client-go/dynamic"
	"k8s.io/client-go/kubernetes"
)

// Package-level dependencies (set from main package)
var (
	GetProjectSettingsResource func() schema.GroupVersionResource
	GetGitHubInstallation      func(context.Context, string) (interface{}, error)
	GitHubTokenManager         interface{} // *GitHubTokenManager from main package
)

// ProjectSettings represents the project configuration
type ProjectSettings struct {
	RunnerSecret string
}

// DiffSummary holds summary counts from git diff --numstat
type DiffSummary struct {
	TotalAdded   int `json:"total_added"`
	TotalRemoved int `json:"total_removed"`
	FilesAdded   int `json:"files_added"`
	FilesRemoved int `json:"files_removed"`
}

// GetGitHubToken tries to get a GitHub token from GitHub App first, then falls back to project runner secret
func GetGitHubToken(ctx context.Context, k8sClient *kubernetes.Clientset, dynClient dynamic.Interface, project, userID string) (string, error) {
	// Try GitHub App first if available
	if GetGitHubInstallation != nil && GitHubTokenManager != nil {
		installation, err := GetGitHubInstallation(ctx, userID)
		if err == nil && installation != nil {
			// Use reflection-like approach to call MintInstallationTokenForHost
			// This requires the caller to set up the proper interface/struct
			type githubInstallation interface {
				GetInstallationID() int64
				GetHost() string
			}
			type tokenManager interface {
				MintInstallationTokenForHost(context.Context, int64, string) (string, time.Time, error)
			}

			if inst, ok := installation.(githubInstallation); ok {
				if mgr, ok := GitHubTokenManager.(tokenManager); ok {
					token, _, err := mgr.MintInstallationTokenForHost(ctx, inst.GetInstallationID(), inst.GetHost())
					if err == nil && token != "" {
						log.Printf("Using GitHub App token for user %s", userID)
						return token, nil
					}
					log.Printf("Failed to mint GitHub App token for user %s: %v", userID, err)
				}
			}
		}
	}

	// Fall back to project integration secret GITHUB_TOKEN (hardcoded secret name)
	if k8sClient == nil {
		log.Printf("Cannot read integration secret: k8s client is nil")
		return "", fmt.Errorf("no GitHub credentials available. Either connect GitHub App or configure GITHUB_TOKEN in integration secrets")
	}

	const secretName = "ambient-non-vertex-integrations"

	log.Printf("Attempting to read GITHUB_TOKEN from secret %s/%s", project, secretName)

	secret, err := k8sClient.CoreV1().Secrets(project).Get(ctx, secretName, v1.GetOptions{})
	if err != nil {
		log.Printf("Failed to get integration secret %s/%s: %v", project, secretName, err)
		return "", fmt.Errorf("no GitHub credentials available. Either connect GitHub App or configure GITHUB_TOKEN in integration secrets")
	}

	if secret.Data == nil {
		log.Printf("Secret %s/%s exists but Data is nil", project, secretName)
		return "", fmt.Errorf("no GitHub credentials available. Either connect GitHub App or configure GITHUB_TOKEN in integration secrets")
	}

	token, ok := secret.Data["GITHUB_TOKEN"]
	if !ok {
		log.Printf("Secret %s/%s exists but has no GITHUB_TOKEN key (available keys: %v)", project, secretName, getSecretKeys(secret.Data))
		return "", fmt.Errorf("no GitHub credentials available. Either connect GitHub App or configure GITHUB_TOKEN in integration secrets")
	}

	if len(token) == 0 {
		log.Printf("Secret %s/%s has GITHUB_TOKEN key but value is empty", project, secretName)
		return "", fmt.Errorf("no GitHub credentials available. Either connect GitHub App or configure GITHUB_TOKEN in integration secrets")
	}

	log.Printf("Using GITHUB_TOKEN from integration secret %s/%s", project, secretName)
	return string(token), nil
}

// getSecretKeys returns a list of keys from a secret's Data map for debugging
func getSecretKeys(data map[string][]byte) []string {
	keys := make([]string, 0, len(data))
	for k := range data {
		keys = append(keys, k)
	}
	return keys
}

// CheckRepoSeeding checks if a repo has been seeded by verifying .claude/commands/ and .specify/ exist
func CheckRepoSeeding(ctx context.Context, repoURL string, branch *string, githubToken string) (bool, map[string]interface{}, error) {
	owner, repo, err := ParseGitHubURL(repoURL)
	if err != nil {
		return false, nil, err
	}

	branchName := "main"
	if branch != nil && strings.TrimSpace(*branch) != "" {
		branchName = strings.TrimSpace(*branch)
	}

	claudeExists, err := checkGitHubPathExists(ctx, owner, repo, branchName, ".claude", githubToken)
	if err != nil {
		return false, nil, fmt.Errorf("failed to check .claude: %w", err)
	}

	// Check for .claude/commands directory (spec-kit slash commands)
	claudeCommandsExists, err := checkGitHubPathExists(ctx, owner, repo, branchName, ".claude/commands", githubToken)
	if err != nil {
		return false, nil, fmt.Errorf("failed to check .claude/commands: %w", err)
	}

	// Check for .claude/agents directory
	claudeAgentsExists, err := checkGitHubPathExists(ctx, owner, repo, branchName, ".claude/agents", githubToken)
	if err != nil {
		return false, nil, fmt.Errorf("failed to check .claude/agents: %w", err)
	}

	// Check for .specify directory (from spec-kit)
	specifyExists, err := checkGitHubPathExists(ctx, owner, repo, branchName, ".specify", githubToken)
	if err != nil {
		return false, nil, fmt.Errorf("failed to check .specify: %w", err)
	}

	details := map[string]interface{}{
		"claudeExists":         claudeExists,
		"claudeCommandsExists": claudeCommandsExists,
		"claudeAgentsExists":   claudeAgentsExists,
		"specifyExists":        specifyExists,
	}

	// Repo is properly seeded if all critical components exist
	isSeeded := claudeCommandsExists && claudeAgentsExists && specifyExists
	return isSeeded, details, nil
}

// ParseGitHubURL extracts owner and repo from a GitHub URL
func ParseGitHubURL(gitURL string) (owner, repo string, err error) {
	gitURL = strings.TrimSuffix(gitURL, ".git")

	if strings.Contains(gitURL, "github.com") {
		parts := strings.Split(gitURL, "github.com")
		if len(parts) != 2 {
			return "", "", fmt.Errorf("invalid GitHub URL")
		}
		path := strings.Trim(parts[1], "/:")
		pathParts := strings.Split(path, "/")
		if len(pathParts) < 2 {
			return "", "", fmt.Errorf("invalid GitHub URL path")
		}
		return pathParts[0], pathParts[1], nil
	}

	return "", "", fmt.Errorf("not a GitHub URL")
}

// IsProtectedBranch checks if a branch name is a protected branch
// Protected branches: main, master, develop
func IsProtectedBranch(branchName string) bool {
	protected := []string{"main", "master", "develop"}
	normalized := strings.ToLower(strings.TrimSpace(branchName))
	for _, p := range protected {
		if normalized == p {
			return true
		}
	}
	return false
}

// ValidateBranchName validates a user-provided branch name
// Returns an error if the branch name is protected or invalid
func ValidateBranchName(branchName string) error {
	normalized := strings.TrimSpace(branchName)
	if normalized == "" {
		return fmt.Errorf("branch name cannot be empty")
	}
	if IsProtectedBranch(normalized) {
		return fmt.Errorf("'%s' is a protected branch name. Please use a different branch name", normalized)
	}
	return nil
}

// checkGitHubPathExists checks if a path exists in a GitHub repo
func checkGitHubPathExists(ctx context.Context, owner, repo, branch, path, token string) (bool, error) {
	apiURL := fmt.Sprintf("https://api.github.com/repos/%s/%s/contents/%s?ref=%s",
		owner, repo, path, branch)

	req, err := http.NewRequestWithContext(ctx, "GET", apiURL, nil)
	if err != nil {
		return false, err
	}

	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("Accept", "application/vnd.github.v3+json")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return false, err
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusOK {
		return true, nil
	}
	if resp.StatusCode == http.StatusNotFound {
		return false, nil
	}

	body, _ := io.ReadAll(resp.Body)
	return false, fmt.Errorf("GitHub API error: %s (body: %s)", resp.Status, string(body))
}

// GitRepo interface for repository information
type GitRepo interface {
	GetURL() string
	GetBranch() *string
}

// Workflow interface for RFE workflows
type Workflow interface {
	GetUmbrellaRepo() GitRepo
	GetSupportingRepos() []GitRepo
}

// PerformRepoSeeding performs the actual seeding operations
// wf parameter should implement the Workflow interface
// Returns: branchExisted (bool), error
func PerformRepoSeeding(ctx context.Context, wf Workflow, branchName, githubToken, agentURL, agentBranch, agentPath, specKitRepo, specKitVersion, specKitTemplate string) (bool, error) {
	umbrellaRepo := wf.GetUmbrellaRepo()
	if umbrellaRepo == nil {
		return false, fmt.Errorf("workflow has no spec repo")
	}

	if branchName == "" {
		return false, fmt.Errorf("branchName is required")
	}

	umbrellaDir, err := os.MkdirTemp("", "umbrella-*")
	if err != nil {
		return false, fmt.Errorf("failed to create temp dir for spec repo: %w", err)
	}
	defer os.RemoveAll(umbrellaDir)

	agentSrcDir, err := os.MkdirTemp("", "agents-*")
	if err != nil {
		return false, fmt.Errorf("failed to create temp dir for agent source: %w", err)
	}
	defer os.RemoveAll(agentSrcDir)

	// Clone umbrella repo with authentication
	log.Printf("Cloning umbrella repo: %s", umbrellaRepo.GetURL())
	authenticatedURL, err := InjectGitHubToken(umbrellaRepo.GetURL(), githubToken)
	if err != nil {
		return false, fmt.Errorf("failed to prepare spec repo URL: %w", err)
	}

	// Clone base branch (the branch from which feature branch will be created)
	baseBranch := "main"
	if branch := umbrellaRepo.GetBranch(); branch != nil && strings.TrimSpace(*branch) != "" {
		baseBranch = strings.TrimSpace(*branch)
	}

	log.Printf("Verifying base branch '%s' exists before cloning", baseBranch)

	// Verify base branch exists before trying to clone
	verifyCmd := exec.CommandContext(ctx, "git", "ls-remote", "--heads", authenticatedURL, baseBranch)
	verifyOut, verifyErr := verifyCmd.CombinedOutput()
	if verifyErr != nil || strings.TrimSpace(string(verifyOut)) == "" {
		return false, fmt.Errorf("base branch '%s' does not exist in repository. Please ensure the base branch exists before seeding", baseBranch)
	}

	umbrellaArgs := []string{"clone", "--depth", "1", "--branch", baseBranch, authenticatedURL, umbrellaDir}

	cmd := exec.CommandContext(ctx, "git", umbrellaArgs...)
	if out, err := cmd.CombinedOutput(); err != nil {
		return false, fmt.Errorf("failed to clone base branch '%s': %w (output: %s)", baseBranch, err, string(out))
	}

	// Configure git user
	cmd = exec.CommandContext(ctx, "git", "-C", umbrellaDir, "config", "user.email", "vteam-bot@ambient-code.io")
	if out, err := cmd.CombinedOutput(); err != nil {
		log.Printf("Warning: failed to set git user.email: %v (output: %s)", err, string(out))
	}
	cmd = exec.CommandContext(ctx, "git", "-C", umbrellaDir, "config", "user.name", "vTeam Bot")
	if out, err := cmd.CombinedOutput(); err != nil {
		log.Printf("Warning: failed to set git user.name: %v (output: %s)", err, string(out))
	}

	// Check if feature branch already exists remotely
	cmd = exec.CommandContext(ctx, "git", "-C", umbrellaDir, "ls-remote", "--heads", "origin", branchName)
	lsRemoteOut, lsRemoteErr := cmd.CombinedOutput()
	branchExistsRemotely := lsRemoteErr == nil && strings.TrimSpace(string(lsRemoteOut)) != ""

	if branchExistsRemotely {
		// Branch exists - check it out instead of creating new
		log.Printf("⚠️  Branch '%s' already exists remotely - checking out existing branch", branchName)
		log.Printf("⚠️  This RFE will modify the existing branch '%s'", branchName)

		// Check if the branch is already checked out (happens when base branch == feature branch)
		if baseBranch == branchName {
			log.Printf("Feature branch '%s' is the same as base branch - already checked out", branchName)
		} else {
			// Fetch the specific branch with depth (works with shallow clones)
			// Format: git fetch --depth 1 origin <remote-branch>:<local-branch>
			cmd = exec.CommandContext(ctx, "git", "-C", umbrellaDir, "fetch", "--depth", "1", "origin", fmt.Sprintf("%s:%s", branchName, branchName))
			if out, err := cmd.CombinedOutput(); err != nil {
				return false, fmt.Errorf("failed to fetch existing branch %s: %w (output: %s)", branchName, err, string(out))
			}

			// Checkout the fetched branch
			cmd = exec.CommandContext(ctx, "git", "-C", umbrellaDir, "checkout", branchName)
			if out, err := cmd.CombinedOutput(); err != nil {
				return false, fmt.Errorf("failed to checkout existing branch %s: %w (output: %s)", branchName, err, string(out))
			}
		}
	} else {
		// Branch doesn't exist remotely
		// Check if we're already on the feature branch (happens when base branch == feature branch)
		if baseBranch == branchName {
			log.Printf("Feature branch '%s' is the same as base branch - already on this branch", branchName)
		} else {
			// Create new feature branch from the current base branch
			log.Printf("Creating new feature branch: %s", branchName)
			cmd = exec.CommandContext(ctx, "git", "-C", umbrellaDir, "checkout", "-b", branchName)
			if out, err := cmd.CombinedOutput(); err != nil {
				return false, fmt.Errorf("failed to create branch %s: %w (output: %s)", branchName, err, string(out))
			}
		}
	}

	// Download and extract spec-kit template
	log.Printf("Downloading spec-kit from repo: %s, version: %s", specKitRepo, specKitVersion)

	// Support both releases (vX.X.X) and branch archives (main, branch-name)
	var specKitURL string
	if strings.HasPrefix(specKitVersion, "v") {
		// It's a tagged release - use releases API
		specKitURL = fmt.Sprintf("https://github.com/%s/releases/download/%s/%s-%s.zip",
			specKitRepo, specKitVersion, specKitTemplate, specKitVersion)
		log.Printf("Downloading spec-kit release: %s", specKitURL)
	} else {
		// It's a branch name - use archive API
		specKitURL = fmt.Sprintf("https://github.com/%s/archive/refs/heads/%s.zip",
			specKitRepo, specKitVersion)
		log.Printf("Downloading spec-kit branch archive: %s", specKitURL)
	}

	resp, err := http.Get(specKitURL)
	if err != nil {
		return false, fmt.Errorf("failed to download spec-kit: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return false, fmt.Errorf("spec-kit download failed with status: %s", resp.Status)
	}

	zipData, err := io.ReadAll(resp.Body)
	if err != nil {
		return false, fmt.Errorf("failed to read spec-kit zip: %w", err)
	}

	zr, err := zip.NewReader(bytes.NewReader(zipData), int64(len(zipData)))
	if err != nil {
		return false, fmt.Errorf("failed to open spec-kit zip: %w", err)
	}

	// Extract spec-kit files
	specKitFilesAdded := 0
	for _, f := range zr.File {
		if f.FileInfo().IsDir() {
			continue
		}

		rel := strings.TrimPrefix(f.Name, "./")
		rel = strings.ReplaceAll(rel, "\\", "/")

		// Strip archive prefix from branch downloads (e.g., "spec-kit-rh-vteam-flexible-branches/")
		// Branch archives have format: "repo-branch-name/file", releases have just "file"
		if strings.Contains(rel, "/") && !strings.HasPrefix(specKitVersion, "v") {
			parts := strings.SplitN(rel, "/", 2)
			if len(parts) == 2 {
				rel = parts[1] // Take everything after first "/"
			}
		}

		// Only extract files needed for umbrella repos (matching official spec-kit release template):
		// - templates/commands/ → .claude/commands/
		// - scripts/bash/ → .specify/scripts/bash/
		// - templates/*.md → .specify/templates/
		// - memory/ → .specify/memory/
		// Skip everything else (docs/, media/, root files, .github/, scripts/powershell/, etc.)

		var targetRel string
		if strings.HasPrefix(rel, "templates/commands/") {
			// Map templates/commands/*.md to .claude/commands/speckit.*.md
			cmdFile := strings.TrimPrefix(rel, "templates/commands/")
			if !strings.HasPrefix(cmdFile, "speckit.") {
				cmdFile = "speckit." + cmdFile
			}
			targetRel = ".claude/commands/" + cmdFile
		} else if strings.HasPrefix(rel, "scripts/bash/") {
			// Map scripts/bash/ to .specify/scripts/bash/
			targetRel = strings.Replace(rel, "scripts/bash/", ".specify/scripts/bash/", 1)
		} else if strings.HasPrefix(rel, "templates/") && strings.HasSuffix(rel, ".md") {
			// Map templates/*.md to .specify/templates/
			targetRel = strings.Replace(rel, "templates/", ".specify/templates/", 1)
		} else if strings.HasPrefix(rel, "memory/") {
			// Map memory/ to .specify/memory/
			targetRel = ".specify/" + rel
		} else {
			// Skip all other files (docs/, media/, root files, .github/, scripts/powershell/, etc.)
			continue
		}

		// Security: prevent path traversal
		for strings.Contains(targetRel, "../") {
			targetRel = strings.ReplaceAll(targetRel, "../", "")
		}

		targetPath := filepath.Join(umbrellaDir, targetRel)

		if _, err := os.Stat(targetPath); err == nil {
			continue
		}

		if err := os.MkdirAll(filepath.Dir(targetPath), 0755); err != nil {
			log.Printf("Failed to create dir for %s: %v", rel, err)
			continue
		}

		rc, err := f.Open()
		if err != nil {
			log.Printf("Failed to open zip entry %s: %v", f.Name, err)
			continue
		}
		content, err := io.ReadAll(rc)
		rc.Close()
		if err != nil {
			log.Printf("Failed to read zip entry %s: %v", f.Name, err)
			continue
		}

		// Preserve executable permissions for scripts
		fileMode := fs.FileMode(0644)
		if strings.HasPrefix(targetRel, ".specify/scripts/") {
			// Scripts need to be executable
			fileMode = 0755
		} else if f.Mode().Perm()&0111 != 0 {
			// Preserve executable bit from zip if it was set
			fileMode = 0755
		}

		if err := os.WriteFile(targetPath, content, fileMode); err != nil {
			log.Printf("Failed to write %s: %v", targetPath, err)
			continue
		}
		specKitFilesAdded++
	}
	log.Printf("Extracted %d spec-kit files", specKitFilesAdded)

	// Clone agent source repo
	log.Printf("Cloning agent source: %s", agentURL)
	agentArgs := []string{"clone", "--depth", "1"}
	if agentBranch != "" {
		agentArgs = append(agentArgs, "--branch", agentBranch)
	}
	agentArgs = append(agentArgs, agentURL, agentSrcDir)

	cmd = exec.CommandContext(ctx, "git", agentArgs...)
	if out, err := cmd.CombinedOutput(); err != nil {
		return false, fmt.Errorf("failed to clone agent source: %w (output: %s)", err, string(out))
	}

	// Copy agent markdown files to .claude/agents/
	agentSourcePath := filepath.Join(agentSrcDir, agentPath)
	claudeDir := filepath.Join(umbrellaDir, ".claude")
	claudeAgentsDir := filepath.Join(claudeDir, "agents")
	if err := os.MkdirAll(claudeAgentsDir, 0755); err != nil {
		return false, fmt.Errorf("failed to create .claude/agents directory: %w", err)
	}

	agentsCopied := 0
	err = filepath.WalkDir(agentSourcePath, func(path string, d fs.DirEntry, err error) error {
		if err != nil || d.IsDir() {
			return nil
		}
		if !strings.HasSuffix(strings.ToLower(d.Name()), ".md") {
			return nil
		}

		content, err := os.ReadFile(path)
		if err != nil {
			log.Printf("Failed to read agent file %s: %v", path, err)
			return nil
		}

		targetPath := filepath.Join(claudeAgentsDir, d.Name())
		if err := os.WriteFile(targetPath, content, 0644); err != nil {
			log.Printf("Failed to write agent file %s: %v", targetPath, err)
			return nil
		}
		agentsCopied++
		return nil
	})
	if err != nil {
		return false, fmt.Errorf("failed to copy agents: %w", err)
	}
	log.Printf("Copied %d agent files", agentsCopied)

	// Create specs directory for feature work
	specsDir := filepath.Join(umbrellaDir, "specs", branchName)
	if err := os.MkdirAll(specsDir, 0755); err != nil {
		return false, fmt.Errorf("failed to create specs/%s directory: %w", branchName, err)
	}
	log.Printf("Created specs/%s directory", branchName)

	// Commit and push changes to feature branch
	cmd = exec.CommandContext(ctx, "git", "-C", umbrellaDir, "add", ".")
	if out, err := cmd.CombinedOutput(); err != nil {
		return false, fmt.Errorf("git add failed: %w (output: %s)", err, string(out))
	}

	cmd = exec.CommandContext(ctx, "git", "-C", umbrellaDir, "diff", "--cached", "--quiet")
	if err := cmd.Run(); err == nil {
		log.Printf("No changes to commit for seeding, but will still push branch")
	} else {
		// Commit with branch-specific message
		commitMsg := fmt.Sprintf("chore: initialize %s with spec-kit and agents", branchName)
		cmd = exec.CommandContext(ctx, "git", "-C", umbrellaDir, "commit", "-m", commitMsg)
		if out, err := cmd.CombinedOutput(); err != nil {
			return false, fmt.Errorf("git commit failed: %w (output: %s)", err, string(out))
		}
	}

	cmd = exec.CommandContext(ctx, "git", "-C", umbrellaDir, "remote", "set-url", "origin", authenticatedURL)
	if out, err := cmd.CombinedOutput(); err != nil {
		return false, fmt.Errorf("failed to set remote URL: %w (output: %s)", err, string(out))
	}

	// Push feature branch to origin
	cmd = exec.CommandContext(ctx, "git", "-C", umbrellaDir, "push", "-u", "origin", branchName)
	if out, err := cmd.CombinedOutput(); err != nil {
		return false, fmt.Errorf("git push failed: %w (output: %s)", err, string(out))
	}

	log.Printf("Successfully seeded umbrella repo on branch %s", branchName)

	// Create feature branch in all supporting repos
	// Push access will be validated by the actual git operations - if they fail, we'll get a clear error
	supportingRepos := wf.GetSupportingRepos()
	if len(supportingRepos) > 0 {
		log.Printf("Creating feature branch %s in %d supporting repos", branchName, len(supportingRepos))
		for i, repo := range supportingRepos {
			if err := createBranchInRepo(ctx, repo, branchName, githubToken); err != nil {
				return false, fmt.Errorf("failed to create branch in supporting repo #%d (%s): %w", i+1, repo.GetURL(), err)
			}
		}
	}

	return branchExistsRemotely, nil
}

// InjectGitHubToken injects a GitHub token into a git URL for authentication
func InjectGitHubToken(gitURL, token string) (string, error) {
	u, err := url.Parse(gitURL)
	if err != nil {
		return "", fmt.Errorf("invalid git URL: %w", err)
	}

	if u.Scheme != "https" {
		return gitURL, nil
	}

	u.User = url.UserPassword("x-access-token", token)
	return u.String(), nil
}

// DeriveRepoFolderFromURL extracts the repo folder from a Git URL
func DeriveRepoFolderFromURL(u string) string {
	s := strings.TrimSpace(u)
	if s == "" {
		return ""
	}

	if strings.HasPrefix(s, "git@") && strings.Contains(s, ":") {
		parts := strings.SplitN(s, ":", 2)
		host := strings.TrimPrefix(parts[0], "git@")
		s = "https://" + host + "/" + parts[1]
	}

	if i := strings.Index(s, "://"); i >= 0 {
		s = s[i+3:]
	}

	if i := strings.Index(s, "/"); i >= 0 {
		s = s[i+1:]
	}

	segs := strings.Split(s, "/")
	if len(segs) == 0 {
		return ""
	}

	last := segs[len(segs)-1]
	last = strings.TrimSuffix(last, ".git")
	return strings.TrimSpace(last)
}

// PushRepo performs git add/commit/push operations on a repository directory
func PushRepo(ctx context.Context, repoDir, commitMessage, outputRepoURL, branch, githubToken string) (string, error) {
	if fi, err := os.Stat(repoDir); err != nil || !fi.IsDir() {
		return "", fmt.Errorf("repo directory not found: %s", repoDir)
	}

	run := func(args ...string) (string, string, error) {
		start := time.Now()
		cmd := exec.CommandContext(ctx, args[0], args[1:]...)
		cmd.Dir = repoDir
		var stdout, stderr bytes.Buffer
		cmd.Stdout = &stdout
		cmd.Stderr = &stderr
		err := cmd.Run()
		dur := time.Since(start)
		log.Printf("gitPushRepo: exec dur=%s cmd=%q stderr.len=%d stdout.len=%d err=%v", dur, strings.Join(args, " "), len(stderr.Bytes()), len(stdout.Bytes()), err)
		return stdout.String(), stderr.String(), err
	}

	log.Printf("gitPushRepo: checking worktree status ...")
	if out, _, _ := run("git", "status", "--porcelain"); strings.TrimSpace(out) == "" {
		return "", nil
	}

	// Configure git user identity from GitHub API
	gitUserName := ""
	gitUserEmail := ""

	if githubToken != "" {
		req, _ := http.NewRequest("GET", "https://api.github.com/user", nil)
		req.Header.Set("Authorization", "token "+githubToken)
		req.Header.Set("Accept", "application/vnd.github+json")
		resp, err := http.DefaultClient.Do(req)
		if err == nil {
			defer resp.Body.Close()
			switch resp.StatusCode {
			case 200:
				var ghUser struct {
					Login string `json:"login"`
					Name  string `json:"name"`
					Email string `json:"email"`
				}
				if json.Unmarshal([]byte(fmt.Sprintf("%v", resp.Body)), &ghUser) == nil {
					if gitUserName == "" && ghUser.Name != "" {
						gitUserName = ghUser.Name
					} else if gitUserName == "" && ghUser.Login != "" {
						gitUserName = ghUser.Login
					}
					if gitUserEmail == "" && ghUser.Email != "" {
						gitUserEmail = ghUser.Email
					}
					log.Printf("gitPushRepo: fetched GitHub user name=%q email=%q", gitUserName, gitUserEmail)
				}
			case 403:
				log.Printf("gitPushRepo: GitHub API /user returned 403 (token lacks 'read:user' scope, using fallback identity)")
			default:
				log.Printf("gitPushRepo: GitHub API /user returned status %d", resp.StatusCode)
			}
		} else {
			log.Printf("gitPushRepo: failed to fetch GitHub user: %v", err)
		}
	}

	if gitUserName == "" {
		gitUserName = "Ambient Code Bot"
	}
	if gitUserEmail == "" {
		gitUserEmail = "bot@ambient-code.local"
	}
	run("git", "config", "user.name", gitUserName)
	run("git", "config", "user.email", gitUserEmail)
	log.Printf("gitPushRepo: configured git identity name=%q email=%q", gitUserName, gitUserEmail)

	// Stage and commit
	log.Printf("gitPushRepo: staging changes ...")
	_, _, _ = run("git", "add", "-A")

	cm := commitMessage
	if strings.TrimSpace(cm) == "" {
		cm = "Update from Ambient session"
	}

	log.Printf("gitPushRepo: committing changes ...")
	commitOut, commitErr, commitErrCode := run("git", "commit", "-m", cm)
	if commitErrCode != nil {
		log.Printf("gitPushRepo: commit failed (continuing): err=%v stderr=%q stdout=%q", commitErrCode, commitErr, commitOut)
	}

	// Determine target refspec
	ref := "HEAD"
	if branch == "auto" {
		cur, _, _ := run("git", "rev-parse", "--abbrev-ref", "HEAD")
		br := strings.TrimSpace(cur)
		if br == "" || br == "HEAD" {
			branch = "ambient-session"
			log.Printf("gitPushRepo: auto branch resolved to %q", branch)
		} else {
			branch = br
		}
	}
	if branch != "auto" {
		ref = "HEAD:" + branch
	}

	// Push with token authentication
	var pushArgs []string
	if githubToken != "" {
		cfg := fmt.Sprintf("url.https://x-access-token:%s@github.com/.insteadOf=https://github.com/", githubToken)
		pushArgs = []string{"git", "-c", cfg, "push", "-u", outputRepoURL, ref}
		log.Printf("gitPushRepo: running git push with token auth to %s %s", outputRepoURL, ref)
	} else {
		pushArgs = []string{"git", "push", "-u", outputRepoURL, ref}
		log.Printf("gitPushRepo: running git push %s %s in %s", outputRepoURL, ref, repoDir)
	}

	out, errOut, err := run(pushArgs...)
	if err != nil {
		serr := errOut
		if len(serr) > 2000 {
			serr = serr[:2000] + "..."
		}
		sout := out
		if len(sout) > 2000 {
			sout = sout[:2000] + "..."
		}
		log.Printf("gitPushRepo: push failed url=%q ref=%q err=%v stderr.snip=%q stdout.snip=%q", outputRepoURL, ref, err, serr, sout)
		return "", fmt.Errorf("push failed: %s", errOut)
	}

	if len(out) > 2000 {
		out = out[:2000] + "..."
	}
	log.Printf("gitPushRepo: push ok url=%q ref=%q stdout.snip=%q", outputRepoURL, ref, out)
	return out, nil
}

// AbandonRepo discards all uncommitted changes in a repository directory
func AbandonRepo(ctx context.Context, repoDir string) error {
	if fi, err := os.Stat(repoDir); err != nil || !fi.IsDir() {
		return fmt.Errorf("repo directory not found: %s", repoDir)
	}

	run := func(args ...string) (string, string, error) {
		cmd := exec.CommandContext(ctx, args[0], args[1:]...)
		cmd.Dir = repoDir
		var stdout, stderr bytes.Buffer
		cmd.Stdout = &stdout
		cmd.Stderr = &stderr
		err := cmd.Run()
		return stdout.String(), stderr.String(), err
	}

	log.Printf("gitAbandonRepo: git reset --hard in %s", repoDir)
	_, _, _ = run("git", "reset", "--hard")
	log.Printf("gitAbandonRepo: git clean -fd in %s", repoDir)
	_, _, _ = run("git", "clean", "-fd")
	return nil
}

// DiffRepo returns diff statistics comparing working directory to HEAD
func DiffRepo(ctx context.Context, repoDir string) (*DiffSummary, error) {
	// Validate repoDir exists
	if fi, err := os.Stat(repoDir); err != nil || !fi.IsDir() {
		return &DiffSummary{}, nil
	}

	run := func(args ...string) (string, error) {
		cmd := exec.CommandContext(ctx, args[0], args[1:]...)
		cmd.Dir = repoDir
		var stdout bytes.Buffer
		cmd.Stdout = &stdout
		cmd.Stderr = &stdout
		if err := cmd.Run(); err != nil {
			return "", err
		}
		return stdout.String(), nil
	}

	summary := &DiffSummary{}

	// Get numstat for modified tracked files (working tree vs HEAD)
	numstatOut, err := run("git", "diff", "--numstat", "HEAD")
	if err == nil && strings.TrimSpace(numstatOut) != "" {
		lines := strings.Split(strings.TrimSpace(numstatOut), "\n")
		for _, ln := range lines {
			if ln == "" {
				continue
			}
			parts := strings.Fields(ln)
			if len(parts) < 3 {
				continue
			}
			added, removed := parts[0], parts[1]
			// Parse additions
			if added != "-" {
				var n int
				fmt.Sscanf(added, "%d", &n)
				summary.TotalAdded += n
			}
			// Parse deletions
			if removed != "-" {
				var n int
				fmt.Sscanf(removed, "%d", &n)
				summary.TotalRemoved += n
			}
			// If file was deleted (0 added, all removed), count as removed file
			if added == "0" && removed != "0" {
				summary.FilesRemoved++
			}
		}
	}

	// Get untracked files (new files not yet added to git)
	untrackedOut, err := run("git", "ls-files", "--others", "--exclude-standard")
	if err == nil && strings.TrimSpace(untrackedOut) != "" {
		untrackedFiles := strings.Split(strings.TrimSpace(untrackedOut), "\n")
		for _, filePath := range untrackedFiles {
			if filePath == "" {
				continue
			}
			// Count lines in the untracked file
			fullPath := filepath.Join(repoDir, filePath)
			if data, err := os.ReadFile(fullPath); err == nil {
				// Count lines (all lines in a new file are "added")
				lineCount := strings.Count(string(data), "\n")
				if len(data) > 0 && !strings.HasSuffix(string(data), "\n") {
					lineCount++ // Count last line if it doesn't end with newline
				}
				summary.TotalAdded += lineCount
				summary.FilesAdded++
			}
		}
	}

	log.Printf("gitDiffRepo: files_added=%d files_removed=%d total_added=%d total_removed=%d",
		summary.FilesAdded, summary.FilesRemoved, summary.TotalAdded, summary.TotalRemoved)
	return summary, nil
}

// ReadGitHubFile reads the content of a file from a GitHub repository
func ReadGitHubFile(ctx context.Context, owner, repo, branch, path, token string) ([]byte, error) {
	apiURL := fmt.Sprintf("https://api.github.com/repos/%s/%s/contents/%s?ref=%s",
		owner, repo, path, branch)

	req, err := http.NewRequestWithContext(ctx, "GET", apiURL, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("Accept", "application/vnd.github.v3.raw")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("GitHub API error: %s (body: %s)", resp.Status, string(body))
	}

	return io.ReadAll(resp.Body)
}

// CheckBranchExists checks if a branch exists in a GitHub repository
func CheckBranchExists(ctx context.Context, repoURL, branchName, githubToken string) (bool, error) {
	owner, repo, err := ParseGitHubURL(repoURL)
	if err != nil {
		return false, err
	}

	apiURL := fmt.Sprintf("https://api.github.com/repos/%s/%s/git/refs/heads/%s",
		owner, repo, branchName)

	req, err := http.NewRequestWithContext(ctx, "GET", apiURL, nil)
	if err != nil {
		return false, err
	}

	req.Header.Set("Authorization", "Bearer "+githubToken)
	req.Header.Set("Accept", "application/vnd.github.v3+json")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return false, err
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusOK {
		return true, nil
	}
	if resp.StatusCode == http.StatusNotFound {
		return false, nil
	}

	body, _ := io.ReadAll(resp.Body)
	return false, fmt.Errorf("GitHub API error: %s (body: %s)", resp.Status, string(body))
}

// createBranchInRepo creates a feature branch in a supporting repository
// Follows the same pattern as umbrella repo seeding but without adding files
// Note: This function assumes push access has already been validated by the caller
func createBranchInRepo(ctx context.Context, repo GitRepo, branchName, githubToken string) error {
	repoURL := repo.GetURL()
	if repoURL == "" {
		return fmt.Errorf("repository URL is empty")
	}

	repoDir, err := os.MkdirTemp("", "supporting-repo-*")
	if err != nil {
		return fmt.Errorf("failed to create temp dir: %w", err)
	}
	defer os.RemoveAll(repoDir)

	authenticatedURL, err := InjectGitHubToken(repoURL, githubToken)
	if err != nil {
		return fmt.Errorf("failed to prepare repo URL: %w", err)
	}

	baseBranch := "main"
	if branch := repo.GetBranch(); branch != nil && strings.TrimSpace(*branch) != "" {
		baseBranch = strings.TrimSpace(*branch)
	}

	log.Printf("Cloning supporting repo: %s (branch: %s)", repoURL, baseBranch)
	cloneArgs := []string{"clone", "--depth", "1", "--branch", baseBranch, authenticatedURL, repoDir}
	cmd := exec.CommandContext(ctx, "git", cloneArgs...)
	if out, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to clone repo: %w (output: %s)", err, string(out))
	}

	cmd = exec.CommandContext(ctx, "git", "-C", repoDir, "config", "user.email", "vteam-bot@ambient-code.io")
	if out, err := cmd.CombinedOutput(); err != nil {
		log.Printf("Warning: failed to set git user.email: %v (output: %s)", err, string(out))
	}
	cmd = exec.CommandContext(ctx, "git", "-C", repoDir, "config", "user.name", "vTeam Bot")
	if out, err := cmd.CombinedOutput(); err != nil {
		log.Printf("Warning: failed to set git user.name: %v (output: %s)", err, string(out))
	}

	cmd = exec.CommandContext(ctx, "git", "-C", repoDir, "ls-remote", "--heads", "origin", branchName)
	lsRemoteOut, lsRemoteErr := cmd.CombinedOutput()
	branchExistsRemotely := lsRemoteErr == nil && strings.TrimSpace(string(lsRemoteOut)) != ""

	if branchExistsRemotely {
		log.Printf("Branch '%s' already exists in %s, skipping", branchName, repoURL)
		return nil
	}

	log.Printf("Creating feature branch '%s' in %s", branchName, repoURL)
	cmd = exec.CommandContext(ctx, "git", "-C", repoDir, "checkout", "-b", branchName)
	if out, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to create branch %s: %w (output: %s)", branchName, err, string(out))
	}

	cmd = exec.CommandContext(ctx, "git", "-C", repoDir, "remote", "set-url", "origin", authenticatedURL)
	if out, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to set remote URL: %w (output: %s)", err, string(out))
	}

	// Push using HEAD:branchName refspec to ensure the newly created local branch is pushed
	cmd = exec.CommandContext(ctx, "git", "-C", repoDir, "push", "-u", "origin", fmt.Sprintf("HEAD:%s", branchName))
	if out, err := cmd.CombinedOutput(); err != nil {
		// Check if it's a permission error
		errMsg := string(out)
		if strings.Contains(errMsg, "Permission denied") || strings.Contains(errMsg, "403") || strings.Contains(errMsg, "not authorized") {
			return fmt.Errorf("permission denied: you don't have push access to %s. Please provide a repository you can push to", repoURL)
		}
		return fmt.Errorf("failed to push branch: %w (output: %s)", err, errMsg)
	}

	log.Printf("Successfully created and pushed branch '%s' in %s", branchName, repoURL)
	return nil
}

// InitRepo initializes a new git repository
func InitRepo(ctx context.Context, repoDir string) error {
	cmd := exec.CommandContext(ctx, "git", "init")
	cmd.Dir = repoDir

	if out, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to init git repo: %w (output: %s)", err, string(out))
	}

	// Configure default user if not set
	cmd = exec.CommandContext(ctx, "git", "config", "user.name", "Ambient Code Bot")
	cmd.Dir = repoDir
	_ = cmd.Run() // Best effort

	cmd = exec.CommandContext(ctx, "git", "config", "user.email", "bot@ambient-code.local")
	cmd.Dir = repoDir
	_ = cmd.Run() // Best effort

	return nil
}

// ConfigureRemote adds or updates a git remote
func ConfigureRemote(ctx context.Context, repoDir, remoteName, remoteURL string) error {
	// Try to remove existing remote first
	cmd := exec.CommandContext(ctx, "git", "remote", "remove", remoteName)
	cmd.Dir = repoDir
	_ = cmd.Run() // Ignore error if remote doesn't exist

	// Add the remote
	cmd = exec.CommandContext(ctx, "git", "remote", "add", remoteName, remoteURL)
	cmd.Dir = repoDir

	if out, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to add remote: %w (output: %s)", err, string(out))
	}

	return nil
}

// MergeStatus contains information about merge conflict status
type MergeStatus struct {
	CanMergeClean      bool     `json:"canMergeClean"`
	LocalChanges       int      `json:"localChanges"`
	RemoteCommitsAhead int      `json:"remoteCommitsAhead"`
	ConflictingFiles   []string `json:"conflictingFiles"`
	RemoteBranchExists bool     `json:"remoteBranchExists"`
}

// CheckMergeStatus checks if local and remote can merge cleanly
func CheckMergeStatus(ctx context.Context, repoDir, branch string) (*MergeStatus, error) {
	if branch == "" {
		branch = "main"
	}

	status := &MergeStatus{
		ConflictingFiles: []string{},
	}

	run := func(args ...string) (string, error) {
		cmd := exec.CommandContext(ctx, args[0], args[1:]...)
		cmd.Dir = repoDir
		var stdout bytes.Buffer
		cmd.Stdout = &stdout
		if err := cmd.Run(); err != nil {
			return stdout.String(), err
		}
		return stdout.String(), nil
	}

	// Fetch remote branch
	_, err := run("git", "fetch", "origin", branch)
	if err != nil {
		// Remote branch doesn't exist yet
		status.RemoteBranchExists = false
		status.CanMergeClean = true
		return status, nil
	}
	status.RemoteBranchExists = true

	// Count local uncommitted changes
	statusOut, _ := run("git", "status", "--porcelain")
	status.LocalChanges = len(strings.Split(strings.TrimSpace(statusOut), "\n"))
	if strings.TrimSpace(statusOut) == "" {
		status.LocalChanges = 0
	}

	// Count commits on remote but not local
	countOut, _ := run("git", "rev-list", "--count", "HEAD..origin/"+branch)
	fmt.Sscanf(strings.TrimSpace(countOut), "%d", &status.RemoteCommitsAhead)

	// Test merge to detect conflicts (dry run)
	mergeBase, err := run("git", "merge-base", "HEAD", "origin/"+branch)
	if err != nil {
		// No common ancestor - unrelated histories
		// This is NOT a conflict - we can merge with --allow-unrelated-histories
		// which is already used in PullRepo and SyncRepo
		status.CanMergeClean = true
		status.ConflictingFiles = []string{}
		return status, nil
	}

	// Use git merge-tree to simulate merge without touching working directory
	mergeTreeOut, err := run("git", "merge-tree", strings.TrimSpace(mergeBase), "HEAD", "origin/"+branch)
	if err == nil && strings.TrimSpace(mergeTreeOut) != "" {
		// Check for conflict markers in output
		if strings.Contains(mergeTreeOut, "<<<<<<<") {
			status.CanMergeClean = false
			// Parse conflicting files from merge-tree output
			for _, line := range strings.Split(mergeTreeOut, "\n") {
				if strings.HasPrefix(line, "--- a/") || strings.HasPrefix(line, "+++ b/") {
					file := strings.TrimPrefix(strings.TrimPrefix(line, "--- a/"), "+++ b/")
					if file != "" && !contains(status.ConflictingFiles, file) {
						status.ConflictingFiles = append(status.ConflictingFiles, file)
					}
				}
			}
		} else {
			status.CanMergeClean = true
		}
	} else {
		status.CanMergeClean = true
	}

	return status, nil
}

// PullRepo pulls changes from remote branch
func PullRepo(ctx context.Context, repoDir, branch string) error {
	if branch == "" {
		branch = "main"
	}

	cmd := exec.CommandContext(ctx, "git", "pull", "--allow-unrelated-histories", "origin", branch)
	cmd.Dir = repoDir

	if out, err := cmd.CombinedOutput(); err != nil {
		outStr := string(out)
		if strings.Contains(outStr, "CONFLICT") {
			return fmt.Errorf("merge conflicts detected: %s", outStr)
		}
		return fmt.Errorf("failed to pull: %w (output: %s)", err, outStr)
	}

	log.Printf("Successfully pulled from origin/%s", branch)
	return nil
}

// PushToRepo pushes local commits to specified branch
func PushToRepo(ctx context.Context, repoDir, branch, commitMessage string) error {
	if branch == "" {
		branch = "main"
	}

	run := func(args ...string) (string, error) {
		cmd := exec.CommandContext(ctx, args[0], args[1:]...)
		cmd.Dir = repoDir
		var stdout bytes.Buffer
		cmd.Stdout = &stdout
		cmd.Stderr = &stdout
		err := cmd.Run()
		return stdout.String(), err
	}

	// Ensure we're on the correct branch (create if needed)
	// This handles fresh git init repos that don't have a branch yet
	if _, err := run("git", "checkout", "-B", branch); err != nil {
		return fmt.Errorf("failed to checkout branch: %w", err)
	}

	// Stage all changes
	if _, err := run("git", "add", "."); err != nil {
		return fmt.Errorf("failed to stage changes: %w", err)
	}

	// Commit if there are changes
	if out, err := run("git", "commit", "-m", commitMessage); err != nil {
		if !strings.Contains(out, "nothing to commit") {
			return fmt.Errorf("failed to commit: %w", err)
		}
	}

	// Push to branch
	if out, err := run("git", "push", "-u", "origin", branch); err != nil {
		return fmt.Errorf("failed to push: %w (output: %s)", err, out)
	}

	log.Printf("Successfully pushed to origin/%s", branch)
	return nil
}

// CreateBranch creates a new branch and pushes it to remote
func CreateBranch(ctx context.Context, repoDir, branchName string) error {
	run := func(args ...string) (string, error) {
		cmd := exec.CommandContext(ctx, args[0], args[1:]...)
		cmd.Dir = repoDir
		var stdout bytes.Buffer
		cmd.Stdout = &stdout
		cmd.Stderr = &stdout
		err := cmd.Run()
		return stdout.String(), err
	}

	// Create and checkout new branch
	if _, err := run("git", "checkout", "-b", branchName); err != nil {
		return fmt.Errorf("failed to create branch: %w", err)
	}

	// Push to remote using HEAD:branchName refspec
	if out, err := run("git", "push", "-u", "origin", fmt.Sprintf("HEAD:%s", branchName)); err != nil {
		return fmt.Errorf("failed to push new branch: %w (output: %s)", err, out)
	}

	log.Printf("Successfully created and pushed branch %s", branchName)
	return nil
}

// ListRemoteBranches lists all branches in the remote repository
func ListRemoteBranches(ctx context.Context, repoDir string) ([]string, error) {
	cmd := exec.CommandContext(ctx, "git", "ls-remote", "--heads", "origin")
	cmd.Dir = repoDir

	var stdout bytes.Buffer
	cmd.Stdout = &stdout

	if err := cmd.Run(); err != nil {
		return nil, fmt.Errorf("failed to list remote branches: %w", err)
	}

	branches := []string{}
	for _, line := range strings.Split(stdout.String(), "\n") {
		if strings.TrimSpace(line) == "" {
			continue
		}
		// Format: "commit-hash refs/heads/branch-name"
		parts := strings.Fields(line)
		if len(parts) >= 2 {
			ref := parts[1]
			branchName := strings.TrimPrefix(ref, "refs/heads/")
			branches = append(branches, branchName)
		}
	}

	return branches, nil
}

// SyncRepo commits, pulls, and pushes changes
func SyncRepo(ctx context.Context, repoDir, commitMessage, branch string) error {
	if branch == "" {
		branch = "main"
	}

	// Stage all changes
	cmd := exec.CommandContext(ctx, "git", "add", ".")
	cmd.Dir = repoDir
	if out, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to stage changes: %w (output: %s)", err, string(out))
	}

	// Commit changes (only if there are changes)
	cmd = exec.CommandContext(ctx, "git", "commit", "-m", commitMessage)
	cmd.Dir = repoDir
	if out, err := cmd.CombinedOutput(); err != nil {
		// Check if error is "nothing to commit"
		outStr := string(out)
		if !strings.Contains(outStr, "nothing to commit") && !strings.Contains(outStr, "no changes added") {
			return fmt.Errorf("failed to commit: %w (output: %s)", err, outStr)
		}
		// Nothing to commit is not an error
		log.Printf("SyncRepo: nothing to commit in %s", repoDir)
	}

	// Pull with rebase to sync with remote
	cmd = exec.CommandContext(ctx, "git", "pull", "--rebase", "origin", branch)
	cmd.Dir = repoDir
	if out, err := cmd.CombinedOutput(); err != nil {
		outStr := string(out)
		// Check if it's just "no tracking information" (first push)
		if !strings.Contains(outStr, "no tracking information") && !strings.Contains(outStr, "couldn't find remote ref") {
			return fmt.Errorf("failed to pull: %w (output: %s)", err, outStr)
		}
		log.Printf("SyncRepo: pull skipped (no remote tracking): %s", outStr)
	}

	// Push to remote
	cmd = exec.CommandContext(ctx, "git", "push", "-u", "origin", branch)
	cmd.Dir = repoDir
	if out, err := cmd.CombinedOutput(); err != nil {
		outStr := string(out)
		if strings.Contains(outStr, "Permission denied") || strings.Contains(outStr, "403") {
			return fmt.Errorf("permission denied: no push access to remote")
		}
		return fmt.Errorf("failed to push: %w (output: %s)", err, outStr)
	}

	log.Printf("Successfully synchronized %s to %s", repoDir, branch)
	return nil
}

// Helper function to check if string slice contains a value
func contains(slice []string, str string) bool {
	for _, s := range slice {
		if s == str {
			return true
		}
	}
	return false
}
</file>

<file path="components/backend/handlers/sessions.go">
// Package handlers implements HTTP request handlers for the vTeam backend API.
package handlers

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"os"
	"strings"
	"time"

	"ambient-code-backend/git"
	"ambient-code-backend/types"

	"github.com/gin-gonic/gin"
	authnv1 "k8s.io/api/authentication/v1"
	corev1 "k8s.io/api/core/v1"
	rbacv1 "k8s.io/api/rbac/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/resource"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
	ktypes "k8s.io/apimachinery/pkg/types"
	intstr "k8s.io/apimachinery/pkg/util/intstr"
	"k8s.io/client-go/dynamic"
	"k8s.io/client-go/kubernetes"
)

// Package-level variables for session handlers (set from main package)
var (
	GetAgenticSessionV1Alpha1Resource func() schema.GroupVersionResource
	DynamicClient                     dynamic.Interface
	GetGitHubToken                    func(context.Context, *kubernetes.Clientset, dynamic.Interface, string, string) (string, error)
	DeriveRepoFolderFromURL           func(string) string
	SendMessageToSession              func(string, string, map[string]interface{})
)

// parseSpec parses AgenticSessionSpec with v1alpha1 fields
func parseSpec(spec map[string]interface{}) types.AgenticSessionSpec {
	result := types.AgenticSessionSpec{}

	if prompt, ok := spec["prompt"].(string); ok {
		result.Prompt = prompt
	}

	if interactive, ok := spec["interactive"].(bool); ok {
		result.Interactive = interactive
	}

	if displayName, ok := spec["displayName"].(string); ok {
		result.DisplayName = displayName
	}

	if project, ok := spec["project"].(string); ok {
		result.Project = project
	}

	if timeout, ok := spec["timeout"].(float64); ok {
		result.Timeout = int(timeout)
	}

	if llmSettings, ok := spec["llmSettings"].(map[string]interface{}); ok {
		if model, ok := llmSettings["model"].(string); ok {
			result.LLMSettings.Model = model
		}
		if temperature, ok := llmSettings["temperature"].(float64); ok {
			result.LLMSettings.Temperature = temperature
		}
		if maxTokens, ok := llmSettings["maxTokens"].(float64); ok {
			result.LLMSettings.MaxTokens = int(maxTokens)
		}
	}

	// environmentVariables passthrough
	if env, ok := spec["environmentVariables"].(map[string]interface{}); ok {
		resultEnv := make(map[string]string, len(env))
		for k, v := range env {
			if s, ok := v.(string); ok {
				resultEnv[k] = s
			}
		}
		if len(resultEnv) > 0 {
			result.EnvironmentVariables = resultEnv
		}
	}

	if userContext, ok := spec["userContext"].(map[string]interface{}); ok {
		uc := &types.UserContext{}
		if userID, ok := userContext["userId"].(string); ok {
			uc.UserID = userID
		}
		if displayName, ok := userContext["displayName"].(string); ok {
			uc.DisplayName = displayName
		}
		if groups, ok := userContext["groups"].([]interface{}); ok {
			for _, group := range groups {
				if groupStr, ok := group.(string); ok {
					uc.Groups = append(uc.Groups, groupStr)
				}
			}
		}
		result.UserContext = uc
	}

	if botAccount, ok := spec["botAccount"].(map[string]interface{}); ok {
		ba := &types.BotAccountRef{}
		if name, ok := botAccount["name"].(string); ok {
			ba.Name = name
		}
		result.BotAccount = ba
	}

	if resourceOverrides, ok := spec["resourceOverrides"].(map[string]interface{}); ok {
		ro := &types.ResourceOverrides{}
		if cpu, ok := resourceOverrides["cpu"].(string); ok {
			ro.CPU = cpu
		}
		if memory, ok := resourceOverrides["memory"].(string); ok {
			ro.Memory = memory
		}
		if storageClass, ok := resourceOverrides["storageClass"].(string); ok {
			ro.StorageClass = storageClass
		}
		if priorityClass, ok := resourceOverrides["priorityClass"].(string); ok {
			ro.PriorityClass = priorityClass
		}
		result.ResourceOverrides = ro
	}

	// Multi-repo parsing (unified repos)
	if arr, ok := spec["repos"].([]interface{}); ok {
		repos := make([]types.SessionRepoMapping, 0, len(arr))
		for _, it := range arr {
			m, ok := it.(map[string]interface{})
			if !ok {
				continue
			}
			r := types.SessionRepoMapping{}
			if in, ok := m["input"].(map[string]interface{}); ok {
				ng := types.NamedGitRepo{}
				if s, ok := in["url"].(string); ok {
					ng.URL = s
				}
				if s, ok := in["branch"].(string); ok && strings.TrimSpace(s) != "" {
					ng.Branch = types.StringPtr(s)
				}
				r.Input = ng
			}
			if out, ok := m["output"].(map[string]interface{}); ok {
				og := &types.OutputNamedGitRepo{}
				if s, ok := out["url"].(string); ok {
					og.URL = s
				}
				if s, ok := out["branch"].(string); ok && strings.TrimSpace(s) != "" {
					og.Branch = types.StringPtr(s)
				}
				r.Output = og
			}
			// Include per-repo status if present
			if st, ok := m["status"].(string); ok {
				r.Status = types.StringPtr(st)
			}
			if strings.TrimSpace(r.Input.URL) != "" {
				repos = append(repos, r)
			}
		}
		result.Repos = repos
	}
	if idx, ok := spec["mainRepoIndex"].(float64); ok {
		idxInt := int(idx)
		result.MainRepoIndex = &idxInt
	}

	// Parse activeWorkflow
	if workflow, ok := spec["activeWorkflow"].(map[string]interface{}); ok {
		ws := &types.WorkflowSelection{}
		if gitURL, ok := workflow["gitUrl"].(string); ok {
			ws.GitURL = gitURL
		}
		if branch, ok := workflow["branch"].(string); ok {
			ws.Branch = branch
		}
		if path, ok := workflow["path"].(string); ok {
			ws.Path = path
		}
		result.ActiveWorkflow = ws
	}

	return result
}

// parseStatus parses AgenticSessionStatus with v1alpha1 fields
func parseStatus(status map[string]interface{}) *types.AgenticSessionStatus {
	result := &types.AgenticSessionStatus{}

	if phase, ok := status["phase"].(string); ok {
		result.Phase = phase
	}

	if message, ok := status["message"].(string); ok {
		result.Message = message
	}

	if startTime, ok := status["startTime"].(string); ok {
		result.StartTime = &startTime
	}

	if completionTime, ok := status["completionTime"].(string); ok {
		result.CompletionTime = &completionTime
	}

	if jobName, ok := status["jobName"].(string); ok {
		result.JobName = jobName
	}

	// New: result summary fields (top-level in status)
	if st, ok := status["subtype"].(string); ok {
		result.Subtype = st
	}

	if ie, ok := status["is_error"].(bool); ok {
		result.IsError = ie
	}
	if nt, ok := status["num_turns"].(float64); ok {
		result.NumTurns = int(nt)
	}
	if sid, ok := status["session_id"].(string); ok {
		result.SessionID = sid
	}
	if tcu, ok := status["total_cost_usd"].(float64); ok {
		result.TotalCostUSD = &tcu
	}
	if usage, ok := status["usage"].(map[string]interface{}); ok {
		result.Usage = usage
	}
	if res, ok := status["result"].(string); ok {
		result.Result = &res
	}

	if stateDir, ok := status["stateDir"].(string); ok {
		result.StateDir = stateDir
	}

	return result
}

// V2 API Handlers - Multi-tenant session management

func ListSessions(c *gin.Context) {
	project := c.GetString("project")
	reqK8s, reqDyn := GetK8sClientsForRequest(c)
	_ = reqK8s
	gvr := GetAgenticSessionV1Alpha1Resource()

	list, err := reqDyn.Resource(gvr).Namespace(project).List(context.TODO(), v1.ListOptions{})
	if err != nil {
		log.Printf("Failed to list agentic sessions in project %s: %v", project, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to list agentic sessions"})
		return
	}

	var sessions []types.AgenticSession
	for _, item := range list.Items {
		session := types.AgenticSession{
			APIVersion: item.GetAPIVersion(),
			Kind:       item.GetKind(),
			Metadata:   item.Object["metadata"].(map[string]interface{}),
		}

		if spec, ok := item.Object["spec"].(map[string]interface{}); ok {
			session.Spec = parseSpec(spec)
		}

		if status, ok := item.Object["status"].(map[string]interface{}); ok {
			session.Status = parseStatus(status)
		}

		sessions = append(sessions, session)
	}

	c.JSON(http.StatusOK, gin.H{"items": sessions})
}

func CreateSession(c *gin.Context) {
	project := c.GetString("project")
	// Get user-scoped clients for creating the AgenticSession (enforces user RBAC)
	_, reqDyn := GetK8sClientsForRequest(c)
	if reqDyn == nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "User token required"})
		return
	}
	var req types.CreateAgenticSessionRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Validation for multi-repo can be added here if needed

	// Set defaults for LLM settings if not provided
	llmSettings := types.LLMSettings{
		Model:       "sonnet",
		Temperature: 0.7,
		MaxTokens:   4000,
	}
	if req.LLMSettings != nil {
		if req.LLMSettings.Model != "" {
			llmSettings.Model = req.LLMSettings.Model
		}
		if req.LLMSettings.Temperature != 0 {
			llmSettings.Temperature = req.LLMSettings.Temperature
		}
		if req.LLMSettings.MaxTokens != 0 {
			llmSettings.MaxTokens = req.LLMSettings.MaxTokens
		}
	}

	timeout := 300
	if req.Timeout != nil {
		timeout = *req.Timeout
	}

	// Generate unique name
	timestamp := time.Now().Unix()
	name := fmt.Sprintf("agentic-session-%d", timestamp)

	// Create the custom resource
	// Metadata
	metadata := map[string]interface{}{
		"name":      name,
		"namespace": project,
	}
	if len(req.Labels) > 0 {
		labels := map[string]interface{}{}
		for k, v := range req.Labels {
			labels[k] = v
		}
		metadata["labels"] = labels
	}
	if len(req.Annotations) > 0 {
		annotations := map[string]interface{}{}
		for k, v := range req.Annotations {
			annotations[k] = v
		}
		metadata["annotations"] = annotations
	}

	session := map[string]interface{}{
		"apiVersion": "vteam.ambient-code/v1alpha1",
		"kind":       "AgenticSession",
		"metadata":   metadata,
		"spec": map[string]interface{}{
			"prompt":      req.Prompt,
			"displayName": req.DisplayName,
			"project":     project,
			"llmSettings": map[string]interface{}{
				"model":       llmSettings.Model,
				"temperature": llmSettings.Temperature,
				"maxTokens":   llmSettings.MaxTokens,
			},
			"timeout": timeout,
		},
		"status": map[string]interface{}{
			"phase": "Pending",
		},
	}

	// Optional environment variables passthrough (always, independent of git config presence)
	envVars := make(map[string]string)
	for k, v := range req.EnvironmentVariables {
		envVars[k] = v
	}

	// Handle session continuation
	if req.ParentSessionID != "" {
		envVars["PARENT_SESSION_ID"] = req.ParentSessionID
		// Add annotation to track continuation lineage
		if metadata["annotations"] == nil {
			metadata["annotations"] = make(map[string]interface{})
		}
		annotations := metadata["annotations"].(map[string]interface{})
		annotations["vteam.ambient-code/parent-session-id"] = req.ParentSessionID
		log.Printf("Creating continuation session from parent %s", req.ParentSessionID)

		// Clean up temp-content pod from parent session to free the PVC
		// This prevents Multi-Attach errors when the new session tries to mount the same workspace
		reqK8s, _ := GetK8sClientsForRequest(c)
		if reqK8s != nil {
			tempPodName := fmt.Sprintf("temp-content-%s", req.ParentSessionID)
			if err := reqK8s.CoreV1().Pods(project).Delete(c.Request.Context(), tempPodName, v1.DeleteOptions{}); err != nil {
				if !errors.IsNotFound(err) {
					log.Printf("CreateSession: failed to delete temp-content pod %s (non-fatal): %v", tempPodName, err)
				}
			} else {
				log.Printf("CreateSession: deleted temp-content pod %s to free PVC for continuation", tempPodName)
			}
		}
	}

	if len(envVars) > 0 {
		spec := session["spec"].(map[string]interface{})
		spec["environmentVariables"] = envVars
	}

	// Interactive flag
	if req.Interactive != nil {
		session["spec"].(map[string]interface{})["interactive"] = *req.Interactive
	}

	// AutoPushOnComplete flag
	if req.AutoPushOnComplete != nil {
		session["spec"].(map[string]interface{})["autoPushOnComplete"] = *req.AutoPushOnComplete
	}

	// Set multi-repo configuration on spec
	{
		spec := session["spec"].(map[string]interface{})
		// Multi-repo pass-through (unified repos)
		if len(req.Repos) > 0 {
			arr := make([]map[string]interface{}, 0, len(req.Repos))
			for _, r := range req.Repos {
				m := map[string]interface{}{}
				in := map[string]interface{}{"url": r.Input.URL}
				if r.Input.Branch != nil {
					in["branch"] = *r.Input.Branch
				}
				m["input"] = in
				if r.Output != nil {
					out := map[string]interface{}{"url": r.Output.URL}
					if r.Output.Branch != nil {
						out["branch"] = *r.Output.Branch
					}
					m["output"] = out
				}
				// Remove default repo status; status will be set explicitly when pushed/abandoned
				// m["status"] intentionally unset at creation time
				arr = append(arr, m)
			}
			spec["repos"] = arr
		}
		if req.MainRepoIndex != nil {
			spec["mainRepoIndex"] = *req.MainRepoIndex
		}
	}

	// Add userContext derived from authenticated caller; ignore client-supplied userId
	{
		uidVal, _ := c.Get("userID")
		uid, _ := uidVal.(string)
		uid = strings.TrimSpace(uid)
		if uid != "" {
			displayName := ""
			if v, ok := c.Get("userName"); ok {
				if s, ok2 := v.(string); ok2 {
					displayName = s
				}
			}
			groups := []string{}
			if v, ok := c.Get("userGroups"); ok {
				if gg, ok2 := v.([]string); ok2 {
					groups = gg
				}
			}
			// Fallbacks for non-identity fields only
			if displayName == "" && req.UserContext != nil {
				displayName = req.UserContext.DisplayName
			}
			if len(groups) == 0 && req.UserContext != nil {
				groups = req.UserContext.Groups
			}
			session["spec"].(map[string]interface{})["userContext"] = map[string]interface{}{
				"userId":      uid,
				"displayName": displayName,
				"groups":      groups,
			}
		}
	}

	// Add botAccount if provided
	if req.BotAccount != nil {
		session["spec"].(map[string]interface{})["botAccount"] = map[string]interface{}{
			"name": req.BotAccount.Name,
		}
	}

	// Add resourceOverrides if provided
	if req.ResourceOverrides != nil {
		resourceOverrides := make(map[string]interface{})
		if req.ResourceOverrides.CPU != "" {
			resourceOverrides["cpu"] = req.ResourceOverrides.CPU
		}
		if req.ResourceOverrides.Memory != "" {
			resourceOverrides["memory"] = req.ResourceOverrides.Memory
		}
		if req.ResourceOverrides.StorageClass != "" {
			resourceOverrides["storageClass"] = req.ResourceOverrides.StorageClass
		}
		if req.ResourceOverrides.PriorityClass != "" {
			resourceOverrides["priorityClass"] = req.ResourceOverrides.PriorityClass
		}
		if len(resourceOverrides) > 0 {
			session["spec"].(map[string]interface{})["resourceOverrides"] = resourceOverrides
		}
	}

	gvr := GetAgenticSessionV1Alpha1Resource()
	obj := &unstructured.Unstructured{Object: session}

	// Create AgenticSession using user token (enforces user RBAC permissions)
	created, err := reqDyn.Resource(gvr).Namespace(project).Create(context.TODO(), obj, v1.CreateOptions{})
	if err != nil {
		log.Printf("Failed to create agentic session in project %s: %v", project, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create agentic session"})
		return
	}

	// Best-effort prefill of agent markdown into PVC workspace for immediate UI availability
	// Uses AGENT_PERSONAS or AGENT_PERSONA if provided in request environment variables
	func() {
		defer func() { _ = recover() }()
		personasCsv := ""
		if v, ok := req.EnvironmentVariables["AGENT_PERSONAS"]; ok && strings.TrimSpace(v) != "" {
			personasCsv = v
		} else if v, ok := req.EnvironmentVariables["AGENT_PERSONA"]; ok && strings.TrimSpace(v) != "" {
			personasCsv = v
		}
		if strings.TrimSpace(personasCsv) == "" {
			return
		}
		// content service removed; skip workspace path handling
		// Write each agent markdown
		for _, p := range strings.Split(personasCsv, ",") {
			persona := strings.TrimSpace(p)
			if persona == "" {
				continue
			}
			// ambient-content removed: skip agent prefill writes
		}
	}()

	// Provision runner token using backend SA (requires elevated permissions for SA/Role/Secret creation)
	if DynamicClient == nil || K8sClient == nil {
		log.Printf("Warning: backend SA clients not available, skipping runner token provisioning for session %s/%s", project, name)
	} else if err := provisionRunnerTokenForSession(c, K8sClient, DynamicClient, project, name); err != nil {
		// Non-fatal: log and continue. Operator may retry later if implemented.
		log.Printf("Warning: failed to provision runner token for session %s/%s: %v", project, name, err)
	}

	c.JSON(http.StatusCreated, gin.H{
		"message": "Agentic session created successfully",
		"name":    name,
		"uid":     created.GetUID(),
	})
}

// provisionRunnerTokenForSession creates a per-session ServiceAccount, grants minimal RBAC,
// mints a short-lived token, stores it in a Secret, and annotates the AgenticSession with the Secret name.
func provisionRunnerTokenForSession(c *gin.Context, reqK8s *kubernetes.Clientset, reqDyn dynamic.Interface, project string, sessionName string) error {
	// Load owning AgenticSession to parent all resources
	gvr := GetAgenticSessionV1Alpha1Resource()
	obj, err := reqDyn.Resource(gvr).Namespace(project).Get(c.Request.Context(), sessionName, v1.GetOptions{})
	if err != nil {
		return fmt.Errorf("get AgenticSession: %w", err)
	}
	ownerRef := v1.OwnerReference{
		APIVersion: obj.GetAPIVersion(),
		Kind:       obj.GetKind(),
		Name:       obj.GetName(),
		UID:        obj.GetUID(),
		Controller: types.BoolPtr(true),
	}

	// Create ServiceAccount
	saName := fmt.Sprintf("ambient-session-%s", sessionName)
	sa := &corev1.ServiceAccount{
		ObjectMeta: v1.ObjectMeta{
			Name:            saName,
			Namespace:       project,
			Labels:          map[string]string{"app": "ambient-runner"},
			OwnerReferences: []v1.OwnerReference{ownerRef},
		},
	}
	if _, err := reqK8s.CoreV1().ServiceAccounts(project).Create(c.Request.Context(), sa, v1.CreateOptions{}); err != nil {
		if !errors.IsAlreadyExists(err) {
			return fmt.Errorf("create SA: %w", err)
		}
	}

	// Create Role with least-privilege for updating AgenticSession status and annotations
	roleName := fmt.Sprintf("ambient-session-%s-role", sessionName)
	role := &rbacv1.Role{
		ObjectMeta: v1.ObjectMeta{
			Name:            roleName,
			Namespace:       project,
			OwnerReferences: []v1.OwnerReference{ownerRef},
		},
		Rules: []rbacv1.PolicyRule{
			{
				APIGroups: []string{"vteam.ambient-code"},
				Resources: []string{"agenticsessions/status"},
				Verbs:     []string{"get", "update", "patch"},
			},
			{
				APIGroups: []string{"vteam.ambient-code"},
				Resources: []string{"agenticsessions"},
				Verbs:     []string{"get", "list", "watch", "update", "patch"}, // Added update, patch for annotations
			},
			{
				APIGroups: []string{"authorization.k8s.io"},
				Resources: []string{"selfsubjectaccessreviews"},
				Verbs:     []string{"create"},
			},
		},
	}
	// Try to create or update the Role to ensure it has latest permissions
	if _, err := reqK8s.RbacV1().Roles(project).Create(c.Request.Context(), role, v1.CreateOptions{}); err != nil {
		if errors.IsAlreadyExists(err) {
			// Role exists - update it to ensure it has the latest permissions (including update/patch)
			log.Printf("Role %s already exists, updating with latest permissions", roleName)
			if _, err := reqK8s.RbacV1().Roles(project).Update(c.Request.Context(), role, v1.UpdateOptions{}); err != nil {
				return fmt.Errorf("update Role: %w", err)
			}
			log.Printf("Successfully updated Role %s with annotation update permissions", roleName)
		} else {
			return fmt.Errorf("create Role: %w", err)
		}
	}

	// Bind Role to the ServiceAccount
	rbName := fmt.Sprintf("ambient-session-%s-rb", sessionName)
	rb := &rbacv1.RoleBinding{
		ObjectMeta: v1.ObjectMeta{
			Name:            rbName,
			Namespace:       project,
			OwnerReferences: []v1.OwnerReference{ownerRef},
		},
		RoleRef:  rbacv1.RoleRef{APIGroup: "rbac.authorization.k8s.io", Kind: "Role", Name: roleName},
		Subjects: []rbacv1.Subject{{Kind: "ServiceAccount", Name: saName, Namespace: project}},
	}
	if _, err := reqK8s.RbacV1().RoleBindings(project).Create(context.TODO(), rb, v1.CreateOptions{}); err != nil {
		if !errors.IsAlreadyExists(err) {
			return fmt.Errorf("create RoleBinding: %w", err)
		}
	}

	// Mint short-lived K8s ServiceAccount token for CR status updates
	tr := &authnv1.TokenRequest{Spec: authnv1.TokenRequestSpec{}}
	tok, err := reqK8s.CoreV1().ServiceAccounts(project).CreateToken(c.Request.Context(), saName, tr, v1.CreateOptions{})
	if err != nil {
		return fmt.Errorf("mint token: %w", err)
	}
	k8sToken := tok.Status.Token
	if strings.TrimSpace(k8sToken) == "" {
		return fmt.Errorf("received empty token for SA %s", saName)
	}

	// Only store the K8s token; GitHub tokens are minted on-demand by the runner
	secretData := map[string]string{
		"k8s-token": k8sToken,
	}

	// Store token in a Secret (update if exists to refresh token)
	secretName := fmt.Sprintf("ambient-runner-token-%s", sessionName)
	sec := &corev1.Secret{
		ObjectMeta: v1.ObjectMeta{
			Name:            secretName,
			Namespace:       project,
			Labels:          map[string]string{"app": "ambient-runner-token"},
			OwnerReferences: []v1.OwnerReference{ownerRef},
		},
		Type:       corev1.SecretTypeOpaque,
		StringData: secretData,
	}

	// Try to create the secret
	if _, err := reqK8s.CoreV1().Secrets(project).Create(c.Request.Context(), sec, v1.CreateOptions{}); err != nil {
		if errors.IsAlreadyExists(err) {
			// Secret exists - update it with fresh token
			log.Printf("Updating existing secret %s with fresh token", secretName)
			if _, err := reqK8s.CoreV1().Secrets(project).Update(c.Request.Context(), sec, v1.UpdateOptions{}); err != nil {
				return fmt.Errorf("update Secret: %w", err)
			}
			log.Printf("Successfully updated secret %s with fresh token", secretName)
		} else {
			return fmt.Errorf("create Secret: %w", err)
		}
	}

	// Annotate the AgenticSession with the Secret and SA names (conflict-safe patch)
	patch := map[string]interface{}{
		"metadata": map[string]interface{}{
			"annotations": map[string]string{
				"ambient-code.io/runner-token-secret": secretName,
				"ambient-code.io/runner-sa":           saName,
			},
		},
	}
	b, _ := json.Marshal(patch)
	if _, err := reqDyn.Resource(gvr).Namespace(project).Patch(c.Request.Context(), obj.GetName(), ktypes.MergePatchType, b, v1.PatchOptions{}); err != nil {
		return fmt.Errorf("annotate AgenticSession: %w", err)
	}

	return nil
}

func GetSession(c *gin.Context) {
	project := c.GetString("project")
	sessionName := c.Param("sessionName")
	reqK8s, reqDyn := GetK8sClientsForRequest(c)
	_ = reqK8s
	gvr := GetAgenticSessionV1Alpha1Resource()

	item, err := reqDyn.Resource(gvr).Namespace(project).Get(context.TODO(), sessionName, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			c.JSON(http.StatusNotFound, gin.H{"error": "Session not found"})
			return
		}
		log.Printf("Failed to get agentic session %s in project %s: %v", sessionName, project, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get agentic session"})
		return
	}

	session := types.AgenticSession{
		APIVersion: item.GetAPIVersion(),
		Kind:       item.GetKind(),
		Metadata:   item.Object["metadata"].(map[string]interface{}),
	}

	if spec, ok := item.Object["spec"].(map[string]interface{}); ok {
		session.Spec = parseSpec(spec)
	}

	if status, ok := item.Object["status"].(map[string]interface{}); ok {
		session.Status = parseStatus(status)
	}

	c.JSON(http.StatusOK, session)
}

// MintSessionGitHubToken validates the token via TokenReview, ensures SA matches CR annotation, and returns a short-lived GitHub token.
// POST /api/projects/:projectName/agentic-sessions/:sessionName/github/token
// Auth: Authorization: Bearer <BOT_TOKEN> (K8s SA token with audience "ambient-backend")
func MintSessionGitHubToken(c *gin.Context) {
	project := c.Param("projectName")
	sessionName := c.Param("sessionName")

	rawAuth := strings.TrimSpace(c.GetHeader("Authorization"))
	if rawAuth == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "missing Authorization header"})
		return
	}
	parts := strings.SplitN(rawAuth, " ", 2)
	if len(parts) != 2 || !strings.EqualFold(parts[0], "Bearer") {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid Authorization header"})
		return
	}
	token := strings.TrimSpace(parts[1])
	if token == "" {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "empty token"})
		return
	}

	// TokenReview using default audience (works with standard SA tokens)
	tr := &authnv1.TokenReview{Spec: authnv1.TokenReviewSpec{Token: token}}
	rv, err := K8sClient.AuthenticationV1().TokenReviews().Create(c.Request.Context(), tr, v1.CreateOptions{})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "token review failed"})
		return
	}
	if rv.Status.Error != "" || !rv.Status.Authenticated {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthenticated"})
		return
	}
	subj := strings.TrimSpace(rv.Status.User.Username)
	const pfx = "system:serviceaccount:"
	if !strings.HasPrefix(subj, pfx) {
		c.JSON(http.StatusForbidden, gin.H{"error": "subject is not a service account"})
		return
	}
	rest := strings.TrimPrefix(subj, pfx)
	segs := strings.SplitN(rest, ":", 2)
	if len(segs) != 2 {
		c.JSON(http.StatusForbidden, gin.H{"error": "invalid service account subject"})
		return
	}
	nsFromToken, saFromToken := segs[0], segs[1]
	if nsFromToken != project {
		c.JSON(http.StatusForbidden, gin.H{"error": "namespace mismatch"})
		return
	}

	// Load session and verify SA matches annotation
	gvr := GetAgenticSessionV1Alpha1Resource()
	obj, err := DynamicClient.Resource(gvr).Namespace(project).Get(c.Request.Context(), sessionName, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			c.JSON(http.StatusNotFound, gin.H{"error": "session not found"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to read session"})
		return
	}
	meta, _ := obj.Object["metadata"].(map[string]interface{})
	anns, _ := meta["annotations"].(map[string]interface{})
	expectedSA := ""
	if anns != nil {
		if v, ok := anns["ambient-code.io/runner-sa"].(string); ok {
			expectedSA = strings.TrimSpace(v)
		}
	}
	if expectedSA == "" || expectedSA != saFromToken {
		c.JSON(http.StatusForbidden, gin.H{"error": "service account not authorized for session"})
		return
	}

	// Read authoritative userId from spec.userContext.userId
	spec, _ := obj.Object["spec"].(map[string]interface{})
	userID := ""
	if spec != nil {
		if uc, ok := spec["userContext"].(map[string]interface{}); ok {
			if v, ok := uc["userId"].(string); ok {
				userID = strings.TrimSpace(v)
			}
		}
	}
	if userID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "session missing user context"})
		return
	}

	// Get GitHub token (GitHub App or PAT fallback via project runner secret)
	tokenStr, err := GetGitHubToken(c.Request.Context(), K8sClient, DynamicClient, project, userID)
	if err != nil {
		c.JSON(http.StatusBadGateway, gin.H{"error": err.Error()})
		return
	}
	// Note: PATs don't have expiration, so we omit expiresAt for simplicity
	// Runners should treat all tokens as short-lived and request new ones as needed
	c.JSON(http.StatusOK, gin.H{"token": tokenStr})
}

func PatchSession(c *gin.Context) {
	project := c.GetString("project")
	sessionName := c.Param("sessionName")
	_, reqDyn := GetK8sClientsForRequest(c)

	var patch map[string]interface{}
	if err := c.ShouldBindJSON(&patch); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	gvr := GetAgenticSessionV1Alpha1Resource()

	// Get current resource
	item, err := reqDyn.Resource(gvr).Namespace(project).Get(context.TODO(), sessionName, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			c.JSON(http.StatusNotFound, gin.H{"error": "Session not found"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get session"})
		return
	}

	// Apply patch to metadata annotations
	if metaPatch, ok := patch["metadata"].(map[string]interface{}); ok {
		if annsPatch, ok := metaPatch["annotations"].(map[string]interface{}); ok {
			metadata := item.Object["metadata"].(map[string]interface{})
			if metadata["annotations"] == nil {
				metadata["annotations"] = make(map[string]interface{})
			}
			anns := metadata["annotations"].(map[string]interface{})
			for k, v := range annsPatch {
				anns[k] = v
			}
		}
	}

	// Update the resource
	updated, err := reqDyn.Resource(gvr).Namespace(project).Update(context.TODO(), item, v1.UpdateOptions{})
	if err != nil {
		log.Printf("Failed to patch agentic session %s: %v", sessionName, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to patch session"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Session patched successfully", "annotations": updated.GetAnnotations()})
}

func UpdateSession(c *gin.Context) {
	project := c.GetString("project")
	sessionName := c.Param("sessionName")
	reqK8s, reqDyn := GetK8sClientsForRequest(c)
	_ = reqK8s

	var req types.CreateAgenticSessionRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	gvr := GetAgenticSessionV1Alpha1Resource()

	// Get current resource with brief retry to avoid race on creation
	var item *unstructured.Unstructured
	var err error
	for attempt := 0; attempt < 5; attempt++ {
		item, err = reqDyn.Resource(gvr).Namespace(project).Get(context.TODO(), sessionName, v1.GetOptions{})
		if err == nil {
			break
		}
		if errors.IsNotFound(err) {
			time.Sleep(300 * time.Millisecond)
			continue
		}
		log.Printf("Failed to get agentic session %s in project %s: %v", sessionName, project, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get agentic session"})
		return
	}
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Session not found"})
		return
	}

	// Update spec
	spec := item.Object["spec"].(map[string]interface{})
	spec["prompt"] = req.Prompt
	spec["displayName"] = req.DisplayName

	if req.LLMSettings != nil {
		llmSettings := make(map[string]interface{})
		if req.LLMSettings.Model != "" {
			llmSettings["model"] = req.LLMSettings.Model
		}
		if req.LLMSettings.Temperature != 0 {
			llmSettings["temperature"] = req.LLMSettings.Temperature
		}
		if req.LLMSettings.MaxTokens != 0 {
			llmSettings["maxTokens"] = req.LLMSettings.MaxTokens
		}
		spec["llmSettings"] = llmSettings
	}

	if req.Timeout != nil {
		spec["timeout"] = *req.Timeout
	}

	// Update the resource
	updated, err := reqDyn.Resource(gvr).Namespace(project).Update(context.TODO(), item, v1.UpdateOptions{})
	if err != nil {
		log.Printf("Failed to update agentic session %s in project %s: %v", sessionName, project, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update agentic session"})
		return
	}

	// Parse and return updated session
	session := types.AgenticSession{
		APIVersion: updated.GetAPIVersion(),
		Kind:       updated.GetKind(),
		Metadata:   updated.Object["metadata"].(map[string]interface{}),
	}

	if spec, ok := updated.Object["spec"].(map[string]interface{}); ok {
		session.Spec = parseSpec(spec)
	}

	if status, ok := updated.Object["status"].(map[string]interface{}); ok {
		session.Status = parseStatus(status)
	}

	c.JSON(http.StatusOK, session)
}

// UpdateSessionDisplayName updates only the spec.displayName field on the AgenticSession.
// PUT /api/projects/:projectName/agentic-sessions/:sessionName/displayname
func UpdateSessionDisplayName(c *gin.Context) {
	project := c.GetString("project")
	sessionName := c.Param("sessionName")
	_, reqDyn := GetK8sClientsForRequest(c)

	var req struct {
		DisplayName string `json:"displayName" binding:"required"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	gvr := GetAgenticSessionV1Alpha1Resource()

	// Retrieve current resource
	item, err := reqDyn.Resource(gvr).Namespace(project).Get(context.TODO(), sessionName, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			c.JSON(http.StatusNotFound, gin.H{"error": "Session not found"})
			return
		}
		log.Printf("Failed to get agentic session %s in project %s: %v", sessionName, project, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get agentic session"})
		return
	}

	// Update only displayName in spec
	spec, ok := item.Object["spec"].(map[string]interface{})
	if !ok {
		spec = make(map[string]interface{})
		item.Object["spec"] = spec
	}
	spec["displayName"] = req.DisplayName

	// Persist the change
	updated, err := reqDyn.Resource(gvr).Namespace(project).Update(context.TODO(), item, v1.UpdateOptions{})
	if err != nil {
		log.Printf("Failed to update display name for agentic session %s in project %s: %v", sessionName, project, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update display name"})
		return
	}

	// Respond with updated session summary
	session := types.AgenticSession{
		APIVersion: updated.GetAPIVersion(),
		Kind:       updated.GetKind(),
		Metadata:   updated.Object["metadata"].(map[string]interface{}),
	}
	if s, ok := updated.Object["spec"].(map[string]interface{}); ok {
		session.Spec = parseSpec(s)
	}
	if st, ok := updated.Object["status"].(map[string]interface{}); ok {
		session.Status = parseStatus(st)
	}

	c.JSON(http.StatusOK, session)
}

// SelectWorkflow sets the active workflow for a session
// POST /api/projects/:projectName/agentic-sessions/:sessionName/workflow
func SelectWorkflow(c *gin.Context) {
	project := c.GetString("project")
	sessionName := c.Param("sessionName")
	_, reqDyn := GetK8sClientsForRequest(c)

	var req types.WorkflowSelection
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	gvr := GetAgenticSessionV1Alpha1Resource()

	// Retrieve current resource
	item, err := reqDyn.Resource(gvr).Namespace(project).Get(context.TODO(), sessionName, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			c.JSON(http.StatusNotFound, gin.H{"error": "Session not found"})
			return
		}
		log.Printf("Failed to get agentic session %s in project %s: %v", sessionName, project, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get agentic session"})
		return
	}

	// Update activeWorkflow in spec
	spec, ok := item.Object["spec"].(map[string]interface{})
	if !ok {
		spec = make(map[string]interface{})
		item.Object["spec"] = spec
	}

	// Set activeWorkflow
	workflowMap := map[string]interface{}{
		"gitUrl": req.GitURL,
	}
	if req.Branch != "" {
		workflowMap["branch"] = req.Branch
	} else {
		workflowMap["branch"] = "main"
	}
	if req.Path != "" {
		workflowMap["path"] = req.Path
	}
	spec["activeWorkflow"] = workflowMap

	// Persist the change
	updated, err := reqDyn.Resource(gvr).Namespace(project).Update(context.TODO(), item, v1.UpdateOptions{})
	if err != nil {
		log.Printf("Failed to update workflow for agentic session %s in project %s: %v", sessionName, project, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update workflow"})
		return
	}

	log.Printf("Workflow updated for session %s: %s@%s", sessionName, req.GitURL, workflowMap["branch"])

	// Note: The workflow will be available on next user interaction. The frontend should
	// send a workflow_change message via the WebSocket to notify the runner immediately.

	// Respond with updated session summary
	session := types.AgenticSession{
		APIVersion: updated.GetAPIVersion(),
		Kind:       updated.GetKind(),
		Metadata:   updated.Object["metadata"].(map[string]interface{}),
	}
	if s, ok := updated.Object["spec"].(map[string]interface{}); ok {
		session.Spec = parseSpec(s)
	}
	if st, ok := updated.Object["status"].(map[string]interface{}); ok {
		session.Status = parseStatus(st)
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "Workflow updated successfully",
		"session": session,
	})
}

// AddRepo adds a new repository to a running session
// POST /api/projects/:projectName/agentic-sessions/:sessionName/repos
func AddRepo(c *gin.Context) {
	project := c.GetString("project")
	sessionName := c.Param("sessionName")
	_, reqDyn := GetK8sClientsForRequest(c)

	var req struct {
		URL    string `json:"url" binding:"required"`
		Branch string `json:"branch"`
		Output *struct {
			URL    string `json:"url"`
			Branch string `json:"branch"`
		} `json:"output,omitempty"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	if req.Branch == "" {
		req.Branch = "main"
	}

	gvr := GetAgenticSessionV1Alpha1Resource()
	item, err := reqDyn.Resource(gvr).Namespace(project).Get(context.TODO(), sessionName, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			c.JSON(http.StatusNotFound, gin.H{"error": "Session not found"})
			return
		}
		log.Printf("Failed to get session %s in project %s: %v", sessionName, project, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get session"})
		return
	}

	// Update spec.repos
	spec, ok := item.Object["spec"].(map[string]interface{})
	if !ok {
		spec = make(map[string]interface{})
		item.Object["spec"] = spec
	}
	repos, _ := spec["repos"].([]interface{})
	if repos == nil {
		repos = []interface{}{}
	}

	newRepo := map[string]interface{}{
		"input": map[string]interface{}{
			"url":    req.URL,
			"branch": req.Branch,
		},
	}
	if req.Output != nil {
		newRepo["output"] = map[string]interface{}{
			"url":    req.Output.URL,
			"branch": req.Output.Branch,
		}
	}
	repos = append(repos, newRepo)
	spec["repos"] = repos

	// Persist change
	_, err = reqDyn.Resource(gvr).Namespace(project).Update(context.TODO(), item, v1.UpdateOptions{})
	if err != nil {
		log.Printf("Failed to update session %s in project %s: %v", sessionName, project, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update session"})
		return
	}

	// Notify runner via WebSocket
	repoName := DeriveRepoFolderFromURL(req.URL)
	if SendMessageToSession != nil {
		SendMessageToSession(sessionName, "repo_added", map[string]interface{}{
			"name":   repoName,
			"url":    req.URL,
			"branch": req.Branch,
		})
	}

	log.Printf("Added repository %s to session %s in project %s", repoName, sessionName, project)
	c.JSON(http.StatusOK, gin.H{"message": "Repository added", "name": repoName})
}

// RemoveRepo removes a repository from a running session
// DELETE /api/projects/:projectName/agentic-sessions/:sessionName/repos/:repoName
func RemoveRepo(c *gin.Context) {
	project := c.GetString("project")
	sessionName := c.Param("sessionName")
	repoName := c.Param("repoName")
	_, reqDyn := GetK8sClientsForRequest(c)

	gvr := GetAgenticSessionV1Alpha1Resource()
	item, err := reqDyn.Resource(gvr).Namespace(project).Get(context.TODO(), sessionName, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			c.JSON(http.StatusNotFound, gin.H{"error": "Session not found"})
			return
		}
		log.Printf("Failed to get session %s in project %s: %v", sessionName, project, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get session"})
		return
	}

	// Update spec.repos
	spec, ok := item.Object["spec"].(map[string]interface{})
	if !ok {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Session has no spec"})
		return
	}
	repos, _ := spec["repos"].([]interface{})

	filteredRepos := []interface{}{}
	found := false
	for _, r := range repos {
		rm, _ := r.(map[string]interface{})
		input, _ := rm["input"].(map[string]interface{})
		url, _ := input["url"].(string)
		if DeriveRepoFolderFromURL(url) != repoName {
			filteredRepos = append(filteredRepos, r)
		} else {
			found = true
		}
	}

	if !found {
		c.JSON(http.StatusNotFound, gin.H{"error": "Repository not found in session"})
		return
	}

	spec["repos"] = filteredRepos

	// Persist change
	_, err = reqDyn.Resource(gvr).Namespace(project).Update(context.TODO(), item, v1.UpdateOptions{})
	if err != nil {
		log.Printf("Failed to update session %s in project %s: %v", sessionName, project, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update session"})
		return
	}

	// Notify runner via WebSocket
	if SendMessageToSession != nil {
		SendMessageToSession(sessionName, "repo_removed", map[string]interface{}{
			"name": repoName,
		})
	}

	log.Printf("Removed repository %s from session %s in project %s", repoName, sessionName, project)
	c.JSON(http.StatusOK, gin.H{"message": "Repository removed"})
}

// GetWorkflowMetadata retrieves commands and agents metadata from the active workflow
// GET /api/projects/:projectName/agentic-sessions/:sessionName/workflow/metadata
func GetWorkflowMetadata(c *gin.Context) {
	project := c.GetString("project")
	if project == "" {
		project = c.Param("projectName")
	}
	sessionName := c.Param("sessionName")

	if project == "" {
		log.Printf("GetWorkflowMetadata: project is empty, session=%s", sessionName)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Project namespace required"})
		return
	}

	// Get authorization token
	token := c.GetHeader("Authorization")
	if strings.TrimSpace(token) == "" {
		token = c.GetHeader("X-Forwarded-Access-Token")
	}

	// Try temp service first (for completed sessions), then regular service
	serviceName := fmt.Sprintf("temp-content-%s", sessionName)
	reqK8s, _ := GetK8sClientsForRequest(c)
	if reqK8s != nil {
		if _, err := reqK8s.CoreV1().Services(project).Get(c.Request.Context(), serviceName, v1.GetOptions{}); err != nil {
			// Temp service doesn't exist, use regular service
			serviceName = fmt.Sprintf("ambient-content-%s", sessionName)
		}
	} else {
		serviceName = fmt.Sprintf("ambient-content-%s", sessionName)
	}

	// Build URL to content service
	endpoint := fmt.Sprintf("http://%s.%s.svc:8080", serviceName, project)
	u := fmt.Sprintf("%s/content/workflow-metadata?session=%s", endpoint, sessionName)

	log.Printf("GetWorkflowMetadata: project=%s session=%s endpoint=%s", project, sessionName, endpoint)

	// Create and send request to content pod
	req, _ := http.NewRequestWithContext(c.Request.Context(), http.MethodGet, u, nil)
	if strings.TrimSpace(token) != "" {
		req.Header.Set("Authorization", token)
	}
	client := &http.Client{Timeout: 4 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		log.Printf("GetWorkflowMetadata: content service request failed: %v", err)
		// Return empty metadata on error
		c.JSON(http.StatusOK, gin.H{"commands": []interface{}{}, "agents": []interface{}{}})
		return
	}
	defer resp.Body.Close()

	b, _ := io.ReadAll(resp.Body)
	c.Data(resp.StatusCode, "application/json", b)
}

// fetchGitHubFileContent fetches a file from GitHub via API
// token is optional - works for public repos without authentication (but has rate limits)
func fetchGitHubFileContent(ctx context.Context, owner, repo, ref, path, token string) ([]byte, error) {
	api := "https://api.github.com"
	url := fmt.Sprintf("%s/repos/%s/%s/contents/%s?ref=%s", api, owner, repo, path, ref)

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
	if err != nil {
		return nil, err
	}

	// Only set Authorization header if token is provided
	if token != "" {
		req.Header.Set("Authorization", "Bearer "+token)
	}
	req.Header.Set("Accept", "application/vnd.github.raw")
	req.Header.Set("X-GitHub-Api-Version", "2022-11-28")

	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusNotFound {
		return nil, fmt.Errorf("file not found")
	}

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("GitHub API error %d: %s", resp.StatusCode, string(body))
	}

	return io.ReadAll(resp.Body)
}

// fetchGitHubDirectoryListing lists files/folders in a GitHub directory
// token is optional - works for public repos without authentication (but has rate limits)
func fetchGitHubDirectoryListing(ctx context.Context, owner, repo, ref, path, token string) ([]map[string]interface{}, error) {
	api := "https://api.github.com"
	url := fmt.Sprintf("%s/repos/%s/%s/contents/%s?ref=%s", api, owner, repo, path, ref)

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
	if err != nil {
		return nil, err
	}

	// Only set Authorization header if token is provided
	if token != "" {
		req.Header.Set("Authorization", "Bearer "+token)
	}
	req.Header.Set("Accept", "application/vnd.github+json")
	req.Header.Set("X-GitHub-Api-Version", "2022-11-28")

	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("GitHub API error %d: %s", resp.StatusCode, string(body))
	}

	var entries []map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&entries); err != nil {
		return nil, err
	}

	return entries, nil
}

// OOTBWorkflow represents an out-of-the-box workflow
type OOTBWorkflow struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	Description string `json:"description"`
	GitURL      string `json:"gitUrl"`
	Branch      string `json:"branch"`
	Path        string `json:"path,omitempty"`
	Enabled     bool   `json:"enabled"`
}

// ListOOTBWorkflows returns the list of out-of-the-box workflows dynamically discovered from GitHub
// Attempts to use user's GitHub token for better rate limits, falls back to unauthenticated for public repos
// GET /api/workflows/ootb?project=<projectName>
func ListOOTBWorkflows(c *gin.Context) {
	// Try to get user's GitHub token (best effort - not required)
	// This gives better rate limits (5000/hr vs 60/hr) and supports private repos
	// Project is optional - if provided, we'll try to get the user's token
	token := ""
	project := c.Query("project") // Optional query parameter
	if project != "" {
		userID, _ := c.Get("userID")
		if reqK8s, reqDyn := GetK8sClientsForRequest(c); reqK8s != nil {
			if userIDStr, ok := userID.(string); ok && userIDStr != "" {
				if githubToken, err := GetGitHubToken(c.Request.Context(), reqK8s, reqDyn, project, userIDStr); err == nil {
					token = githubToken
					log.Printf("ListOOTBWorkflows: using user's GitHub token for project %s (better rate limits)", project)
				} else {
					log.Printf("ListOOTBWorkflows: failed to get GitHub token for project %s: %v", project, err)
				}
			}
		}
	}
	if token == "" {
		log.Printf("ListOOTBWorkflows: proceeding without GitHub token (public repo, lower rate limits)")
	}

	// Read OOTB repo configuration from environment
	ootbRepo := strings.TrimSpace(os.Getenv("OOTB_WORKFLOWS_REPO"))
	if ootbRepo == "" {
		ootbRepo = "https://github.com/ambient-code/ootb-ambient-workflows.git"
	}

	ootbBranch := strings.TrimSpace(os.Getenv("OOTB_WORKFLOWS_BRANCH"))
	if ootbBranch == "" {
		ootbBranch = "main"
	}

	ootbWorkflowsPath := strings.TrimSpace(os.Getenv("OOTB_WORKFLOWS_PATH"))
	if ootbWorkflowsPath == "" {
		ootbWorkflowsPath = "workflows"
	}

	// Parse GitHub URL
	owner, repoName, err := git.ParseGitHubURL(ootbRepo)
	if err != nil {
		log.Printf("ListOOTBWorkflows: invalid repo URL: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid OOTB repo URL"})
		return
	}

	// List workflow directories
	entries, err := fetchGitHubDirectoryListing(c.Request.Context(), owner, repoName, ootbBranch, ootbWorkflowsPath, token)
	if err != nil {
		log.Printf("ListOOTBWorkflows: failed to list workflows directory: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to discover OOTB workflows"})
		return
	}

	// Scan each subdirectory for ambient.json
	workflows := []OOTBWorkflow{}
	for _, entry := range entries {
		entryType, _ := entry["type"].(string)
		entryName, _ := entry["name"].(string)

		if entryType != "dir" {
			continue
		}

		// Try to fetch ambient.json from this workflow directory
		ambientPath := fmt.Sprintf("%s/%s/.ambient/ambient.json", ootbWorkflowsPath, entryName)
		ambientData, err := fetchGitHubFileContent(c.Request.Context(), owner, repoName, ootbBranch, ambientPath, token)

		var ambientConfig struct {
			Name        string `json:"name"`
			Description string `json:"description"`
		}
		if err == nil {
			// Parse ambient.json if found
			if parseErr := json.Unmarshal(ambientData, &ambientConfig); parseErr != nil {
				log.Printf("ListOOTBWorkflows: failed to parse ambient.json for %s: %v", entryName, parseErr)
			}
		}

		// Use ambient.json values or fallback to directory name
		workflowName := ambientConfig.Name
		if workflowName == "" {
			workflowName = strings.ReplaceAll(entryName, "-", " ")
			workflowName = strings.Title(workflowName)
		}

		workflows = append(workflows, OOTBWorkflow{
			ID:          entryName,
			Name:        workflowName,
			Description: ambientConfig.Description,
			GitURL:      ootbRepo,
			Branch:      ootbBranch,
			Path:        fmt.Sprintf("%s/%s", ootbWorkflowsPath, entryName),
			Enabled:     true,
		})
	}

	log.Printf("ListOOTBWorkflows: discovered %d workflows from %s", len(workflows), ootbRepo)
	c.JSON(http.StatusOK, gin.H{"workflows": workflows})
}

func DeleteSession(c *gin.Context) {
	project := c.GetString("project")
	sessionName := c.Param("sessionName")
	reqK8s, reqDyn := GetK8sClientsForRequest(c)
	_ = reqK8s
	gvr := GetAgenticSessionV1Alpha1Resource()

	err := reqDyn.Resource(gvr).Namespace(project).Delete(context.TODO(), sessionName, v1.DeleteOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			c.JSON(http.StatusNotFound, gin.H{"error": "Session not found"})
			return
		}
		log.Printf("Failed to delete agentic session %s in project %s: %v", sessionName, project, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete agentic session"})
		return
	}

	c.Status(http.StatusNoContent)
}

func CloneSession(c *gin.Context) {
	project := c.GetString("project")
	sessionName := c.Param("sessionName")
	_, reqDyn := GetK8sClientsForRequest(c)

	var req types.CloneSessionRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	gvr := GetAgenticSessionV1Alpha1Resource()

	// Get source session
	sourceItem, err := reqDyn.Resource(gvr).Namespace(project).Get(context.TODO(), sessionName, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			c.JSON(http.StatusNotFound, gin.H{"error": "Source session not found"})
			return
		}
		log.Printf("Failed to get source agentic session %s in project %s: %v", sessionName, project, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get source agentic session"})
		return
	}

	// Validate target project exists and is managed by Ambient via OpenShift Project
	projGvr := GetOpenShiftProjectResource()
	projObj, err := reqDyn.Resource(projGvr).Get(context.TODO(), req.TargetProject, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			c.JSON(http.StatusNotFound, gin.H{"error": "Target project not found"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to validate target project"})
		return
	}

	isAmbient := false
	if meta, ok := projObj.Object["metadata"].(map[string]interface{}); ok {
		if raw, ok := meta["labels"].(map[string]interface{}); ok {
			if v, ok := raw["ambient-code.io/managed"].(string); ok && v == "true" {
				isAmbient = true
			}
		}
	}
	if !isAmbient {
		c.JSON(http.StatusForbidden, gin.H{"error": "Target project is not managed by Ambient"})
		return
	}

	// Ensure unique target session name in target namespace; if exists, append "-duplicate" (and numeric suffix)
	newName := strings.TrimSpace(req.NewSessionName)
	if newName == "" {
		newName = sessionName
	}
	finalName := newName
	conflicted := false
	for i := 0; i < 50; i++ {
		_, getErr := reqDyn.Resource(gvr).Namespace(req.TargetProject).Get(context.TODO(), finalName, v1.GetOptions{})
		if errors.IsNotFound(getErr) {
			break
		}
		if getErr != nil && !errors.IsNotFound(getErr) {
			// On unexpected error, still attempt to proceed with a duplicate suffix to reduce collision chance
			log.Printf("cloneSession: name check encountered error for %s/%s: %v", req.TargetProject, finalName, getErr)
		}
		conflicted = true
		if i == 0 {
			finalName = fmt.Sprintf("%s-duplicate", newName)
		} else {
			finalName = fmt.Sprintf("%s-duplicate-%d", newName, i+1)
		}
	}

	// Create cloned session
	clonedSession := map[string]interface{}{
		"apiVersion": "vteam.ambient-code/v1alpha1",
		"kind":       "AgenticSession",
		"metadata": map[string]interface{}{
			"name":      finalName,
			"namespace": req.TargetProject,
		},
		"spec": sourceItem.Object["spec"],
		"status": map[string]interface{}{
			"phase": "Pending",
		},
	}

	// Update project in spec
	clonedSpec := clonedSession["spec"].(map[string]interface{})
	clonedSpec["project"] = req.TargetProject
	if conflicted {
		if dn, ok := clonedSpec["displayName"].(string); ok && strings.TrimSpace(dn) != "" {
			clonedSpec["displayName"] = fmt.Sprintf("%s (Duplicate)", dn)
		} else {
			clonedSpec["displayName"] = fmt.Sprintf("%s (Duplicate)", finalName)
		}
	}

	obj := &unstructured.Unstructured{Object: clonedSession}

	created, err := reqDyn.Resource(gvr).Namespace(req.TargetProject).Create(context.TODO(), obj, v1.CreateOptions{})
	if err != nil {
		log.Printf("Failed to create cloned agentic session in project %s: %v", req.TargetProject, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create cloned agentic session"})
		return
	}

	// Parse and return created session
	session := types.AgenticSession{
		APIVersion: created.GetAPIVersion(),
		Kind:       created.GetKind(),
		Metadata:   created.Object["metadata"].(map[string]interface{}),
	}

	if spec, ok := created.Object["spec"].(map[string]interface{}); ok {
		session.Spec = parseSpec(spec)
	}

	if status, ok := created.Object["status"].(map[string]interface{}); ok {
		session.Status = parseStatus(status)
	}

	c.JSON(http.StatusCreated, session)
}

// ensureRunnerRolePermissions updates the runner role to ensure it has all required permissions
// This is useful for existing sessions that were created before we added new permissions
func ensureRunnerRolePermissions(c *gin.Context, reqK8s *kubernetes.Clientset, project string, sessionName string) error {
	roleName := fmt.Sprintf("ambient-session-%s-role", sessionName)

	// Get existing role
	existingRole, err := reqK8s.RbacV1().Roles(project).Get(c.Request.Context(), roleName, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			log.Printf("Role %s not found for session %s - will be created by operator", roleName, sessionName)
			return nil
		}
		return fmt.Errorf("get role: %w", err)
	}

	// Check if role has selfsubjectaccessreviews permission
	hasSelfSubjectAccessReview := false
	for _, rule := range existingRole.Rules {
		for _, apiGroup := range rule.APIGroups {
			if apiGroup == "authorization.k8s.io" {
				for _, resource := range rule.Resources {
					if resource == "selfsubjectaccessreviews" {
						hasSelfSubjectAccessReview = true
						break
					}
				}
			}
		}
	}

	if hasSelfSubjectAccessReview {
		log.Printf("Role %s already has selfsubjectaccessreviews permission", roleName)
		return nil
	}

	// Add missing permission
	log.Printf("Updating role %s to add selfsubjectaccessreviews permission", roleName)
	existingRole.Rules = append(existingRole.Rules, rbacv1.PolicyRule{
		APIGroups: []string{"authorization.k8s.io"},
		Resources: []string{"selfsubjectaccessreviews"},
		Verbs:     []string{"create"},
	})

	_, err = reqK8s.RbacV1().Roles(project).Update(c.Request.Context(), existingRole, v1.UpdateOptions{})
	if err != nil {
		return fmt.Errorf("update role: %w", err)
	}

	log.Printf("Successfully updated role %s with selfsubjectaccessreviews permission", roleName)
	return nil
}

func StartSession(c *gin.Context) {
	project := c.GetString("project")
	sessionName := c.Param("sessionName")
	reqK8s, reqDyn := GetK8sClientsForRequest(c)
	gvr := GetAgenticSessionV1Alpha1Resource()

	// Get current resource
	item, err := reqDyn.Resource(gvr).Namespace(project).Get(context.TODO(), sessionName, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			c.JSON(http.StatusNotFound, gin.H{"error": "Session not found"})
			return
		}
		log.Printf("Failed to get agentic session %s in project %s: %v", sessionName, project, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get agentic session"})
		return
	}

	// Ensure runner role has required permissions (update if needed for existing sessions)
	if err := ensureRunnerRolePermissions(c, reqK8s, project, sessionName); err != nil {
		log.Printf("Warning: failed to ensure runner role permissions for %s: %v", sessionName, err)
		// Non-fatal - continue with restart
	}

	// Clean up temp-content pod if it exists to free the PVC
	// This prevents Multi-Attach errors when the session job tries to mount the workspace
	if reqK8s != nil {
		tempPodName := fmt.Sprintf("temp-content-%s", sessionName)
		if err := reqK8s.CoreV1().Pods(project).Delete(c.Request.Context(), tempPodName, v1.DeleteOptions{}); err != nil {
			if !errors.IsNotFound(err) {
				log.Printf("StartSession: failed to delete temp-content pod %s (non-fatal): %v", tempPodName, err)
			}
		} else {
			log.Printf("StartSession: deleted temp-content pod %s to free PVC", tempPodName)
		}
	}

	// Check if this is a continuation (session is in a terminal phase)
	// Terminal phases from CRD: Completed, Failed, Stopped, Error
	isActualContinuation := false
	currentPhase := ""
	if currentStatus, ok := item.Object["status"].(map[string]interface{}); ok {
		if phase, ok := currentStatus["phase"].(string); ok {
			currentPhase = phase
			terminalPhases := []string{"Completed", "Failed", "Stopped", "Error"}
			for _, terminalPhase := range terminalPhases {
				if phase == terminalPhase {
					isActualContinuation = true
					log.Printf("StartSession: Detected continuation - session is in terminal phase: %s", phase)
					break
				}
			}
		}
	}

	if !isActualContinuation {
		log.Printf("StartSession: Not a continuation - current phase is: %s (not in terminal phases)", currentPhase)
	}

	// Only set parent session annotation if this is an actual continuation
	// Don't set it on first start, even though StartSession can be called for initial creation
	if isActualContinuation {
		annotations := item.GetAnnotations()
		if annotations == nil {
			annotations = make(map[string]string)
		}
		annotations["vteam.ambient-code/parent-session-id"] = sessionName
		item.SetAnnotations(annotations)
		log.Printf("StartSession: Set parent-session-id annotation to %s for continuation (has completion time)", sessionName)

		// For headless sessions being continued, force interactive mode
		if spec, ok := item.Object["spec"].(map[string]interface{}); ok {
			if interactive, ok := spec["interactive"].(bool); !ok || !interactive {
				// Session was headless, convert to interactive
				spec["interactive"] = true
				log.Printf("StartSession: Converting headless session to interactive for continuation")
			}
		}

		// Update the metadata and spec to persist the annotation and interactive flag
		item, err = reqDyn.Resource(gvr).Namespace(project).Update(context.TODO(), item, v1.UpdateOptions{})
		if err != nil {
			log.Printf("Failed to update agentic session metadata %s in project %s: %v", sessionName, project, err)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update session metadata"})
			return
		}

		// Regenerate runner token for continuation (old token may have expired)
		log.Printf("StartSession: Regenerating runner token for session continuation")
		if err := provisionRunnerTokenForSession(c, reqK8s, reqDyn, project, sessionName); err != nil {
			log.Printf("Warning: failed to regenerate runner token for session %s/%s: %v", project, sessionName, err)
			// Non-fatal: continue anyway, operator may retry
		} else {
			log.Printf("StartSession: Successfully regenerated runner token for continuation")

			// Delete the old job so operator creates a new one
			// This ensures fresh token and clean state
			jobName := fmt.Sprintf("ambient-runner-%s", sessionName)
			log.Printf("StartSession: Deleting old job %s to allow operator to create fresh one", jobName)
			if err := reqK8s.BatchV1().Jobs(project).Delete(c.Request.Context(), jobName, v1.DeleteOptions{
				PropagationPolicy: func() *v1.DeletionPropagation { p := v1.DeletePropagationBackground; return &p }(),
			}); err != nil {
				if !errors.IsNotFound(err) {
					log.Printf("Warning: failed to delete old job %s: %v", jobName, err)
				} else {
					log.Printf("StartSession: Job %s already gone", jobName)
				}
			} else {
				log.Printf("StartSession: Successfully deleted old job %s", jobName)
			}
		}
	} else {
		log.Printf("StartSession: Not setting parent-session-id (first run, no completion time)")
	}

	// Now update status to trigger start (using the fresh object from Update)
	if item.Object["status"] == nil {
		item.Object["status"] = make(map[string]interface{})
	}

	status := item.Object["status"].(map[string]interface{})
	// Set to Pending so operator will process it (operator only acts on Pending phase)
	status["phase"] = "Pending"
	status["message"] = "Session restart requested"
	// Clear completion time from previous run
	delete(status, "completionTime")
	// Update start time for this run
	status["startTime"] = time.Now().Format(time.RFC3339)

	// Update the status subresource using backend SA (status updates require elevated permissions)
	if DynamicClient == nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "backend not initialized"})
		return
	}
	updated, err := DynamicClient.Resource(gvr).Namespace(project).UpdateStatus(context.TODO(), item, v1.UpdateOptions{})
	if err != nil {
		log.Printf("Failed to start agentic session %s in project %s: %v", sessionName, project, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to start agentic session"})
		return
	}

	// Parse and return updated session
	session := types.AgenticSession{
		APIVersion: updated.GetAPIVersion(),
		Kind:       updated.GetKind(),
		Metadata:   updated.Object["metadata"].(map[string]interface{}),
	}

	if spec, ok := updated.Object["spec"].(map[string]interface{}); ok {
		session.Spec = parseSpec(spec)
	}

	if status, ok := updated.Object["status"].(map[string]interface{}); ok {
		session.Status = parseStatus(status)
	}

	c.JSON(http.StatusAccepted, session)
}

func StopSession(c *gin.Context) {
	project := c.GetString("project")
	sessionName := c.Param("sessionName")
	reqK8s, reqDyn := GetK8sClientsForRequest(c)
	gvr := GetAgenticSessionV1Alpha1Resource()

	// Get current resource
	item, err := reqDyn.Resource(gvr).Namespace(project).Get(context.TODO(), sessionName, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			c.JSON(http.StatusNotFound, gin.H{"error": "Session not found"})
			return
		}
		log.Printf("Failed to get agentic session %s in project %s: %v", sessionName, project, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get agentic session"})
		return
	}

	// Check current status
	status, ok := item.Object["status"].(map[string]interface{})
	if !ok {
		status = make(map[string]interface{})
		item.Object["status"] = status
	}

	currentPhase, _ := status["phase"].(string)
	if currentPhase == "Completed" || currentPhase == "Failed" || currentPhase == "Stopped" {
		c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("Cannot stop session in %s state", currentPhase)})
		return
	}

	log.Printf("Attempting to stop agentic session %s in project %s (current phase: %s)", sessionName, project, currentPhase)

	// Get job name from status
	jobName, jobExists := status["jobName"].(string)
	if !jobExists || jobName == "" {
		// Try to derive job name if not in status
		jobName = fmt.Sprintf("%s-job", sessionName)
		log.Printf("Job name not in status, trying derived name: %s", jobName)
	}

	// Delete the job and its pods
	log.Printf("Attempting to delete job %s for session %s", jobName, sessionName)

	// First, delete the job itself with foreground propagation
	deletePolicy := v1.DeletePropagationForeground
	err = reqK8s.BatchV1().Jobs(project).Delete(context.TODO(), jobName, v1.DeleteOptions{
		PropagationPolicy: &deletePolicy,
	})
	if err != nil {
		if errors.IsNotFound(err) {
			log.Printf("Job %s not found (may have already completed or been deleted)", jobName)
		} else {
			log.Printf("Failed to delete job %s: %v", jobName, err)
			// Don't fail the request if job deletion fails - continue with status update
			log.Printf("Continuing with status update despite job deletion failure")
		}
	} else {
		log.Printf("Successfully deleted job %s for agentic session %s", jobName, sessionName)
	}

	// Then, explicitly delete all pods for this job (by job-name label)
	podSelector := fmt.Sprintf("job-name=%s", jobName)
	log.Printf("Deleting pods with job-name selector: %s", podSelector)
	err = reqK8s.CoreV1().Pods(project).DeleteCollection(context.TODO(), v1.DeleteOptions{}, v1.ListOptions{
		LabelSelector: podSelector,
	})
	if err != nil && !errors.IsNotFound(err) {
		log.Printf("Failed to delete pods for job %s: %v (continuing anyway)", jobName, err)
	} else {
		log.Printf("Successfully deleted pods for job %s", jobName)
	}

	// Also delete any pods labeled with this session (in case owner refs are lost)
	sessionPodSelector := fmt.Sprintf("agentic-session=%s", sessionName)
	log.Printf("Deleting pods with agentic-session selector: %s", sessionPodSelector)
	err = reqK8s.CoreV1().Pods(project).DeleteCollection(context.TODO(), v1.DeleteOptions{}, v1.ListOptions{
		LabelSelector: sessionPodSelector,
	})
	if err != nil && !errors.IsNotFound(err) {
		log.Printf("Failed to delete session pods: %v (continuing anyway)", err)
	} else {
		log.Printf("Successfully deleted session-labeled pods")
	}

	// Update status to Stopped
	status["phase"] = "Stopped"
	status["message"] = "Session stopped by user"
	status["completionTime"] = time.Now().Format(time.RFC3339)

	// Also set interactive: true in spec so session can be restarted
	if spec, ok := item.Object["spec"].(map[string]interface{}); ok {
		if interactive, ok := spec["interactive"].(bool); !ok || !interactive {
			log.Printf("Setting interactive: true for stopped session %s to allow restart", sessionName)
			spec["interactive"] = true
			// Update spec first (must use Update, not UpdateStatus)
			item, err = reqDyn.Resource(gvr).Namespace(project).Update(context.TODO(), item, v1.UpdateOptions{})
			if err != nil {
				log.Printf("Failed to update session spec for %s: %v (continuing with status update)", sessionName, err)
				// Continue anyway - status update is more important
			}
		}
	}

	// Update the resource using UpdateStatus for status subresource (using backend SA)
	if DynamicClient == nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "backend not initialized"})
		return
	}
	updated, err := DynamicClient.Resource(gvr).Namespace(project).UpdateStatus(context.TODO(), item, v1.UpdateOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			// Session was deleted while we were trying to update it
			log.Printf("Agentic session %s was deleted during stop operation", sessionName)
			c.JSON(http.StatusOK, gin.H{"message": "Session no longer exists (already deleted)"})
			return
		}
		log.Printf("Failed to update agentic session status %s: %v", sessionName, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update agentic session status"})
		return
	}

	// Parse and return updated session
	session := types.AgenticSession{
		APIVersion: updated.GetAPIVersion(),
		Kind:       updated.GetKind(),
		Metadata:   updated.Object["metadata"].(map[string]interface{}),
	}

	if spec, ok := updated.Object["spec"].(map[string]interface{}); ok {
		session.Spec = parseSpec(spec)
	}

	if status, ok := updated.Object["status"].(map[string]interface{}); ok {
		session.Status = parseStatus(status)
	}

	log.Printf("Successfully stopped agentic session %s", sessionName)
	c.JSON(http.StatusAccepted, session)
}

// UpdateSessionStatus writes selected fields to PVC-backed files and updates CR status.
// PUT /api/projects/:projectName/agentic-sessions/:sessionName/status
func UpdateSessionStatus(c *gin.Context) {
	project := c.GetString("project")
	sessionName := c.Param("sessionName")
	_, reqDyn := GetK8sClientsForRequest(c)

	var statusUpdate map[string]interface{}
	if err := c.ShouldBindJSON(&statusUpdate); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	gvr := GetAgenticSessionV1Alpha1Resource()

	// Get current resource
	item, err := reqDyn.Resource(gvr).Namespace(project).Get(context.TODO(), sessionName, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			c.JSON(http.StatusNotFound, gin.H{"error": "Session not found"})
			return
		}
		log.Printf("Failed to get agentic session %s in project %s: %v", sessionName, project, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get agentic session"})
		return
	}

	// Ensure status map
	if item.Object["status"] == nil {
		item.Object["status"] = make(map[string]interface{})
	}
	status := item.Object["status"].(map[string]interface{})

	// Accept standard fields and result summary fields from runner
	allowed := map[string]struct{}{
		"phase": {}, "completionTime": {}, "cost": {}, "message": {},
		"subtype": {}, "duration_ms": {}, "duration_api_ms": {}, "is_error": {},
		"num_turns": {}, "session_id": {}, "total_cost_usd": {}, "usage": {}, "result": {},
	}
	for k := range statusUpdate {
		if _, ok := allowed[k]; !ok {
			delete(statusUpdate, k)
		}
	}

	// Merge remaining fields into status
	for k, v := range statusUpdate {
		status[k] = v
	}

	// Update only the status subresource using backend SA (status updates require elevated permissions)
	if DynamicClient == nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "backend not initialized"})
		return
	}
	if _, err := DynamicClient.Resource(gvr).Namespace(project).UpdateStatus(context.TODO(), item, v1.UpdateOptions{}); err != nil {
		log.Printf("Failed to update agentic session status %s in project %s: %v", sessionName, project, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update agentic session status"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "agentic session status updated"})
}

// SpawnContentPod creates a temporary pod for workspace access on completed sessions
// POST /api/projects/:projectName/agentic-sessions/:sessionName/spawn-content-pod
func SpawnContentPod(c *gin.Context) {
	// Get project from context (set by middleware) or param
	project := c.GetString("project")
	if project == "" {
		project = c.Param("projectName")
	}
	sessionName := c.Param("sessionName")

	reqK8s, _ := GetK8sClientsForRequest(c)
	if reqK8s == nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
		return
	}

	podName := fmt.Sprintf("temp-content-%s", sessionName)

	// Check if already exists
	if existing, err := reqK8s.CoreV1().Pods(project).Get(c.Request.Context(), podName, v1.GetOptions{}); err == nil {
		ready := false
		for _, cond := range existing.Status.Conditions {
			if cond.Type == corev1.PodReady && cond.Status == corev1.ConditionTrue {
				ready = true
				break
			}
		}
		c.JSON(http.StatusOK, gin.H{"status": "exists", "podName": podName, "ready": ready})
		return
	}

	// Verify PVC exists
	pvcName := fmt.Sprintf("ambient-workspace-%s", sessionName)
	if _, err := reqK8s.CoreV1().PersistentVolumeClaims(project).Get(c.Request.Context(), pvcName, v1.GetOptions{}); err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "workspace PVC not found"})
		return
	}

	// Get content service image from env
	contentImage := os.Getenv("CONTENT_SERVICE_IMAGE")
	if contentImage == "" {
		contentImage = "quay.io/ambient_code/vteam_backend:latest"
	}
	imagePullPolicy := corev1.PullIfNotPresent
	if os.Getenv("IMAGE_PULL_POLICY") == "Always" {
		imagePullPolicy = corev1.PullAlways
	}

	// Create temporary pod
	pod := &corev1.Pod{
		ObjectMeta: v1.ObjectMeta{
			Name:      podName,
			Namespace: project,
			Labels: map[string]string{
				"app":                      "temp-content-service",
				"temp-content-for-session": sessionName,
			},
			Annotations: map[string]string{
				"vteam.ambient-code/ttl":        "900",
				"vteam.ambient-code/created-at": time.Now().Format(time.RFC3339),
			},
		},
		Spec: corev1.PodSpec{
			RestartPolicy: corev1.RestartPolicyNever,
			Containers: []corev1.Container{
				{
					Name:            "content",
					Image:           contentImage,
					ImagePullPolicy: imagePullPolicy,
					Env: []corev1.EnvVar{
						{Name: "CONTENT_SERVICE_MODE", Value: "true"},
						{Name: "STATE_BASE_DIR", Value: "/workspace"},
					},
					Ports: []corev1.ContainerPort{{ContainerPort: 8080, Name: "http"}},
					ReadinessProbe: &corev1.Probe{
						ProbeHandler: corev1.ProbeHandler{
							HTTPGet: &corev1.HTTPGetAction{
								Path: "/health",
								Port: intstr.FromString("http"),
							},
						},
						InitialDelaySeconds: 2,
						PeriodSeconds:       2,
					},
					VolumeMounts: []corev1.VolumeMount{
						{
							Name:      "workspace",
							MountPath: "/workspace",
							ReadOnly:  false,
						},
					},
					Resources: corev1.ResourceRequirements{
						Requests: corev1.ResourceList{
							corev1.ResourceCPU:    resource.MustParse("100m"),
							corev1.ResourceMemory: resource.MustParse("128Mi"),
						},
						Limits: corev1.ResourceList{
							corev1.ResourceCPU:    resource.MustParse("500m"),
							corev1.ResourceMemory: resource.MustParse("512Mi"),
						},
					},
				},
			},
			Volumes: []corev1.Volume{
				{
					Name: "workspace",
					VolumeSource: corev1.VolumeSource{
						PersistentVolumeClaim: &corev1.PersistentVolumeClaimVolumeSource{
							ClaimName: pvcName,
						},
					},
				},
			},
		},
	}

	// Create pod using backend SA (pod creation requires elevated permissions)
	if K8sClient == nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "backend not initialized"})
		return
	}
	created, err := K8sClient.CoreV1().Pods(project).Create(c.Request.Context(), pod, v1.CreateOptions{})
	if err != nil {
		log.Printf("Failed to create temp content pod: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("failed to create pod: %v", err)})
		return
	}

	// Create service
	svc := &corev1.Service{
		ObjectMeta: v1.ObjectMeta{
			Name:      fmt.Sprintf("temp-content-%s", sessionName),
			Namespace: project,
			Labels: map[string]string{
				"app":                      "temp-content-service",
				"temp-content-for-session": sessionName,
			},
			OwnerReferences: []v1.OwnerReference{
				{
					APIVersion: "v1",
					Kind:       "Pod",
					Name:       podName,
					UID:        created.UID,
					Controller: types.BoolPtr(true),
				},
			},
		},
		Spec: corev1.ServiceSpec{
			Selector: map[string]string{
				"temp-content-for-session": sessionName,
			},
			Ports: []corev1.ServicePort{
				{Port: 8080, TargetPort: intstr.FromString("http")},
			},
		},
	}

	// Create service using backend SA
	if _, err := K8sClient.CoreV1().Services(project).Create(c.Request.Context(), svc, v1.CreateOptions{}); err != nil && !errors.IsAlreadyExists(err) {
		log.Printf("Failed to create temp service: %v", err)
	}

	c.JSON(http.StatusOK, gin.H{
		"status":  "creating",
		"podName": podName,
	})
}

// GetContentPodStatus checks if temporary content pod is ready
// GET /api/projects/:projectName/agentic-sessions/:sessionName/content-pod-status
func GetContentPodStatus(c *gin.Context) {
	// Get project from context (set by middleware) or param
	project := c.GetString("project")
	if project == "" {
		project = c.Param("projectName")
	}
	sessionName := c.Param("sessionName")

	reqK8s, _ := GetK8sClientsForRequest(c)
	if reqK8s == nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
		return
	}

	podName := fmt.Sprintf("temp-content-%s", sessionName)
	pod, err := reqK8s.CoreV1().Pods(project).Get(c.Request.Context(), podName, v1.GetOptions{})
	if err != nil {
		if errors.IsNotFound(err) {
			c.JSON(http.StatusNotFound, gin.H{"status": "not_found"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get pod"})
		return
	}

	ready := false
	for _, cond := range pod.Status.Conditions {
		if cond.Type == corev1.PodReady && cond.Status == corev1.ConditionTrue {
			ready = true
			break
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"status":    string(pod.Status.Phase),
		"ready":     ready,
		"podName":   podName,
		"createdAt": pod.CreationTimestamp.Format(time.RFC3339),
	})
}

// DeleteContentPod removes temporary content pod
// DELETE /api/projects/:projectName/agentic-sessions/:sessionName/content-pod
func DeleteContentPod(c *gin.Context) {
	// Get project from context (set by middleware) or param
	project := c.GetString("project")
	if project == "" {
		project = c.Param("projectName")
	}
	sessionName := c.Param("sessionName")

	reqK8s, _ := GetK8sClientsForRequest(c)
	if reqK8s == nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
		return
	}

	podName := fmt.Sprintf("temp-content-%s", sessionName)
	err := reqK8s.CoreV1().Pods(project).Delete(c.Request.Context(), podName, v1.DeleteOptions{})
	if err != nil && !errors.IsNotFound(err) {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to delete pod"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "content pod deleted"})
}

// GetSessionK8sResources returns job, pod, and PVC information for a session
// GET /api/projects/:projectName/agentic-sessions/:sessionName/k8s-resources
func GetSessionK8sResources(c *gin.Context) {
	// Get project from context (set by middleware) or param
	project := c.GetString("project")
	if project == "" {
		project = c.Param("projectName")
	}
	sessionName := c.Param("sessionName")

	reqK8s, reqDyn := GetK8sClientsForRequest(c)
	if reqK8s == nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
		return
	}

	// Get session to find job name
	gvr := GetAgenticSessionV1Alpha1Resource()
	session, err := reqDyn.Resource(gvr).Namespace(project).Get(c.Request.Context(), sessionName, v1.GetOptions{})
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "session not found"})
		return
	}

	status, _ := session.Object["status"].(map[string]interface{})
	jobName, _ := status["jobName"].(string)
	if jobName == "" {
		jobName = fmt.Sprintf("%s-job", sessionName)
	}

	result := map[string]interface{}{}

	// Get Job status
	job, err := reqK8s.BatchV1().Jobs(project).Get(c.Request.Context(), jobName, v1.GetOptions{})
	jobExists := err == nil

	if jobExists {
		result["jobName"] = jobName
		jobStatus := "Unknown"
		if job.Status.Active > 0 {
			jobStatus = "Active"
		} else if job.Status.Succeeded > 0 {
			jobStatus = "Succeeded"
		} else if job.Status.Failed > 0 {
			jobStatus = "Failed"
		}
		result["jobStatus"] = jobStatus
		result["jobConditions"] = job.Status.Conditions
	} else if errors.IsNotFound(err) {
		// Job not found - don't return job info at all
		log.Printf("GetSessionK8sResources: Job %s not found, omitting from response", jobName)
		// Don't include jobName or jobStatus in result
	} else {
		// Other error - still show job name but with error status
		result["jobName"] = jobName
		result["jobStatus"] = "Error"
		log.Printf("GetSessionK8sResources: Error getting job %s: %v", jobName, err)
	}

	// Get Pods for this job (only if job exists)
	podInfos := []map[string]interface{}{}
	if jobExists {
		pods, err := reqK8s.CoreV1().Pods(project).List(c.Request.Context(), v1.ListOptions{
			LabelSelector: fmt.Sprintf("job-name=%s", jobName),
		})
		if err == nil {
			for _, pod := range pods.Items {
				// Check if pod is terminating (has DeletionTimestamp)
				podPhase := string(pod.Status.Phase)
				if pod.DeletionTimestamp != nil {
					podPhase = "Terminating"
				}

				containerInfos := []map[string]interface{}{}
				for _, cs := range pod.Status.ContainerStatuses {
					state := "Unknown"
					var exitCode *int32
					var reason string
					if cs.State.Running != nil {
						state = "Running"
						// If pod is terminating but container still shows running, mark it as terminating
						if pod.DeletionTimestamp != nil {
							state = "Terminating"
						}
					} else if cs.State.Terminated != nil {
						state = "Terminated"
						exitCode = &cs.State.Terminated.ExitCode
						reason = cs.State.Terminated.Reason
					} else if cs.State.Waiting != nil {
						state = "Waiting"
						reason = cs.State.Waiting.Reason
					}
					containerInfos = append(containerInfos, map[string]interface{}{
						"name":     cs.Name,
						"state":    state,
						"exitCode": exitCode,
						"reason":   reason,
					})
				}
				podInfos = append(podInfos, map[string]interface{}{
					"name":       pod.Name,
					"phase":      podPhase,
					"containers": containerInfos,
				})
			}
		}
	}

	// Check for temp-content pod
	tempPodName := fmt.Sprintf("temp-content-%s", sessionName)
	tempPod, err := reqK8s.CoreV1().Pods(project).Get(c.Request.Context(), tempPodName, v1.GetOptions{})
	if err == nil {
		tempPodPhase := string(tempPod.Status.Phase)
		if tempPod.DeletionTimestamp != nil {
			tempPodPhase = "Terminating"
		}

		containerInfos := []map[string]interface{}{}
		for _, cs := range tempPod.Status.ContainerStatuses {
			state := "Unknown"
			var exitCode *int32
			var reason string
			if cs.State.Running != nil {
				state = "Running"
				// If pod is terminating but container still shows running, mark as terminating
				if tempPod.DeletionTimestamp != nil {
					state = "Terminating"
				}
			} else if cs.State.Terminated != nil {
				state = "Terminated"
				exitCode = &cs.State.Terminated.ExitCode
				reason = cs.State.Terminated.Reason
			} else if cs.State.Waiting != nil {
				state = "Waiting"
				reason = cs.State.Waiting.Reason
			}
			containerInfos = append(containerInfos, map[string]interface{}{
				"name":     cs.Name,
				"state":    state,
				"exitCode": exitCode,
				"reason":   reason,
			})
		}
		podInfos = append(podInfos, map[string]interface{}{
			"name":       tempPod.Name,
			"phase":      tempPodPhase,
			"containers": containerInfos,
			"isTempPod":  true,
		})
	}

	result["pods"] = podInfos

	// Get PVC info - always use session's own PVC name
	// Note: If session was created with parent_session_id (via API), the operator handles PVC reuse
	pvcName := fmt.Sprintf("ambient-workspace-%s", sessionName)
	pvc, err := reqK8s.CoreV1().PersistentVolumeClaims(project).Get(c.Request.Context(), pvcName, v1.GetOptions{})
	result["pvcName"] = pvcName
	if err == nil {
		result["pvcExists"] = true
		if storage, ok := pvc.Status.Capacity[corev1.ResourceStorage]; ok {
			result["pvcSize"] = storage.String()
		}
	} else {
		result["pvcExists"] = false
	}

	c.JSON(http.StatusOK, result)
}

// setRepoStatus updates status.repos[idx] with status and diff info
func setRepoStatus(dyn dynamic.Interface, project, sessionName string, repoIndex int, newStatus string) error {
	gvr := GetAgenticSessionV1Alpha1Resource()
	item, err := dyn.Resource(gvr).Namespace(project).Get(context.TODO(), sessionName, v1.GetOptions{})
	if err != nil {
		return err
	}

	// Get repo name from spec.repos[repoIndex]
	spec, _ := item.Object["spec"].(map[string]interface{})
	specRepos, _ := spec["repos"].([]interface{})
	if repoIndex < 0 || repoIndex >= len(specRepos) {
		return fmt.Errorf("repo index out of range")
	}
	specRepo, _ := specRepos[repoIndex].(map[string]interface{})
	repoName := ""
	if name, ok := specRepo["name"].(string); ok {
		repoName = name
	} else if input, ok := specRepo["input"].(map[string]interface{}); ok {
		if url, ok := input["url"].(string); ok {
			repoName = DeriveRepoFolderFromURL(url)
		}
	}
	if repoName == "" {
		repoName = fmt.Sprintf("repo-%d", repoIndex)
	}

	// Ensure status.repos exists
	if item.Object["status"] == nil {
		item.Object["status"] = make(map[string]interface{})
	}
	status := item.Object["status"].(map[string]interface{})
	statusRepos, _ := status["repos"].([]interface{})
	if statusRepos == nil {
		statusRepos = []interface{}{}
	}

	// Find or create status entry for this repo
	repoStatus := map[string]interface{}{
		"name":         repoName,
		"status":       newStatus,
		"last_updated": time.Now().Format(time.RFC3339),
	}

	// Update existing or append new
	found := false
	for i, r := range statusRepos {
		if rm, ok := r.(map[string]interface{}); ok {
			if n, ok := rm["name"].(string); ok && n == repoName {
				rm["status"] = newStatus
				rm["last_updated"] = time.Now().Format(time.RFC3339)
				statusRepos[i] = rm
				found = true
				break
			}
		}
	}
	if !found {
		statusRepos = append(statusRepos, repoStatus)
	}

	status["repos"] = statusRepos
	item.Object["status"] = status

	updated, err := dyn.Resource(gvr).Namespace(project).UpdateStatus(context.TODO(), item, v1.UpdateOptions{})
	if err != nil {
		log.Printf("setRepoStatus: update failed project=%s session=%s repoIndex=%d status=%s err=%v", project, sessionName, repoIndex, newStatus, err)
		return err
	}
	if updated != nil {
		log.Printf("setRepoStatus: update ok project=%s session=%s repo=%s status=%s", project, sessionName, repoName, newStatus)
	}
	return nil
}

// ListSessionWorkspace proxies to per-job content service for directory listing.
func ListSessionWorkspace(c *gin.Context) {
	// Get project from context (set by middleware) or param
	project := c.GetString("project")
	if project == "" {
		project = c.Param("projectName")
	}
	session := c.Param("sessionName")

	if project == "" {
		log.Printf("ListSessionWorkspace: project is empty, session=%s", session)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Project namespace required"})
		return
	}

	rel := strings.TrimSpace(c.Query("path"))
	// Build absolute workspace path using plain session (no url.PathEscape to match FS paths)
	absPath := "/sessions/" + session + "/workspace"
	if rel != "" {
		absPath += "/" + rel
	}

	// Call per-job service or temp service for completed sessions
	token := c.GetHeader("Authorization")
	if strings.TrimSpace(token) == "" {
		token = c.GetHeader("X-Forwarded-Access-Token")
	}

	// Try temp service first (for completed sessions), then regular service
	serviceName := fmt.Sprintf("temp-content-%s", session)
	reqK8s, _ := GetK8sClientsForRequest(c)
	if reqK8s != nil {
		if _, err := reqK8s.CoreV1().Services(project).Get(c.Request.Context(), serviceName, v1.GetOptions{}); err != nil {
			// Temp service doesn't exist, use regular service
			serviceName = fmt.Sprintf("ambient-content-%s", session)
		}
	} else {
		serviceName = fmt.Sprintf("ambient-content-%s", session)
	}

	endpoint := fmt.Sprintf("http://%s.%s.svc:8080", serviceName, project)
	u := fmt.Sprintf("%s/content/list?path=%s", endpoint, url.QueryEscape(absPath))
	log.Printf("ListSessionWorkspace: project=%s session=%s endpoint=%s", project, session, endpoint)
	req, _ := http.NewRequestWithContext(c.Request.Context(), http.MethodGet, u, nil)
	if strings.TrimSpace(token) != "" {
		req.Header.Set("Authorization", token)
	}
	client := &http.Client{Timeout: 4 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		log.Printf("ListSessionWorkspace: content service request failed: %v", err)
		// Soften error to 200 with empty list so UI doesn't spam
		c.JSON(http.StatusOK, gin.H{"items": []any{}})
		return
	}
	defer resp.Body.Close()
	b, _ := io.ReadAll(resp.Body)

	// If content service returns 404, check if it's because workspace doesn't exist yet
	if resp.StatusCode == http.StatusNotFound {
		log.Printf("ListSessionWorkspace: workspace not found (may not be created yet by runner)")
		// Return empty list instead of error for better UX during session startup
		c.JSON(http.StatusOK, gin.H{"items": []any{}})
		return
	}

	c.Data(resp.StatusCode, resp.Header.Get("Content-Type"), b)
}

// GetSessionWorkspaceFile reads a file via content service.
func GetSessionWorkspaceFile(c *gin.Context) {
	// Get project from context (set by middleware) or param
	project := c.GetString("project")
	if project == "" {
		project = c.Param("projectName")
	}
	session := c.Param("sessionName")

	if project == "" {
		log.Printf("GetSessionWorkspaceFile: project is empty, session=%s", session)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Project namespace required"})
		return
	}

	sub := strings.TrimPrefix(c.Param("path"), "/")
	absPath := "/sessions/" + session + "/workspace/" + sub
	token := c.GetHeader("Authorization")
	if strings.TrimSpace(token) == "" {
		token = c.GetHeader("X-Forwarded-Access-Token")
	}

	// Try temp service first (for completed sessions), then regular service
	serviceName := fmt.Sprintf("temp-content-%s", session)
	reqK8s, _ := GetK8sClientsForRequest(c)
	if reqK8s != nil {
		if _, err := reqK8s.CoreV1().Services(project).Get(c.Request.Context(), serviceName, v1.GetOptions{}); err != nil {
			serviceName = fmt.Sprintf("ambient-content-%s", session)
		}
	} else {
		serviceName = fmt.Sprintf("ambient-content-%s", session)
	}

	endpoint := fmt.Sprintf("http://%s.%s.svc:8080", serviceName, project)
	u := fmt.Sprintf("%s/content/file?path=%s", endpoint, url.QueryEscape(absPath))
	req, _ := http.NewRequestWithContext(c.Request.Context(), http.MethodGet, u, nil)
	if strings.TrimSpace(token) != "" {
		req.Header.Set("Authorization", token)
	}
	client := &http.Client{Timeout: 4 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		c.JSON(http.StatusServiceUnavailable, gin.H{"error": err.Error()})
		return
	}
	defer resp.Body.Close()
	b, _ := io.ReadAll(resp.Body)
	c.Data(resp.StatusCode, resp.Header.Get("Content-Type"), b)
}

// PutSessionWorkspaceFile writes a file via content service.
func PutSessionWorkspaceFile(c *gin.Context) {
	// Get project from context (set by middleware) or param
	project := c.GetString("project")
	if project == "" {
		project = c.Param("projectName")
	}
	session := c.Param("sessionName")

	if project == "" {
		log.Printf("PutSessionWorkspaceFile: project is empty, session=%s", session)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Project namespace required"})
		return
	}
	sub := strings.TrimPrefix(c.Param("path"), "/")
	absPath := "/sessions/" + session + "/workspace/" + sub
	token := c.GetHeader("Authorization")
	if strings.TrimSpace(token) == "" {
		token = c.GetHeader("X-Forwarded-Access-Token")
	}

	// Try temp service first (for completed sessions), then regular service
	serviceName := fmt.Sprintf("temp-content-%s", session)
	reqK8s, _ := GetK8sClientsForRequest(c)
	if reqK8s != nil {
		if _, err := reqK8s.CoreV1().Services(project).Get(c.Request.Context(), serviceName, v1.GetOptions{}); err != nil {
			// Temp service doesn't exist, use regular service
			serviceName = fmt.Sprintf("ambient-content-%s", session)
		}
	} else {
		serviceName = fmt.Sprintf("ambient-content-%s", session)
	}

	endpoint := fmt.Sprintf("http://%s.%s.svc:8080", serviceName, project)
	log.Printf("PutSessionWorkspaceFile: using service %s for session %s", serviceName, session)
	payload, _ := io.ReadAll(c.Request.Body)
	wreq := struct {
		Path     string `json:"path"`
		Content  string `json:"content"`
		Encoding string `json:"encoding"`
	}{Path: absPath, Content: string(payload), Encoding: "utf8"}
	b, _ := json.Marshal(wreq)
	req, _ := http.NewRequestWithContext(c.Request.Context(), http.MethodPost, endpoint+"/content/write", strings.NewReader(string(b)))
	if strings.TrimSpace(token) != "" {
		req.Header.Set("Authorization", token)
	}
	req.Header.Set("Content-Type", "application/json")
	client := &http.Client{Timeout: 4 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		c.JSON(http.StatusServiceUnavailable, gin.H{"error": err.Error()})
		return
	}
	defer resp.Body.Close()
	rb, _ := io.ReadAll(resp.Body)
	c.Data(resp.StatusCode, resp.Header.Get("Content-Type"), rb)
}

// PushSessionRepo proxies a push request for a given session repo to the per-job content service.
// POST /api/projects/:projectName/agentic-sessions/:sessionName/github/push
// Body: { repoIndex: number, commitMessage?: string, branch?: string }
func PushSessionRepo(c *gin.Context) {
	project := c.Param("projectName")
	session := c.Param("sessionName")

	var body struct {
		RepoIndex     int    `json:"repoIndex"`
		CommitMessage string `json:"commitMessage"`
	}
	if err := c.BindJSON(&body); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid JSON body"})
		return
	}
	log.Printf("pushSessionRepo: request project=%s session=%s repoIndex=%d commitLen=%d", project, session, body.RepoIndex, len(strings.TrimSpace(body.CommitMessage)))

	// Try temp service first (for completed sessions), then regular service
	serviceName := fmt.Sprintf("temp-content-%s", session)
	reqK8s, _ := GetK8sClientsForRequest(c)
	if reqK8s != nil {
		if _, err := reqK8s.CoreV1().Services(project).Get(c.Request.Context(), serviceName, v1.GetOptions{}); err != nil {
			serviceName = fmt.Sprintf("ambient-content-%s", session)
		}
	} else {
		serviceName = fmt.Sprintf("ambient-content-%s", session)
	}
	endpoint := fmt.Sprintf("http://%s.%s.svc:8080", serviceName, project)
	log.Printf("pushSessionRepo: using service %s", serviceName)

	// Simplified: 1) get session; 2) compute repoPath from INPUT repo folder; 3) get output url/branch; 4) proxy
	resolvedRepoPath := ""
	// default branch when not defined on output
	resolvedBranch := fmt.Sprintf("sessions/%s", session)
	resolvedOutputURL := ""
	if _, reqDyn := GetK8sClientsForRequest(c); reqDyn != nil {
		gvr := GetAgenticSessionV1Alpha1Resource()
		obj, err := reqDyn.Resource(gvr).Namespace(project).Get(c.Request.Context(), session, v1.GetOptions{})
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "failed to read session"})
			return
		}
		spec, _ := obj.Object["spec"].(map[string]interface{})
		repos, _ := spec["repos"].([]interface{})
		if body.RepoIndex < 0 || body.RepoIndex >= len(repos) {
			c.JSON(http.StatusBadRequest, gin.H{"error": "invalid repo index"})
			return
		}
		rm, _ := repos[body.RepoIndex].(map[string]interface{})
		// Derive repoPath from input URL folder name
		if in, ok := rm["input"].(map[string]interface{}); ok {
			if urlv, ok2 := in["url"].(string); ok2 && strings.TrimSpace(urlv) != "" {
				folder := DeriveRepoFolderFromURL(strings.TrimSpace(urlv))
				if folder != "" {
					resolvedRepoPath = fmt.Sprintf("/sessions/%s/workspace/%s", session, folder)
				}
			}
		}
		if out, ok := rm["output"].(map[string]interface{}); ok {
			if urlv, ok2 := out["url"].(string); ok2 && strings.TrimSpace(urlv) != "" {
				resolvedOutputURL = strings.TrimSpace(urlv)
			}
			if bs, ok2 := out["branch"].(string); ok2 && strings.TrimSpace(bs) != "" {
				resolvedBranch = strings.TrimSpace(bs)
			} else if bv, ok2 := out["branch"].(*string); ok2 && bv != nil && strings.TrimSpace(*bv) != "" {
				resolvedBranch = strings.TrimSpace(*bv)
			}
		}
	} else {
		c.JSON(http.StatusBadRequest, gin.H{"error": "no dynamic client"})
		return
	}
	// If input URL missing or unparsable, fall back to numeric index path (last resort)
	if strings.TrimSpace(resolvedRepoPath) == "" {
		if body.RepoIndex >= 0 {
			resolvedRepoPath = fmt.Sprintf("/sessions/%s/workspace/%d", session, body.RepoIndex)
		} else {
			resolvedRepoPath = fmt.Sprintf("/sessions/%s/workspace", session)
		}
	}
	if strings.TrimSpace(resolvedOutputURL) == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "missing output repo url"})
		return
	}
	log.Printf("pushSessionRepo: resolved repoPath=%q outputUrl=%q branch=%q", resolvedRepoPath, resolvedOutputURL, resolvedBranch)

	payload := map[string]interface{}{
		"repoPath":      resolvedRepoPath,
		"commitMessage": body.CommitMessage,
		"branch":        resolvedBranch,
		"outputRepoUrl": resolvedOutputURL,
	}
	b, _ := json.Marshal(payload)
	req, _ := http.NewRequestWithContext(c.Request.Context(), http.MethodPost, endpoint+"/content/github/push", strings.NewReader(string(b)))
	if v := c.GetHeader("Authorization"); v != "" {
		req.Header.Set("Authorization", v)
	}
	if v := c.GetHeader("X-Forwarded-Access-Token"); v != "" {
		req.Header.Set("X-Forwarded-Access-Token", v)
	}
	req.Header.Set("Content-Type", "application/json")

	// Attach short-lived GitHub token for one-shot authenticated push
	if reqK8s, reqDyn := GetK8sClientsForRequest(c); reqK8s != nil {
		// Load session to get authoritative userId
		gvr := GetAgenticSessionV1Alpha1Resource()
		obj, err := reqDyn.Resource(gvr).Namespace(project).Get(c.Request.Context(), session, v1.GetOptions{})
		if err == nil {
			spec, _ := obj.Object["spec"].(map[string]interface{})
			userID := ""
			if spec != nil {
				if uc, ok := spec["userContext"].(map[string]interface{}); ok {
					if v, ok := uc["userId"].(string); ok {
						userID = strings.TrimSpace(v)
					}
				}
			}
			if userID != "" {
				if tokenStr, err := GetGitHubToken(c.Request.Context(), reqK8s, reqDyn, project, userID); err == nil && strings.TrimSpace(tokenStr) != "" {
					req.Header.Set("X-GitHub-Token", tokenStr)
					log.Printf("pushSessionRepo: attached short-lived GitHub token for project=%s session=%s", project, session)
				} else if err != nil {
					log.Printf("pushSessionRepo: failed to resolve GitHub token: %v", err)
				}
			} else {
				log.Printf("pushSessionRepo: session %s/%s missing userContext.userId; proceeding without token", project, session)
			}
		} else {
			log.Printf("pushSessionRepo: failed to read session for token attach: %v", err)
		}
	}

	log.Printf("pushSessionRepo: proxy push project=%s session=%s repoIndex=%d repoPath=%s endpoint=%s", project, session, body.RepoIndex, resolvedRepoPath, endpoint+"/content/github/push")
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		c.JSON(http.StatusBadGateway, gin.H{"error": err.Error()})
		return
	}
	defer resp.Body.Close()
	bodyBytes, _ := io.ReadAll(resp.Body)
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		log.Printf("pushSessionRepo: content returned status=%d body.snip=%q", resp.StatusCode, func() string {
			s := string(bodyBytes)
			if len(s) > 1500 {
				return s[:1500] + "..."
			}
			return s
		}())
		c.Data(resp.StatusCode, "application/json", bodyBytes)
		return
	}
	if DynamicClient != nil {
		log.Printf("pushSessionRepo: setting repo status to 'pushed' for repoIndex=%d", body.RepoIndex)
		if err := setRepoStatus(DynamicClient, project, session, body.RepoIndex, "pushed"); err != nil {
			log.Printf("pushSessionRepo: setRepoStatus failed project=%s session=%s repoIndex=%d err=%v", project, session, body.RepoIndex, err)
		}
	} else {
		log.Printf("pushSessionRepo: backend SA not available; cannot set repo status project=%s session=%s", project, session)
	}
	log.Printf("pushSessionRepo: content push succeeded status=%d body.len=%d", resp.StatusCode, len(bodyBytes))
	c.Data(http.StatusOK, "application/json", bodyBytes)
}

// AbandonSessionRepo instructs sidecar to discard local changes for a repo.
func AbandonSessionRepo(c *gin.Context) {
	project := c.Param("projectName")
	session := c.Param("sessionName")
	var body struct {
		RepoIndex int    `json:"repoIndex"`
		RepoPath  string `json:"repoPath"`
	}
	if err := c.BindJSON(&body); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid JSON body"})
		return
	}

	// Try temp service first (for completed sessions), then regular service
	serviceName := fmt.Sprintf("temp-content-%s", session)
	reqK8s, _ := GetK8sClientsForRequest(c)
	if reqK8s != nil {
		if _, err := reqK8s.CoreV1().Services(project).Get(c.Request.Context(), serviceName, v1.GetOptions{}); err != nil {
			serviceName = fmt.Sprintf("ambient-content-%s", session)
		}
	} else {
		serviceName = fmt.Sprintf("ambient-content-%s", session)
	}
	endpoint := fmt.Sprintf("http://%s.%s.svc:8080", serviceName, project)
	log.Printf("AbandonSessionRepo: using service %s", serviceName)
	repoPath := strings.TrimSpace(body.RepoPath)
	if repoPath == "" {
		if body.RepoIndex >= 0 {
			repoPath = fmt.Sprintf("/sessions/%s/workspace/%d", session, body.RepoIndex)
		} else {
			repoPath = fmt.Sprintf("/sessions/%s/workspace", session)
		}
	}
	payload := map[string]interface{}{
		"repoPath": repoPath,
	}
	b, _ := json.Marshal(payload)
	req, _ := http.NewRequestWithContext(c.Request.Context(), http.MethodPost, endpoint+"/content/github/abandon", strings.NewReader(string(b)))
	if v := c.GetHeader("Authorization"); v != "" {
		req.Header.Set("Authorization", v)
	}
	if v := c.GetHeader("X-Forwarded-Access-Token"); v != "" {
		req.Header.Set("X-Forwarded-Access-Token", v)
	}
	req.Header.Set("Content-Type", "application/json")
	log.Printf("abandonSessionRepo: proxy abandon project=%s session=%s repoIndex=%d repoPath=%s", project, session, body.RepoIndex, repoPath)
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		c.JSON(http.StatusBadGateway, gin.H{"error": err.Error()})
		return
	}
	defer resp.Body.Close()
	bodyBytes, _ := io.ReadAll(resp.Body)
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		log.Printf("abandonSessionRepo: content returned status=%d body=%s", resp.StatusCode, string(bodyBytes))
		c.Data(resp.StatusCode, "application/json", bodyBytes)
		return
	}
	if DynamicClient != nil {
		if err := setRepoStatus(DynamicClient, project, session, body.RepoIndex, "abandoned"); err != nil {
			log.Printf("abandonSessionRepo: setRepoStatus failed project=%s session=%s repoIndex=%d err=%v", project, session, body.RepoIndex, err)
		}
	} else {
		log.Printf("abandonSessionRepo: backend SA not available; cannot set repo status project=%s session=%s", project, session)
	}
	c.Data(http.StatusOK, "application/json", bodyBytes)
}

// DiffSessionRepo proxies diff counts for a given session repo to the content sidecar.
// GET /api/projects/:projectName/agentic-sessions/:sessionName/github/diff?repoIndex=0&repoPath=...
func DiffSessionRepo(c *gin.Context) {
	project := c.Param("projectName")
	session := c.Param("sessionName")
	repoIndexStr := strings.TrimSpace(c.Query("repoIndex"))
	repoPath := strings.TrimSpace(c.Query("repoPath"))
	if repoPath == "" && repoIndexStr != "" {
		repoPath = fmt.Sprintf("/sessions/%s/workspace/%s", session, repoIndexStr)
	}
	if repoPath == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "missing repoPath/repoIndex"})
		return
	}

	// Try temp service first (for completed sessions), then regular service
	serviceName := fmt.Sprintf("temp-content-%s", session)
	reqK8s, _ := GetK8sClientsForRequest(c)
	if reqK8s != nil {
		if _, err := reqK8s.CoreV1().Services(project).Get(c.Request.Context(), serviceName, v1.GetOptions{}); err != nil {
			serviceName = fmt.Sprintf("ambient-content-%s", session)
		}
	} else {
		serviceName = fmt.Sprintf("ambient-content-%s", session)
	}
	endpoint := fmt.Sprintf("http://%s.%s.svc:8080", serviceName, project)
	log.Printf("DiffSessionRepo: using service %s", serviceName)
	url := fmt.Sprintf("%s/content/github/diff?repoPath=%s", endpoint, url.QueryEscape(repoPath))
	req, _ := http.NewRequestWithContext(c.Request.Context(), http.MethodGet, url, nil)
	if v := c.GetHeader("Authorization"); v != "" {
		req.Header.Set("Authorization", v)
	}
	if v := c.GetHeader("X-Forwarded-Access-Token"); v != "" {
		req.Header.Set("X-Forwarded-Access-Token", v)
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			"files": gin.H{
				"added":   0,
				"removed": 0,
			},
			"total_added":   0,
			"total_removed": 0,
		})
		return
	}
	defer resp.Body.Close()
	bodyBytes, _ := io.ReadAll(resp.Body)
	c.Data(resp.StatusCode, resp.Header.Get("Content-Type"), bodyBytes)
}

// GetGitStatus returns git status for a directory in the workspace
// GET /api/projects/:projectName/agentic-sessions/:sessionName/git/status?path=artifacts
func GetGitStatus(c *gin.Context) {
	project := c.Param("projectName")
	session := c.Param("sessionName")
	relativePath := strings.TrimSpace(c.Query("path"))

	if relativePath == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "path parameter required"})
		return
	}

	// Build absolute path
	absPath := fmt.Sprintf("/sessions/%s/workspace/%s", session, relativePath)

	// Get content service endpoint
	serviceName := fmt.Sprintf("temp-content-%s", session)
	reqK8s, _ := GetK8sClientsForRequest(c)
	if reqK8s != nil {
		if _, err := reqK8s.CoreV1().Services(project).Get(c.Request.Context(), serviceName, v1.GetOptions{}); err != nil {
			serviceName = fmt.Sprintf("ambient-content-%s", session)
		}
	} else {
		serviceName = fmt.Sprintf("ambient-content-%s", session)
	}

	endpoint := fmt.Sprintf("http://%s.%s.svc:8080/content/git-status?path=%s", serviceName, project, url.QueryEscape(absPath))

	req, _ := http.NewRequestWithContext(c.Request.Context(), http.MethodGet, endpoint, nil)
	if v := c.GetHeader("Authorization"); v != "" {
		req.Header.Set("Authorization", v)
	}

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		c.JSON(http.StatusServiceUnavailable, gin.H{"error": "content service unavailable"})
		return
	}
	defer resp.Body.Close()

	bodyBytes, _ := io.ReadAll(resp.Body)
	c.Data(resp.StatusCode, resp.Header.Get("Content-Type"), bodyBytes)
}

// ConfigureGitRemote initializes git and configures remote for a workspace directory
// Body: { path: string, remoteURL: string, branch: string }
// POST /api/projects/:projectName/agentic-sessions/:sessionName/git/configure-remote
func ConfigureGitRemote(c *gin.Context) {
	project := c.Param("projectName")
	sessionName := c.Param("sessionName")
	_, reqDyn := GetK8sClientsForRequest(c)

	var body struct {
		Path      string `json:"path" binding:"required"`
		RemoteURL string `json:"remoteUrl" binding:"required"`
		Branch    string `json:"branch"`
	}

	if err := c.BindJSON(&body); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request body"})
		return
	}

	if body.Branch == "" {
		body.Branch = "main"
	}

	// Build absolute path
	absPath := fmt.Sprintf("/sessions/%s/workspace/%s", sessionName, body.Path)

	// Get content service endpoint
	serviceName := fmt.Sprintf("temp-content-%s", sessionName)
	reqK8s, _ := GetK8sClientsForRequest(c)
	if reqK8s != nil {
		if _, err := reqK8s.CoreV1().Services(project).Get(c.Request.Context(), serviceName, v1.GetOptions{}); err != nil {
			serviceName = fmt.Sprintf("ambient-content-%s", sessionName)
		}
	} else {
		serviceName = fmt.Sprintf("ambient-content-%s", sessionName)
	}

	endpoint := fmt.Sprintf("http://%s.%s.svc:8080/content/git-configure-remote", serviceName, project)

	reqBody, _ := json.Marshal(map[string]interface{}{
		"path":      absPath,
		"remoteUrl": body.RemoteURL,
		"branch":    body.Branch,
	})

	req, _ := http.NewRequestWithContext(c.Request.Context(), http.MethodPost, endpoint, strings.NewReader(string(reqBody)))
	req.Header.Set("Content-Type", "application/json")
	if v := c.GetHeader("Authorization"); v != "" {
		req.Header.Set("Authorization", v)
	}

	// Get and forward GitHub token for authenticated remote URL
	if reqK8s != nil && reqDyn != nil && GetGitHubToken != nil {
		if token, err := GetGitHubToken(c.Request.Context(), reqK8s, reqDyn, project, ""); err == nil && token != "" {
			req.Header.Set("X-GitHub-Token", token)
			log.Printf("Forwarding GitHub token for remote configuration")
		}
	}

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		c.JSON(http.StatusServiceUnavailable, gin.H{"error": "content service unavailable"})
		return
	}
	defer resp.Body.Close()

	// If successful, persist remote config to session annotations for persistence
	if resp.StatusCode == http.StatusOK {
		// Persist remote config in annotations (supports multiple directories)
		gvr := GetAgenticSessionV1Alpha1Resource()
		item, err := reqDyn.Resource(gvr).Namespace(project).Get(c.Request.Context(), sessionName, v1.GetOptions{})
		if err == nil {
			metadata := item.Object["metadata"].(map[string]interface{})
			if metadata["annotations"] == nil {
				metadata["annotations"] = make(map[string]interface{})
			}
			anns := metadata["annotations"].(map[string]interface{})

			// Derive safe annotation key from path (use :: as separator to avoid conflicts with hyphens in path)
			annotationKey := strings.ReplaceAll(body.Path, "/", "::")
			anns[fmt.Sprintf("ambient-code.io/remote-%s-url", annotationKey)] = body.RemoteURL
			anns[fmt.Sprintf("ambient-code.io/remote-%s-branch", annotationKey)] = body.Branch

			_, err = reqDyn.Resource(gvr).Namespace(project).Update(c.Request.Context(), item, v1.UpdateOptions{})
			if err != nil {
				log.Printf("Warning: Failed to persist remote config to annotations: %v", err)
			} else {
				log.Printf("Persisted remote config for %s to session annotations: %s@%s", body.Path, body.RemoteURL, body.Branch)
			}
		}
	}

	bodyBytes, _ := io.ReadAll(resp.Body)
	c.Data(resp.StatusCode, resp.Header.Get("Content-Type"), bodyBytes)
}

// SynchronizeGit commits, pulls, and pushes changes for a workspace directory
// Body: { path: string, message?: string, branch?: string }
// POST /api/projects/:projectName/agentic-sessions/:sessionName/git/synchronize
func SynchronizeGit(c *gin.Context) {
	project := c.Param("projectName")
	session := c.Param("sessionName")

	var body struct {
		Path    string `json:"path" binding:"required"`
		Message string `json:"message"`
		Branch  string `json:"branch"`
	}

	if err := c.BindJSON(&body); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request body"})
		return
	}

	// Auto-generate commit message if not provided
	if body.Message == "" {
		body.Message = fmt.Sprintf("Session %s - %s", session, time.Now().Format(time.RFC3339))
	}

	// Build absolute path
	absPath := fmt.Sprintf("/sessions/%s/workspace/%s", session, body.Path)

	// Get content service endpoint
	serviceName := fmt.Sprintf("temp-content-%s", session)
	reqK8s, _ := GetK8sClientsForRequest(c)
	if reqK8s != nil {
		if _, err := reqK8s.CoreV1().Services(project).Get(c.Request.Context(), serviceName, v1.GetOptions{}); err != nil {
			serviceName = fmt.Sprintf("ambient-content-%s", session)
		}
	} else {
		serviceName = fmt.Sprintf("ambient-content-%s", session)
	}

	endpoint := fmt.Sprintf("http://%s.%s.svc:8080/content/git-sync", serviceName, project)

	reqBody, _ := json.Marshal(map[string]interface{}{
		"path":    absPath,
		"message": body.Message,
		"branch":  body.Branch,
	})

	req, _ := http.NewRequestWithContext(c.Request.Context(), http.MethodPost, endpoint, strings.NewReader(string(reqBody)))
	req.Header.Set("Content-Type", "application/json")
	if v := c.GetHeader("Authorization"); v != "" {
		req.Header.Set("Authorization", v)
	}

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		c.JSON(http.StatusServiceUnavailable, gin.H{"error": "content service unavailable"})
		return
	}
	defer resp.Body.Close()

	bodyBytes, _ := io.ReadAll(resp.Body)
	c.Data(resp.StatusCode, resp.Header.Get("Content-Type"), bodyBytes)
}

// GetGitMergeStatus checks if local and remote can merge cleanly
// GET /api/projects/:projectName/agentic-sessions/:sessionName/git/merge-status?path=&branch=
func GetGitMergeStatus(c *gin.Context) {
	project := c.Param("projectName")
	session := c.Param("sessionName")
	relativePath := strings.TrimSpace(c.Query("path"))
	branch := strings.TrimSpace(c.Query("branch"))

	if relativePath == "" {
		relativePath = "artifacts"
	}
	if branch == "" {
		branch = "main"
	}

	absPath := fmt.Sprintf("/sessions/%s/workspace/%s", session, relativePath)

	serviceName := fmt.Sprintf("temp-content-%s", session)
	reqK8s, _ := GetK8sClientsForRequest(c)
	if reqK8s != nil {
		if _, err := reqK8s.CoreV1().Services(project).Get(c.Request.Context(), serviceName, v1.GetOptions{}); err != nil {
			serviceName = fmt.Sprintf("ambient-content-%s", session)
		}
	} else {
		serviceName = fmt.Sprintf("ambient-content-%s", session)
	}

	endpoint := fmt.Sprintf("http://%s.%s.svc:8080/content/git-merge-status?path=%s&branch=%s",
		serviceName, project, url.QueryEscape(absPath), url.QueryEscape(branch))

	req, _ := http.NewRequestWithContext(c.Request.Context(), http.MethodGet, endpoint, nil)
	if v := c.GetHeader("Authorization"); v != "" {
		req.Header.Set("Authorization", v)
	}

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		c.JSON(http.StatusServiceUnavailable, gin.H{"error": "content service unavailable"})
		return
	}
	defer resp.Body.Close()

	bodyBytes, _ := io.ReadAll(resp.Body)
	c.Data(resp.StatusCode, resp.Header.Get("Content-Type"), bodyBytes)
}

// GitPullSession pulls changes from remote
// POST /api/projects/:projectName/agentic-sessions/:sessionName/git/pull
func GitPullSession(c *gin.Context) {
	project := c.Param("projectName")
	session := c.Param("sessionName")

	var body struct {
		Path   string `json:"path"`
		Branch string `json:"branch"`
	}

	if err := c.BindJSON(&body); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request body"})
		return
	}

	if body.Path == "" {
		body.Path = "artifacts"
	}
	if body.Branch == "" {
		body.Branch = "main"
	}

	absPath := fmt.Sprintf("/sessions/%s/workspace/%s", session, body.Path)

	serviceName := fmt.Sprintf("temp-content-%s", session)
	reqK8s, _ := GetK8sClientsForRequest(c)
	if reqK8s != nil {
		if _, err := reqK8s.CoreV1().Services(project).Get(c.Request.Context(), serviceName, v1.GetOptions{}); err != nil {
			serviceName = fmt.Sprintf("ambient-content-%s", session)
		}
	} else {
		serviceName = fmt.Sprintf("ambient-content-%s", session)
	}

	endpoint := fmt.Sprintf("http://%s.%s.svc:8080/content/git-pull", serviceName, project)

	reqBody, _ := json.Marshal(map[string]interface{}{
		"path":   absPath,
		"branch": body.Branch,
	})

	req, _ := http.NewRequestWithContext(c.Request.Context(), http.MethodPost, endpoint, strings.NewReader(string(reqBody)))
	req.Header.Set("Content-Type", "application/json")
	if v := c.GetHeader("Authorization"); v != "" {
		req.Header.Set("Authorization", v)
	}

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		c.JSON(http.StatusServiceUnavailable, gin.H{"error": "content service unavailable"})
		return
	}
	defer resp.Body.Close()

	bodyBytes, _ := io.ReadAll(resp.Body)
	c.Data(resp.StatusCode, resp.Header.Get("Content-Type"), bodyBytes)
}

// GitPushSession pushes changes to remote branch
// POST /api/projects/:projectName/agentic-sessions/:sessionName/git/push
func GitPushSession(c *gin.Context) {
	project := c.Param("projectName")
	session := c.Param("sessionName")

	var body struct {
		Path    string `json:"path"`
		Branch  string `json:"branch"`
		Message string `json:"message"`
	}

	if err := c.BindJSON(&body); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request body"})
		return
	}

	if body.Path == "" {
		body.Path = "artifacts"
	}
	if body.Branch == "" {
		body.Branch = "main"
	}
	if body.Message == "" {
		body.Message = fmt.Sprintf("Session %s artifacts", session)
	}

	absPath := fmt.Sprintf("/sessions/%s/workspace/%s", session, body.Path)

	serviceName := fmt.Sprintf("temp-content-%s", session)
	reqK8s, _ := GetK8sClientsForRequest(c)
	if reqK8s != nil {
		if _, err := reqK8s.CoreV1().Services(project).Get(c.Request.Context(), serviceName, v1.GetOptions{}); err != nil {
			serviceName = fmt.Sprintf("ambient-content-%s", session)
		}
	} else {
		serviceName = fmt.Sprintf("ambient-content-%s", session)
	}

	endpoint := fmt.Sprintf("http://%s.%s.svc:8080/content/git-push", serviceName, project)

	reqBody, _ := json.Marshal(map[string]interface{}{
		"path":    absPath,
		"branch":  body.Branch,
		"message": body.Message,
	})

	req, _ := http.NewRequestWithContext(c.Request.Context(), http.MethodPost, endpoint, strings.NewReader(string(reqBody)))
	req.Header.Set("Content-Type", "application/json")
	if v := c.GetHeader("Authorization"); v != "" {
		req.Header.Set("Authorization", v)
	}

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		c.JSON(http.StatusServiceUnavailable, gin.H{"error": "content service unavailable"})
		return
	}
	defer resp.Body.Close()

	bodyBytes, _ := io.ReadAll(resp.Body)
	c.Data(resp.StatusCode, resp.Header.Get("Content-Type"), bodyBytes)
}

// GitCreateBranchSession creates a new git branch
// POST /api/projects/:projectName/agentic-sessions/:sessionName/git/create-branch
func GitCreateBranchSession(c *gin.Context) {
	project := c.Param("projectName")
	session := c.Param("sessionName")

	var body struct {
		Path       string `json:"path"`
		BranchName string `json:"branchName" binding:"required"`
	}

	if err := c.BindJSON(&body); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request body"})
		return
	}

	if body.Path == "" {
		body.Path = "artifacts"
	}

	absPath := fmt.Sprintf("/sessions/%s/workspace/%s", session, body.Path)

	serviceName := fmt.Sprintf("temp-content-%s", session)
	reqK8s, _ := GetK8sClientsForRequest(c)
	if reqK8s != nil {
		if _, err := reqK8s.CoreV1().Services(project).Get(c.Request.Context(), serviceName, v1.GetOptions{}); err != nil {
			serviceName = fmt.Sprintf("ambient-content-%s", session)
		}
	} else {
		serviceName = fmt.Sprintf("ambient-content-%s", session)
	}

	endpoint := fmt.Sprintf("http://%s.%s.svc:8080/content/git-create-branch", serviceName, project)

	reqBody, _ := json.Marshal(map[string]interface{}{
		"path":       absPath,
		"branchName": body.BranchName,
	})

	req, _ := http.NewRequestWithContext(c.Request.Context(), http.MethodPost, endpoint, strings.NewReader(string(reqBody)))
	req.Header.Set("Content-Type", "application/json")
	if v := c.GetHeader("Authorization"); v != "" {
		req.Header.Set("Authorization", v)
	}

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		c.JSON(http.StatusServiceUnavailable, gin.H{"error": "content service unavailable"})
		return
	}
	defer resp.Body.Close()

	bodyBytes, _ := io.ReadAll(resp.Body)
	c.Data(resp.StatusCode, resp.Header.Get("Content-Type"), bodyBytes)
}

// GitListBranchesSession lists all remote branches
// GET /api/projects/:projectName/agentic-sessions/:sessionName/git/list-branches?path=
func GitListBranchesSession(c *gin.Context) {
	project := c.Param("projectName")
	session := c.Param("sessionName")
	relativePath := strings.TrimSpace(c.Query("path"))

	if relativePath == "" {
		relativePath = "artifacts"
	}

	absPath := fmt.Sprintf("/sessions/%s/workspace/%s", session, relativePath)

	serviceName := fmt.Sprintf("temp-content-%s", session)
	reqK8s, _ := GetK8sClientsForRequest(c)
	if reqK8s != nil {
		if _, err := reqK8s.CoreV1().Services(project).Get(c.Request.Context(), serviceName, v1.GetOptions{}); err != nil {
			serviceName = fmt.Sprintf("ambient-content-%s", session)
		}
	} else {
		serviceName = fmt.Sprintf("ambient-content-%s", session)
	}

	endpoint := fmt.Sprintf("http://%s.%s.svc:8080/content/git-list-branches?path=%s",
		serviceName, project, url.QueryEscape(absPath))

	req, _ := http.NewRequestWithContext(c.Request.Context(), http.MethodGet, endpoint, nil)
	if v := c.GetHeader("Authorization"); v != "" {
		req.Header.Set("Authorization", v)
	}

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		c.JSON(http.StatusServiceUnavailable, gin.H{"error": "content service unavailable"})
		return
	}
	defer resp.Body.Close()

	bodyBytes, _ := io.ReadAll(resp.Body)
	c.Data(resp.StatusCode, resp.Header.Get("Content-Type"), bodyBytes)
}
</file>

</files>
